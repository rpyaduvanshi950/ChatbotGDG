{
    "2050C": {
        "title": "C. Uninteresting Number",
        "description": "You are given a number nn with a length of no more than 105.\nYou can perform the following operation any number of times: choose one of its digits, square it, and replace the original digit with the result. The result must be a digit (that is, if you choose the digit x, then the value of x2 must be less than 10).\nIs it possible to obtain a number that is divisible by 9 through these operations?\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains the number n, without leading zeros. The length of the number does not exceed 105.\nIt is guaranteed that the sum of the lengths of the numbers across all test cases does not exceed 105.\nFor each test case, output \"YES\" if it is possible to obtain a number divisible by 9 using the described operations, and \"NO\" otherwise.\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nIn the first example, from the integer 123, it is possible to obtain only 123, 143, 129, and 149, none of which are divisible by 9.\nIn the second example, you need to replace the second digit with its square; then n will equal 342=38\u22c59.\nIn the third example, the integer is already divisible by 9.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "math",
            "*1200"
        ],
        "solution": "Solution not available"
    },
    "2050B": {
        "title": "B. Transfusion",
        "description": "You are given an array a of length n. In one operation, you can pick an index i from 2 to n\u22121 inclusive, and do one of the following actions:\n \nAfter each operation, all the values must be non-negative. Can you make all the elements equal after any number of operations?\nFirst line of input consists of one integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases.\nFirst line of each test case consists of one integer n (3\u2264n\u22642\u22c5105).\nSecond line of each test case consists of n integers ai (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n of all test cases doesn't exceed 2\u22c5105.\nFor each test case, print \"YES\" without quotation marks if it is possible to make all the elements equal after any number of operations; otherwise, print \"NO\" without quotation marks.\nYou can print answers in any register: \"yes\", \"YeS\", \"nO\" \u00a0\u2014 will also be considered correct.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2048C": {
        "title": "C. Kevin and Binary Strings",
        "description": "Kevin discovered a binary string s that starts with 1 in the river at Moonlit River Park and handed it over to you. Your task is to select two non-empty substrings\u2217 of s (which can be overlapped) to maximize the XOR value of these two substrings.\nThe XOR of two binary strings a and b is defined as the result of the \u2295 operation applied to the two numbers obtained by interpreting a and b as binary numbers, with the leftmost bit representing the highest value. Here, \u2295 denotes the bitwise XOR operation.\nThe strings you choose may have leading zeros.\n\u2217A string a is a substring of a string b if a can be obtained from b by the deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end. \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264103).\nThe only line of each test case contains a binary string s that starts with 1 (1\u2264|s|\u22645000).\nIt is guaranteed that the sum of |s| over all test cases doesn't exceed 5000.\nFor each test case, output four integers l1,r1,l2,r2 (1\u2264l1\u2264r1\u2264|s|, 1\u2264l2\u2264r2\u2264|s|)\u00a0\u2014 in the case the two substrings you selected are sl1sl1+1\u2026sr1 and sl2sl2+1\u2026sr2.\nIf there are multiple solutions, print any of them.\nIn the first test case, we can choose s2=1 and s1s2s3=111, and 1\u2295111=110. It can be proven that it is impossible to obtain a larger result. Additionally, l1=3, r1=3, l2=1, r2=3 is also a valid solution.\nIn the second test case, s1s2s3=100, s1s2s3s4=1000, the result is 100\u22951000=1100, which is the maximum.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "greedy",
            "implementation",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2046A": {
        "title": "A. Swap Columns and Find a Path",
        "description": " \nThere is a matrix consisting of 2 rows and n columns. The rows are numbered from 1 to 2 from top to bottom; the columns are numbered from 1 to n from left to right. Let's denote the cell on the intersection of the i-th row and the j-th column as (i,j). Each cell contains an integer; initially, the integer in the cell (i,j) is ai,j.\nYou can perform the following operation any number of times (possibly zero):\nAfter performing the operations, you have to choose a path from the cell (1,1) to the cell (2,n). For every cell (i,j) in the path except for the last, the next cell should be either (i+1,j) or (i,j+1). Obviously, the path cannot go outside the matrix.\nThe cost of the path is the sum of all integers in all (n+1) cells belonging to the path. You have to perform the operations and choose a path so that its cost is maximum possible.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22645000). The description of the test cases follows. \nEach test case consists of three lines:\nIt is guaranteed that the sum of n over all test cases does not exceed 5000. \nFor each test case, print one integer \u2014 the maximum cost of a path you can obtain.\nHere are the explanations of the first three test cases of the example. The left matrix is the matrix given in the input, the right one is the state of the matrix after several column swaps (possibly zero). The optimal path is highlighted in green.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2044D": {
        "title": "D. Harder Problem",
        "description": "Given a sequence of positive integers, a positive integer is called a mode of the sequence if it occurs the maximum number of times that any positive integer occurs. For example, the mode of [2,2,3] is 2. Any of 9, 8, or 7 can be considered to be a mode of the sequence [9,9,8,8,7,7]. \nYou gave UFO an array a of length n. To thank you, UFO decides to construct another array b of length n such that ai is a mode of the sequence [b1,b2,\u2026,bi] for all 1\u2264i\u2264n. \nHowever, UFO doesn't know how to construct array b, so you must help her. Note that 1\u2264bi\u2264n must hold for your array for all 1\u2264i\u2264n.\nThe first line contains t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105) \u2014 the length of a.\nThe following line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n numbers b1,b2,\u2026,bn (1\u2264bi\u2264n) on a new line. It can be shown that b can always be constructed. If there are multiple possible arrays, you may print any.\nLet's verify the correctness for our sample output in test case 2.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2041E": {
        "title": "E. Beautiful Array",
        "description": "A-Ming's birthday is coming and his friend A-May decided to give him an integer array as a present. A-Ming has two favorite numbers a and b, and he thinks an array is beautiful if its mean is exactly a and its median is exactly b. Please help A-May find a beautiful array so her gift can impress A-Ming.\nThe mean of an array is its sum divided by its length. For example, the mean of array [3,\u22121,5,5] is 12\u00f74=3.\nThe median of an array is its middle element after sorting if its length is odd, or the mean of two middle elements after sorting if its length is even. For example, the median of [1,1,2,4,8] is 2 and the median of [3,\u22121,5,5] is (3+5)\u00f72=4.\nNote that the mean and median are not rounded to an integer. For example, the mean of array [1,2] is 1.5.\nThe only line contains two integers a and b.\nIn the first line, print the length of the array.\nIn the second line, print the elements of the array.\nIf there are multiple solutions, you can print any. It can be proved that, under the constraints of the problem, a solution always exists.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test1024 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2041B": {
        "title": "B. Bowling Frame",
        "description": "Bowling is a national sport in Taiwan; everyone in the country plays the sport on a daily basis since their youth. Naturally, there are a lot of bowling alleys all over the country, and the competition between them is as intense as you can imagine.\nMaw-Shang owns one such bowling alley. To stand out from other competitors in the industry and draw attention from customers, he decided to hold a special event every month that features various unorthodox bowling rules. For the event this month, he came up with a new version of the game called X-pin bowling. In the traditional 10-pin bowling game, a frame is built out of ten bowling pins forming a triangular shape of side length four. The pin closest to the player forms the first row, and the two pins behind it form the second row, and so on. Unlike the standard version, the game of X-pin bowling Maw-Shang designed allows a much larger number of pins that form a larger frame. The following figure shows a standard 10-pin frame on the left, and on the right it shows a 21-pin frame that forms a triangular shape of side length six which is allowed in the game of X-pin bowling.\nBeing the national sport, the government of Taiwan strictly regulates and standardizes the manufacturing of bowling pins. There are two types of bowling pins allowed, one in black and the other in white, and the bowling alley Maw-Shang owns has w white pins and b black pins. To make this new game exciting for the customers, Maw-Shang wants to build the largest possible frame from these w+b pins. However, even though he is okay with using both colors in building the frame, for aesthetic reasons, Maw-Shang still wants the colors of the pins on the same row to be identical. For example, the following figure shows two possible frames of side length six, but only the left one is acceptable to Maw-Shang since the other one has white and black pins mixed in the third row.\nThe monthly special event is happening in just a few hours. Please help Maw-Shang calculate the side length of the largest frame that he can build from his w+b pins!\nThe first line of the input contains a single integer t, the number of test cases. Each of the following t lines contains two integers w and b, the number of white and black pins, respectively.\nFor each test case, output in a single line the side length k of the largest pin satisfying Maw-Shang's requirement you can build with the given pins.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test1024 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "math",
            "*1200"
        ],
        "solution": null
    },
    "2040B": {
        "title": "B. Paint a Strip",
        "description": "You have an array of zeros a1,a2,\u2026,an of length n.\nYou can perform two types of operations on it: \nWhat is the minimum number of operations of the first type needed to make all elements of the array equal to one?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe only line of each test case contains one integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the array.\nNote that there is no limit on the sum of n over all test cases.\nFor each test case, print one integer\u00a0\u2014 the minimum number of needed operations of first type.\nIn the first test case, you can perform an operation of the 1st type with i=1.\nIn the second test case, you can perform the following sequence of operations:\nIn the third test case, you can perform the following sequence of operations:",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "2039C1": {
        "title": "C1. Shohag Loves XOR (Easy Version)",
        "description": "This is the easy version of the problem. The differences between the two versions are highlighted in bold. You can only make hacks if both versions of the problem are solved.\nShohag has two integers x and m. Help him count the number of integers 1\u2264y\u2264m such that x\u2260y and x\u2295y is a divisor\u2217 of either x, y, or both. Here \u2295 is the bitwise XOR operator.\n\u2217The number b is a divisor of the number a if there exists an integer c such that a=b\u22c5c.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains two space-separated integers x and m (1\u2264x\u2264106, 1\u2264m\u22641018).\nIt is guaranteed that the sum of x over all test cases does not exceed 107.\nFor each test case, print a single integer\u00a0\u2014 the number of suitable y.\nIn the first test case, for x=6, there are 3 valid values for y among the integers from 1 to m=9, and they are 4, 5, and 7.\nIn the second test case, for x=5, there are 2 valid values for y among the integers from 1 to m=7, and they are 4 and 6.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "math",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2039B": {
        "title": "B. Shohag Loves Strings",
        "description": "For a string p, let f(p) be the number of distinct non-empty substrings\u2217 of p.\nShohag has a string s. Help him find a non-empty string p such that p is a substring of s and f(p) is even or state that no such string exists.\n\u2217A string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains a string s (1\u2264|s|\u2264105) consisting of lowercase English letters.\nIt is guaranteed that the sum of the length of s over all test cases doesn't exceed 3\u22c5105.\nFor each test case, print a non-empty string that satisfies the conditions mentioned in the statement, or \u22121 if no such string exists. If there are multiple solutions, output any.\nIn the first test case, we can set p= abaa because it is a substring of s and the distinct non-empty substrings of p are a, b, aa, ab, ba, aba, baa and abaa, so it has a total of 8 distinct substrings which is even.\nIn the second test case, we can only set p= a but it has one distinct non-empty substring but this number is odd, so not valid.\nIn the third test case, the whole string contains 52 distinct non-empty substrings, so the string itself is a valid solution.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "strings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "2037C": {
        "title": "C. Superultra's Favorite Permutation",
        "description": "Superultra, a little red panda, desperately wants primogems. In his dreams, a voice tells him that he must solve the following task to obtain a lifetime supply of primogems. Help Superultra!\nConstruct a permutation\u2217 p of length n such that pi+pi+1 is composite\u2020 over all 1\u2264i\u2264n\u22121. If it's not possible, output \u22121.\n\u2217A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\n\u2020An integer x is composite if it has at least one other divisor besides 1 and x. For example, 4 is composite because 2 is a divisor.\nThe first line contains t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case contains an integer n (2\u2264n\u22642\u22c5105) \u2014 the length of the permutation.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, if it's not possible to construct p, output \u22121 on a new line. Otherwise, output n integers p1,p2,\u2026,pn on a new line.\nIn the first example, it can be shown that all permutation of size 3 contain two adjacent elements whose sum is prime. For example, in the permutation [2,3,1] the sum 2+3=5 is prime.\nIn the second example, we can verify that the sample output is correct because 1+8, 8+7, 7+3, 3+6, 6+2, 2+4, and 4+5 are all composite. There may be other constructions that are correct.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "2036C": {
        "title": "C. Anya and 1100",
        "description": "While rummaging through things in a distant drawer, Anya found a beautiful string s consisting only of zeros and ones.\nNow she wants to make it even more beautiful by performing q operations on it.\nEach operation is described by two integers i (1\u2264i\u2264|s|) and v (v\u2208{0,1}) and means that the i-th character of the string is assigned the value v (that is, the assignment si=v is performed).\nBut Anya loves the number 1100, so after each query, she asks you to tell her whether the substring \"1100\" is present in her string (i.e. there exist such 1\u2264i\u2264|s|\u22123 that sisi+1si+2si+3=1100).\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of the test case contains the string s (1\u2264|s|\u22642\u22c5105), consisting only of the characters \"0\" and \"1\". Here |s| denotes the length of the string s.\nThe next line contains an integer q (1\u2264q\u22642\u22c5105) \u2014 the number of queries.\nThe following q lines contain two integers i (1\u2264i\u2264|s|) and v (v\u2208{0,1}), describing the query.\nIt is guaranteed that the sum of |s| across all test cases does not exceed 2\u22c5105. It is also guaranteed that the sum of q across all test cases does not exceed 2\u22c5105.\nFor each query, output \"YES\", if \"1100\" is present in Anya's string; otherwise, output \"NO\".\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2034B": {
        "title": "B. Rakhsh's Revival",
        "description": "Rostam's loyal horse, Rakhsh, has seen better days. Once powerful and fast, Rakhsh has grown weaker over time, struggling to even move. Rostam worries that if too many parts of Rakhsh's body lose strength at once, Rakhsh might stop entirely. To keep his companion going, Rostam decides to strengthen Rakhsh, bit by bit, so no part of his body is too frail for too long.\nImagine Rakhsh's body as a line of spots represented by a binary string ss of length n, where each 0 means a weak spot and each 1 means a strong one. Rostam's goal is to make sure that no interval of m consecutive spots is entirely weak (all 0s).\nLuckily, Rostam has a special ability called Timar, inherited from his mother Rudabeh at birth. With Timar, he can select any segment of length k and instantly strengthen all of it (changing every character in that segment to 1). The challenge is to figure out the minimum number of times Rostam needs to use Timar to keep Rakhsh moving, ensuring there are no consecutive entirely weak spots of length m.\nThe first line contains an integer t (1\u2264t\u2264104), the number of test cases. \nThe first line of each test case contains three numbers n, m, k (1\u2264m,k\u2264n\u22642\u22c5105). The second line of each test case contains a binary string s of n characters s1s2\u2026sn. (si\u2208{0,1} for 1\u2264i\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105. \nFor each test case, output the minimum number of times Rostam needs to use Timar to keep Rakhsh moving, ensuring there are no consecutive entirely weak spots of length m.\nIn the first test case, we should apply an operation on each 0.\nIn the second test case, s is already ok. \nIn the third test case, we can perform an operation on interval [3,4] to get 001100.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "2032B": {
        "title": "B. Medians",
        "description": "You are given an array a=[1,2,\u2026,n], where n is odd, and an integer k.\nYour task is to choose an odd positive integer m and to split a into m subarrays\u2020 b1,b2,\u2026,bm such that:\n\u2020A subarray of the array a of length n is the array [al,al+1,\u2026,ar] for some integers 1\u2264l\u2264r\u2264n.\n\u2021A median of the array of odd length is the middle element after the array is sorted in non-decreasing order. For example: median([1,2,5,4,3])=3, median([3,2,1])=2, median([2,1,2,1,2,2,2])=2.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22645000) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n<2\u22c5105, n is odd)\u00a0\u2014 the length of array a and the desired median of the array of medians of all subarrays.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case:\nIn detail, for a valid answer [p1,p2,\u2026,pm]:\nIf there are multiple solutions, you can output any of them.\nIn the first test case, the given partition has m=1 and b1=[1]. It is obvious that median([median([1])])=median([1])=1.\nIn the second test case, the given partition has m=3 and:\nTherefore, median([median([1]),median([2]),median([3])])=median([1,2,3])=2.\nIn the third test case, there is no valid partition for k=3.\nIn the fourth test case, the given partition has m=5 and:\nTherefore, median([median([1,2,3]),median([4,5,6]),median([7,8,9]),median([10,11,12]),median([13,14,15])])=median([2,5,8,11,14])=8.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2030C": {
        "title": "C. A TRUE Battle",
        "description": "Alice and Bob are playing a game. There is a list of n booleans, each of which is either true or false, given as a binary string \u2217 of length n (where 1 represents true, and 0 represents false). Initially, there are no operators between the booleans.\nAlice and Bob will take alternate turns placing and or or between the booleans, with Alice going first. Thus, the game will consist of n\u22121 turns since there are n booleans. Alice aims for the final statement to evaluate to true, while Bob aims for it to evaluate to false. Given the list of boolean values, determine whether Alice will win if both players play optimally.\nTo evaluate the final expression, repeatedly perform the following steps until the statement consists of a single true or false: \n\u2217A binary string is a string that only consists of characters 0 and 1\nThe first line contains t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the string.\nThe second line contains a binary string of length n, consisting of characters 0 and 1\u00a0\u2014 the list of boolean values.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each testcase, output \"YES\" (without quotes) if Alice wins, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\" and \"Yes\" will be recognized as a positive response).\nIn the first testcase, Alice can place and between the two booleans. The game ends as there are no other places to place operators, and Alice wins because true\u00a0and\u00a0true is true.\nIn the second testcase, Alice can place or between the middle true and the left false. Bob can place and between the middle true and the right false. The statement false\u00a0or\u00a0true\u00a0and\u00a0false is false.\nNote that these examples may not be the best strategies for either Alice or Bob.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "games",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2029B": {
        "title": "B. Replacement",
        "description": "You have a binary string\u2217 s of length n, and Iris gives you another binary string r of length n\u22121.\nIris is going to play a game with you. During the game, you will perform n\u22121 operations on s. In the i-th operation (1\u2264i\u2264n\u22121):\nIf all the n\u22121 operations are performed successfully, you win.\nDetermine whether it is possible for you to win this game.\n\u2217A binary string is a string where each character is either 0 or 1.\nEach test contains multiple test cases. The first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105)\u00a0\u2014 the length of s.\nThe second line contains the binary string s of length n (si=0 or 1).\nThe third line contains the binary string r of length n\u22121 (ri=0 or 1).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print \"YES\" (without quotes) if you can win the game, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn the first test case, you cannot perform the first operation. Thus, you lose the game.\nIn the second test case, you can choose k=1 in the only operation, and after that, s becomes equal to 1. Thus, you win the game.\nIn the third test case, you can perform the following operations: 110_1r1=0\u2192101_r2=0\u219210_r3=1\u21921.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2027B": {
        "title": "B. Stalin Sort",
        "description": "Stalin Sort is a humorous sorting algorithm designed to eliminate elements which are out of place instead of bothering to sort them properly, lending itself to an O(n) time complexity.\nIt goes as follows: starting from the second element in the array, if it is strictly smaller than the previous element (ignoring those which have already been deleted), then delete it. Continue iterating through the array until it is sorted in non-decreasing order. For example, the array [1,4,2,3,6,5,5,7,7] becomes [1,4,6,7,7] after a Stalin Sort.\nWe define an array as vulnerable if you can sort it in non-increasing order by repeatedly applying a Stalin Sort to any of its subarrays\u2217, as many times as is needed.\nGiven an array a of n integers, determine the minimum number of integers which must be removed from the array to make it vulnerable.\n\u2217An array a is a subarray of an array b if a can be obtained from b by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end. \nEach test consists of several test cases. The first line contains a single integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases. This is followed by descriptions of the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642000)\u00a0\u2014 the size of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2000.\nFor each test case, output a single integer\u00a0\u2014 the minimum number of integers which must be removed from the array to make it vulnerable.\nIn the first test case, the optimal answer is to remove the numbers 3 and 9. Then we are left with a=[6,4,2,5,2]. To show this array is vulnerable, we can first apply a Stalin Sort on the subarray [4,2,5] to get a=[6,4,5,2] and then apply a Stalin Sort on the subarray [6,4,5] to get a=[6,2], which is non-increasing.\nIn the second test case, the array is already non-increasing, so we don't have to remove any integers.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2025B": {
        "title": "B. Binomial Coefficients, Kind Of",
        "description": "Recently, akshiM met a task that needed binomial coefficients to solve. He wrote a code he usually does that looked like this:\nUnfortunately, he made an error, since the right formula is the following:\nBut his team member keblidA is interested in values that were produced using the wrong formula. Please help him to calculate these coefficients for t various pairs (ni,ki). Note that they should be calculated according to the first (wrong) formula.\nSince values C[ni][ki] may be too large, print them modulo 109+7.\nThe first line contains a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of pairs. Next, t pairs are written in two lines.\nThe second line contains t integers n1,n2,\u2026,nt (2\u2264ni\u2264105).\nThe third line contains t integers k1,k2,\u2026,kt (1\u2264ki<ni).\nPrint t integers C[ni][ki] modulo 109+7.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "combinatorics",
            "dp",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2024B": {
        "title": "B. Buying Lemonade",
        "description": "There is a vending machine that sells lemonade. The machine has a total of n slots. You know that initially, the i-th slot contains ai cans of lemonade. There are also n buttons on the machine, each button corresponds to a slot, with exactly one button corresponding to each slot. Unfortunately, the labels on the buttons have worn off, so you do not know which button corresponds to which slot.\nWhen you press the button corresponding to the i-th slot, one of two events occurs:\nAfter pressing, the can drops out so quickly that it is impossible to track from which slot it fell. The contents of the slots are hidden from your view, so you cannot see how many cans are left in each slot. The only thing you know is the initial number of cans in the slots: a1,a2,\u2026,an.\nDetermine the minimum number of button presses needed to guarantee that you receive at least k cans of lemonade.\nNote that you can adapt your strategy during the button presses based on whether you received a can or not. It is guaranteed that there are at least k cans of lemonade in total in the machine. In other words, k\u2264a1+a2+\u2026+an.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264n\u22642\u22c5105, 1\u2264k\u2264109)\u00a0\u2014 the number of slots in the machine and the required number of cans of lemonade.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the number of cans in the slots.\nIt is guaranteed that k\u2264a1+a2+\u2026+an, meaning there are at least k cans of lemonade in the machine.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u2014 the minimum number of button presses needed to guarantee that you receive at least k cans of lemonade.\nIn the first test case, we can simply press the first button and receive one can of lemonade.\nIn the second test case, we can press each button once and guarantee that we receive 2 cans of lemonade. Note that if we simply press one button twice, we might not be lucky, and that button could correspond to the first slot, in which case we would only receive 1 can of lemonade for two presses.\nIn the third test case, one of the optimal strategies is as follows:\nPress the first button twice. After the first press, a can of lemonade will definitely drop out. Then there are two options:\nIt can be shown that it is impossible to guarantee receiving 4 cans of lemonade with only 4 presses, so the answer is 5.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "constructive algorithms",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2021B": {
        "title": "B. Maximize Mex",
        "description": "You are given an array a of n positive integers and an integer x. You can do the following two-step operation any (possibly zero) number of times: \nFind the maximum value of the MEX of a if you perform the operations optimally.\nThe MEX (minimum excluded value) of an array is the smallest non-negative integer that is not in the array. For example: \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22645000). The description of the test cases follows.\nThe first line of each test case contains two integers n and x (1\u2264n\u22642\u22c5105; 1\u2264x\u2264109)\u00a0\u2014 the length of the array and the integer to be used in the operation.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109)\u00a0\u2014 the given array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer: the maximum MEX of a if you perform the operations optimally.\nIn the first test case, the MEX of a is 4 without performing any operations, which is the maximum.\nIn the second test case, the MEX of a is 5 without performing any operations. If we perform two operations both with i=1, we will have the array a=[5,3,4,1,0,2]. Then, the MEX of a will become 6, which is the maximum.\nIn the third test case, the MEX of a is 0 without performing any operations, which is the maximum.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2020B": {
        "title": "B. Brightness Begins",
        "description": "Imagine you have n light bulbs numbered 1,2,\u2026,n. Initially, all bulbs are on. To flip the state of a bulb means to turn it off if it used to be on, and to turn it on otherwise.\nNext, you do the following:\nAfter performing all operations, there will be several bulbs that are still on. Your goal is to make this number exactly k.\nFind the smallest suitable n such that after performing the operations there will be exactly k bulbs on. We can show that an answer always exists.\n\u2020 An integer x is divisible by y if there exists an integer z such that x=y\u22c5z.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe only line of each test case contains a single integer k (1\u2264k\u22641018).\nFor each test case, output n\u00a0\u2014 the minimum number of bulbs.\nIn the first test case, the minimum number of bulbs is 2. Let's denote the state of all bulbs with an array, where 1 corresponds to a turned on bulb, and 0 corresponds to a turned off bulb. Initially, the array is [1,1].\nIn the end, there are k=1 bulbs on. We can also show that the answer cannot be less than 2.\nIn the second test case, the minimum number of bulbs is 5. Initially, the array is [1,1,1,1,1]. \nIn the end, there are k=3 bulbs on. We can also show that the answer cannot be smaller than 5.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2019B": {
        "title": "B. All Pairs Segments",
        "description": "You are given n points on the x axis, at increasing positive integer coordinates x1<x2<\u2026<xn.\nFor each pair (i,j) with 1\u2264i<j\u2264n, you draw the segment [xi,xj]. The segments are closed, i.e., a segment [a,b] contains the points a,a+1,\u2026,b.\nYou are given q queries. In the i-th query, you are given a positive integer ki, and you have to determine how many points with integer coordinates are contained in exactly ki segments.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains two integers n, q (2\u2264n\u2264105, 1\u2264q\u2264105)\u00a0\u2014 the number of points and the number of queries.\nThe second line of each test case contains n integers x1,x2,\u2026,xn (1\u2264x1<x2<\u2026<xn\u2264109)\u00a0\u2014 the coordinates of the n points.\nThe third line of each test case contains q integers k1,k2,\u2026,kq (1\u2264ki\u22641018)\u00a0\u2014 the parameters of the q queries.\nIt is guaranteed that the sum of n over all test cases does not exceed 105, and the sum of q over all test cases does not exceed 105.\nFor each test case, output a single line with q integers: the i-th integer is the answer to the i-th query.\nIn the first example, you only draw the segment [101,200]. No point is contained in exactly 2 segments, and the 100 points 101,102,\u2026,200 are contained in exactly 1 segment.\nIn the second example, you draw 15 segments: [1,2],[1,3],[1,5],[1,6],[1,7],[2,3],[2,5],[2,6],[2,7],[3,5],[3,6],[3,7],[5,6],[5,7],[6,7]. Points 1,7 are contained in exactly 5 segments; points 2,4,6 are contained in exactly 9 segments; points 3,5 are contained in exactly 11 segments.",
        "time_limit": "time limit per test1.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2014C": {
        "title": "C. Robin Hood in Town",
        "description": "Look around, the rich are getting richer, and the poor are getting poorer. We need to take from the rich and give to the poor. We need Robin Hood!\nThere are n people living in the town. Just now, the wealth of the i-th person was ai gold. But guess what? The richest person has found an extra pot of gold! \nMore formally, find an aj=max(a1,a2,\u2026,an), change aj to aj+x, where x is a non-negative integer number of gold found in the pot. If there are multiple maxima, it can be any one of them.\nA person is unhappy if their wealth is strictly less than half of the average wealth\u2217. \nIf strictly more than half of the total population n are unhappy, Robin Hood will appear by popular demand.\nDetermine the minimum value of x for Robin Hood to appear, or output \u22121 if it is impossible.\n\u2217The average wealth is defined as the total wealth divided by the total population n, that is, \u2211ain, the result is a real number.\nThe first line of input contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the total population.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106)\u00a0\u2014 the wealth of each person.\nIt is guaranteed that the sum of n across all test cases does not exceed 2\u22c5105.\nFor each test case, output one integer\u00a0\u2014 the minimum number of gold that the richest person must find for Robin Hood to appear. If it is impossible, output \u22121 instead.\nIn the first test case, it is impossible for a single person to be unhappy.\nIn the second test case, there is always 1 happy person (the richest).\nIn the third test case, no additional gold are required, so the answer is 0.\nIn the fourth test case, after adding 15 gold, the average wealth becomes 254, and half of this average is 258, resulting in 3 people being unhappy.\nIn the fifth test case, after adding 16 gold, the average wealth becomes 315, resulting in 3 people being unhappy.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2009C": {
        "title": "C. The Legend of Freya the Frog",
        "description": "Freya the Frog is traveling on the 2D coordinate plane. She is currently at point (0,0) and wants to go to point (x,y). In one move, she chooses an integer d such that 0\u2264d\u2264k and jumps d spots forward in the direction she is facing. \nInitially, she is facing the positive x direction. After every move, she will alternate between facing the positive x direction and the positive y direction (i.e., she will face the positive y direction on her second move, the positive x direction on her third move, and so on). \nWhat is the minimum amount of moves she must perform to land on point (x,y)?\nThe first line contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case contains three integers x, y, and k (0\u2264x,y\u2264109,1\u2264k\u2264109).\nFor each test case, output the number of jumps Freya needs to make on a new line.\nIn the first sample, one optimal set of moves is if Freya jumps in the following way: (0,0) \u2192 (2,0) \u2192 (2,2) \u2192 (3,2) \u2192 (3,5) \u2192 (6,5) \u2192 (6,8) \u2192 (9,8) \u2192 (9,11). This takes 8 jumps.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2008D": {
        "title": "D. Sakurako's Hobby",
        "description": "For a certain permutation p\u2217 Sakurako calls an integer j reachable from an integer i if it is possible to make i equal to j by assigning i=pi a certain number of times.\nIf p=[3,5,6,1,2,4], then, for example, 4 is reachable from 1, because: i=1 \u2192 i=p1=3 \u2192 i=p3=6 \u2192 i=p6=4. Now i=4, so 4 is reachable from 1.\nEach number in the permutation is colored either black or white.\nSakurako defines the function F(i) as the number of black integers that are reachable from i.\nSakurako is interested in F(i) for each 1\u2264i\u2264n, but calculating all values becomes very difficult, so she asks you, as her good friend, to compute this.\n\u2217A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (the number 2 appears twice in the array), and [1,3,4] is also not a permutation (n=3, but the array contains 4).\nThe first line contains a single integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u00a0\u2014 the number of elements in the array.\nThe second line of each test case contains n integers p1,p2,\u2026,pn (1\u2264pi\u2264n) \u00a0\u2014 the elements of the permutation.\nThe third line of each test case contains a string s of length n, consisting of '0' and '1'. If si=0, then the number pi is colored black; if si=1, then the number pi is colored white.\nIt is guaranteed that the sum of n across all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers F(1),F(2),\u2026,F(n).",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "dsu",
            "graphs",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2005B2": {
        "title": "B2. The Strict Teacher (Hard Version)",
        "description": "This is the hard version of the problem. The only differences between the two versions are the constraints on m and q. In this version, m,q\u2264105. You can make hacks only if both versions of the problem are solved.\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now m teachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\nThe classroom can be represented as a one-dimensional line with cells from 1 to n, inclusive.\nAt the start, all m teachers and David are in distinct cells. Then they make moves. During each move \nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\nAlso, as Narek and Tsovak think this task is easy, they decided to give you q queries on David's position.\nIn the first line of the input, you are given a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases. The description of each test case follows.\nIn the first line of each test case, you are given three integers n, m, and q (3\u2264n\u2264109, 1\u2264m,q\u2264105)\u00a0\u2014 the number of cells on the line, the number of teachers, and the number of queries.\nIn the second line of each test case, you are given m distinct integers b1,b2,\u2026,bm (1\u2264bi\u2264n)\u00a0\u2014 the cell numbers of the teachers.\nIn the third line of each test case, you are given q integers a1,a2,\u2026,aq (1\u2264ai\u2264n)\u00a0\u2014 David's cell number for every query.\nIt is guaranteed that for any i, j such that 1\u2264i\u2264m and 1\u2264j\u2264q, bi\u2260aj.\nIt is guaranteed that the sum of values of m over all test cases does not exceed 2\u22c5105.\nIt is guaranteed that the sum of values of q over all test cases does not exceed 2\u22c5105.\nFor each test case, output q lines, the i-th of them containing the answer of the i-th query.\nIn the only query of the first example, the student can run to cell 1. It will take the teacher five moves to reach from cell 6 to cell 1, so the answer is 5.\nIn the second query of the second example, the student can just stay at cell 3. The teacher, initially located in cell 4, can reach cell 3 in one move. Therefore, the answer is 1.",
        "time_limit": "time limit per test1.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2005B1": {
        "title": "B1. The Strict Teacher (Easy Version)",
        "description": "This is the easy version of the problem. The only differences between the two versions are the constraints on m and q. In this version, m=2 and q=1. You can make hacks only if both versions of the problem are solved.\nNarek and Tsovak were busy preparing this round, so they have not managed to do their homework and decided to steal David's homework. Their strict teacher noticed that David has no homework and now wants to punish him. She hires other teachers to help her catch David. And now m teachers together are chasing him. Luckily, the classroom is big, so David has many places to hide.\nThe classroom can be represented as a one-dimensional line with cells from 1 to n, inclusive.\nAt the start, all m teachers and David are in distinct cells. Then they make moves. During each move \nThis continues until David is caught. David is caught if any of the teachers (possibly more than one) is located in the same cell as David. Everyone sees others' moves, so they all act optimally.\nYour task is to find how many moves it will take for the teachers to catch David if they all act optimally.\nActing optimally means the student makes his moves in a way that maximizes the number of moves the teachers need to catch him; and the teachers coordinate with each other to make their moves in a way that minimizes the number of moves they need to catch the student.\nAlso, as Narek and Tsovak think this task is easy, they decided to give you q queries on David's position. Note: this is the easy version, and you are given only one query.\nIn the first line of the input, you are given a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases. The description of each test case follows.\nIn the first line of each test case, you are given three integers n, m, and q (3\u2264n\u2264109, m=2, q=1)\u00a0\u2014 the number of cells on the line, the number of teachers, and the number of queries.\nIn the second line of each test case, you are given m distinct integers b1,b2,\u2026,bm (1\u2264bi\u2264n)\u00a0\u2014 the cell numbers of the teachers.\nIn the third line of each test case, you are given q integers a1,a2,\u2026,aq (1\u2264ai\u2264n)\u00a0\u2014 David's cell number for every query.\nIt is guaranteed that for any i, j such that 1\u2264i\u2264m and 1\u2264j\u2264q, bi\u2260aj.\nFor each test case, output q lines, the i-th of them containing the answer of the i-th query.\nIn the first example, the student can just stay at cell 2. The teacher, initially located in cell 1, can reach cell 2 in one move. Therefore, the answer is 1.\nIn the second example, the student should just stay at cell 1. The teacher, initially located in cell 3, can reach cell 1 in two moves. Therefore, the answer is 2.",
        "time_limit": "time limit per test1.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "2004C": {
        "title": "C. Splitting Items",
        "description": "Alice and Bob have n items they'd like to split between them, so they decided to play a game. All items have a cost, and the i-th item costs ai. Players move in turns starting from Alice.\nIn each turn, the player chooses one of the remaining items and takes it. The game goes on until no items are left.\nLet's say that A is the total cost of items taken by Alice and B is the total cost of Bob's items. The resulting score of the game then will be equal to A\u2212B.\nAlice wants to maximize the score, while Bob wants to minimize it. Both Alice and Bob will play optimally.\nBut the game will take place tomorrow, so today Bob can modify the costs a little. He can increase the costs ai of several (possibly none or all) items by an integer value (possibly, by the same value or by different values for each item). However, the total increase must be less than or equal to k. Otherwise, Alice may suspect something. Note that Bob can't decrease costs, only increase.\nWhat is the minimum possible score Bob can achieve?\nThe first line contains a single integer t (1\u2264t\u22645000)\u00a0\u2014 the number of test cases. Then t cases follow.\nThe first line of each test case contains two integers n and k (2\u2264n\u22642\u22c5105; 0\u2264k\u2264109)\u00a0\u2014 the number of items and the maximum total increase Bob can make.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the initial costs of the items.\nIt's guaranteed that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the minimum possible score A\u2212B after Bob increases the costs of several (possibly none or all) items.\nIn the first test case, Bob can increase a1 by 5, making costs equal to [6,10]. Tomorrow, Alice will take 10 and Bob will take 6. The total score will be equal to 10\u22126=4, and it's the minimum possible.\nIn the second test case, Bob can't change costs. So the score will be equal to (15+10)\u221212=13, since Alice will take 15, Bob will take 12, and Alice\u00a0\u2014 10.\nIn the third test case, Bob, for example, can increase a1 by 1, a2 by 3, and a3 by 2. The total change is equal to 1+3+2\u22646 and costs will be equal to [4,4,4,4]. Obviously, the score will be equal to (4+4)\u2212(4+4)=0.\nIn the fourth test case, Bob can increase a1 by 3, making costs equal to [9,9]. The score will be equal to 9\u22129=0.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "2004B": {
        "title": "B. Game with Doors",
        "description": "There are 100 rooms arranged in a row and 99 doors between them; the i-th door connects rooms i and i+1. Each door can be either locked or unlocked. Initially, all doors are unlocked.\nWe say that room x is reachable from room y if all doors between them are unlocked.\nYou know that: \nHowever, you don't know the exact rooms they are in.\nYou don't want Alice and Bob to be able to reach each other, so you are going to lock some doors to prevent that. What's the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers l and r (1\u2264l<r\u2264100)\u00a0\u2014 the bounds of the segment of rooms where Alice is located.\nThe second line of each test case contains two integers L and R (1\u2264L<R\u2264100) \u2014 the bounds of the segment of rooms where Bob is located.\nFor each test case, print a single integer\u00a0\u2014 the smallest number of doors you have to lock so that Alice and Bob cannot meet, regardless of their starting positions inside the given segments.\nIn the first test case, it is sufficient to lock the door between rooms 2 and 3.\nIn the second test case, the following doors have to be locked: (2,3), (3,4), (4,5).\nIn the third test case, the following doors have to be locked: (5,6) and (6,7).",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "2003C": {
        "title": "C. Turtle and Good Pairs",
        "description": "Turtle gives you a string s, consisting of lowercase Latin letters.\nTurtle considers a pair of integers (i,j) (1\u2264i<j\u2264n) to be a pleasant pair if and only if there exists an integer k such that i\u2264k<j and both of the following two conditions hold:\nBesides, Turtle considers a pair of integers (i,j) (1\u2264i<j\u2264n) to be a good pair if and only if si=sj or (i,j) is a pleasant pair.\nTurtle wants to reorder the string s so that the number of good pairs is maximized. Please help him!\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u22642\u22c5105) \u2014 the length of the string.\nThe second line of each test case contains a string s of length n, consisting of lowercase Latin letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the string s after reordering so that the number of good pairs is maximized. If there are multiple answers, print any of them.\nIn the first test case, (1,3) is a good pair in the reordered string. It can be seen that we can't reorder the string so that the number of good pairs is greater than 1. bac and cab can also be the answer.\nIn the second test case, (1,2), (1,4), (1,5), (2,4), (2,5), (3,5) are good pairs in the reordered string. efddd can also be the answer.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2002C": {
        "title": "C. Black Circles",
        "description": "There are n circles on a two-dimensional plane. The i-th circle is centered at (xi,yi). Initially, all circles have a radius of 0.\nThe circles' radii increase at a rate of 1 unit per second.\nYou are currently at (xs,ys); your goal is to reach (xt,yt) without touching the circumference of any circle (including the moment you reach (xt,yt)). You can move in any direction you want. However, your speed is limited to 1 unit per second.\nPlease determine whether this is possible.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of circles.\nThe next n lines each contain two integers xi, yi (1\u2264xi,yi\u2264109)\u00a0\u2014 the center of each circle.\nThe final line contains four integers xs, ys, xt, yt (1\u2264xs,ys,xt,yt\u2264109)\u00a0\u2014 the coordinates of the starting point and the goal, respectively.\nIt is guaranteed that these n+2 points are distinct.\nIt is guaranteed that the sum of n over all testcases does not exceed 105.\nFor each test case, output YES if it is possible to reach the goal without touching the circle boundaries, and output NO otherwise.\nYou can output Yes and No in any case (for example, strings yEs, yes, Yes, and YES will be recognized as a positive response).\nIn the first test case, a feasible way of movement is as follows. ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "geometry",
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2002B": {
        "title": "B. Removals Game",
        "description": "Alice got a permutation a1,a2,\u2026,ana1,a2,\u2026,an of [1,2,\u2026,n], and Bob got another permutation b1,b2,\u2026,bn of [1,2,\u2026,n]. They are going to play a game with these arrays.\nIn each turn, the following events happen in order:\nThe game continues for n\u22121 turns, after which both arrays will have exactly one remaining element: x in the array a and y in the array b.\nIf x=y, Bob wins; otherwise, Alice wins. Find which player will win if both players play optimally.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows. \nThe first line of each test case contains a single integer n (1\u2264n\u22643\u22c5105).\nThe next line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n, all ai are distinct)\u00a0\u2014 the permutation of Alice.\nThe next line contains n integers b1,b2,\u2026,bn (1\u2264bi\u2264n, all bi are distinct)\u00a0\u2014 the permutation of Bob.\nIt is guaranteed that the sum of all n does not exceed 3\u22c5105.\nFor each test case, print a single line with the name of the winner, assuming both players play optimally. If Alice wins, print Alice; otherwise, print Bob.\nIn the first test case, Bob can win the game by deleting the same element as Alice did.\nIn the second test case, Alice can delete 3 in the first turn, and then in the second turn, delete the element that is different from the one Bob deleted in the first turn to win the game.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "2000D": {
        "title": "D. Right Left Wrong",
        "description": "Vlad found a strip of n cells, numbered from left to right from 1 to n. In the i-th cell, there is a positive integer ai and a letter si, where all si are either 'L' or 'R'.\nVlad invites you to try to score the maximum possible points by performing any (possibly zero) number of operations.\nIn one operation, you can choose two indices l and r (1\u2264l<r\u2264n) such that sl = 'L' and sr = 'R' and do the following:\nFor example, consider the following strip:\nYou can first choose l=1, r=2 and add 3+5=8 to your score.\nThen choose l=3, r=6 and add 1+4+3+2=10 to your score.\nAs a result, it is impossible to perform another operation, and the final score is 18.\nWhat is the maximum score that can be achieved?\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains one integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the strip.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264105)\u00a0\u2014 the numbers written on the strip.\nThe third line of each test case contains a string s of n characters 'L' and 'R'.\nIt is guaranteed that the sum of the values of n across all test cases does not exceed 2\u22c5105.\nFor each test case, output one integer\u00a0\u2014 the maximum possible number of points that can be scored.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "two pointers",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "2000C": {
        "title": "C. Numeric String Template",
        "description": "Kristina has an array a, called a template, consisting of n integers. She also has m strings, each consisting only of lowercase Latin letters. The strings are numbered from 1 to m. She wants to check which strings match the template.\nA string s is considered to match the template if all of the following conditions are simultaneously satisfied: \nFor example, if a = [3,5,2,1,3], then the string \"abfda\" matches the template, while the string \"afbfa\" does not, since the character \"f\" corresponds to both numbers 1 and 5.\nThe first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe following descriptions are for the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u2014 the number of elements in the array a.\nThe second line of each test case contains exactly n integers ai (\u2212109\u2264ai\u2264109) \u2014 the elements of the array a.\nThe third line of each test case contains a single integer m (1\u2264m\u22642\u22c5105) \u2014 the number of strings to check for template matching.\nFollowing are m strings, each containing a non-empty string sj (1\u2264|sj|\u22642\u22c5105), consisting of lowercase Latin letters.\nIt is guaranteed that the sum of n across all test cases does not exceed 2\u22c5105, and that the sum of the lengths of all strings does not exceed 2\u22c5105.\nFor each test case, output m lines. On the i-th line (1\u2264i\u2264m) output: \nYou may output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nThe first test case is explained in the problem statement.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "strings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1999D": {
        "title": "D. Slavic's Exam",
        "description": "Slavic has a very tough exam and needs your help in order to pass it. Here is the question he is struggling with:\nThere exists a string s, which consists of lowercase English letters and possibly zero or more \"?\". \nSlavic is asked to change each \"?\" to a lowercase English letter such that string t becomes a subsequence (not necessarily continuous) of the string s. \nOutput any such string, or say that it is impossible in case no string that respects the conditions exists.\nThe first line contains a single integer T (1\u2264T\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single string s (1\u2264|s|\u22642\u22c5105, and s consists only of lowercase English letters and \"?\"-s) \u00a0\u2013 the original string you have.\nThe second line of each test case contains a single string t (1\u2264|t|\u2264|s|, and t consists only of lowercase English letters) \u00a0\u2013 the string that should be a subsequence of string s.\nThe sum of |s| over all test cases doesn't exceed 2\u22c5105, where |x| denotes the length of the string x.\nFor each test case, if no such string exists as described in the statement, output \"NO\" (without quotes).\nOtherwise, output \"YES\" (without quotes). Then, output one line\u00a0\u2014 the string that respects all conditions.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\", and \"Yes\" will be recognized as a positive response).\nIf multiple answers are possible, you can output any of them.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1999B": {
        "title": "B. Card Game",
        "description": "Suneet and Slavic play a card game. The rules of the game are as follows:\nSince Suneet and Slavic aren't best friends, you need to calculate the number of ways the game could happen that Suneet would end up as the winner.\nFor a better understanding, please check the notes section.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains 4 integers a1, a2, b1, b2 (1\u2264a1,a2,b1,b2\u226410) where a1 and a2 represent the cards Suneet has, and b1 and b2 represent the cards Slavic has, respectively.\nFor each test case, output a single integer\u00a0\u2014 the number of games Suneet would win considering all possible games.\nConsider the first test case when Slavic starts with the cards that have the values 2 and 6, and Suneet starts with cards that have the values 3 and 8. The game could happen in 4 different ways:\n \n \n ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1998B": {
        "title": "B. Minimize Equal Sum Subarrays",
        "description": "You are given a permutation\u2217 p of length n.\nFind a permutation q of length n that minimizes the number of pairs (i,j) (1\u2264i\u2264j\u2264n) such that pi+pi+1+\u2026+pj=qi+qi+1+\u2026+qj.\n\u2217A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nThe first line contains t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains n (1\u2264n\u22642\u22c5105).\nThe following line contains n space-separated integers p1,p2,\u2026,pn (1\u2264pi\u2264n)\u00a0\u2014 denoting the permutation p of length n.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output one line containing any permutation of length n (the permutation q) such that q minimizes the number of pairs.\nFor the first test, there exists only one pair (i,j) (1\u2264i\u2264j\u2264n) such that pi+pi+1+\u2026+pj=qi+qi+1+\u2026+qj, which is (1,2). It can be proven that no such q exists for which there are no pairs.",
        "time_limit": "time limit per test1.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1997C": {
        "title": "C. Even Positions",
        "description": "Monocarp had a regular bracket sequence s of length n (n is even). He even came up with his own way to calculate its cost.\nHe knows that in a regular bracket sequence (RBS), each opening bracket is paired up with the corresponding closing bracket. So he decided to calculate the cost of RBS as the sum of distances between pairs of corresponding bracket pairs.\nFor example, let's look at RBS (())(). It has three pairs of brackets: \nUnfortunately, due to data corruption, Monocarp lost all characters on odd positions s1,s3,\u2026,sn\u22121. Only characters on even positions (s2,s4,\u2026,sn) remain. For example, (())() turned to _(_)_).\nMonocarp wants to restore his RBS by placing brackets on the odd positions. But since the restored RBS may not be unique, he wants to choose one with minimum cost. It's too hard to do for Monocarp alone, so can you help him?\nReminder: A regular bracket sequence is a string consisting of only brackets, such that this sequence, when inserted 1-s and +-s, gives a valid mathematical expression. For example, (), (()) or (()())() are RBS, while ), ()( or ())(() are not.\nThe first line contains a single integer t (1\u2264t\u22645000)\u00a0\u2014 the number of test cases. Next t cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u22642\u22c5105; n is even)\u00a0\u2014 the length of string s.\nThe second line of each test case contains a string s of length n, where all characters on the odd positions are '_' and all characters on the even positions are either '(' or ')'.\nAdditional constraints: \nFor each test case, print one integer\u00a0\u2014 the minimum cost of the regular bracket sequence that can be obtained from s by replacing '_'-s with brackets.\nIn the first test case, it's optimal to make s equal to (())(). The cost of s will be equal to 3+1+1=5.\nIn the second test case, the only option is to make s equal to () with cost 1.\nIn the third test case, the only possible RBS is ()()()() with cost 1+1+1+1=4.\nIn the fourth test case, it's optimal to make s equal to (())(()) with cost 3+1+3+1=8.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1997B": {
        "title": "B. Make Three Regions",
        "description": "There is a grid, consisting of 2 rows and n columns. Each cell of the grid is either free or blocked.\nA free cell y is reachable from a free cell x if at least one of these conditions holds: \nA connected region is a set of free cells of the grid such that all cells in it are reachable from one another, but adding any other free cell to the set violates this rule.\nFor example, consider the following layout, where white cells are free, and dark grey cells are blocked:\nThere are 3 regions in it, denoted with red, green and blue color respectively:\nThe given grid contains at most 1 connected region. Your task is to calculate the number of free cells meeting the following constraint:\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of columns.\nThe i-th of the next two lines contains a description of the i-th row of the grid\u00a0\u2014 the string si, consisting of n characters. Each character is either . (denoting a free cell) or x (denoting a blocked cell). \nAdditional constraint on the input: \nFor each test case, print a single integer\u00a0\u2014 the number of cells such that the number of connected regions becomes 3 if this cell is blocked.\nIn the first test case, if the cell (1,3) is blocked, the number of connected regions becomes 3 (as shown in the picture from the statement).",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1996C": {
        "title": "C. Sort",
        "description": "You are given two strings a and b of length n. Then, you are (forced against your will) to answer q queries.\nFor each query, you are given a range bounded by l and r. In one operation, you can choose an integer i (l\u2264i\u2264r) and set ai=x where x is any character you desire. Output the minimum number of operations you must perform such that sorted(a[l..r])=sorted(b[l..r]). The operations you perform on one query does not affect other queries.\nFor an arbitrary string c, sorted(c[l..r]) denotes the substring consisting of characters cl,cl+1,...,cr sorted in lexicographical order.\nThe first line contains t (1\u2264t\u22641000) \u2013 the number of test cases.\nThe first line of each test case contains two integers n and q (1\u2264n,q\u22642\u22c5105) \u2013 the length of both strings and the number of queries.\nThe following line contains a of length n. It is guaranteed a only contains lowercase latin letters.\nThe following line contains b of length n. It is guaranteed b only contains lowercase latin letters.\nThe following q lines contain two integers l and r (1\u2264l\u2264r\u2264n) \u2013 the range of the query.\nIt is guaranteed the sum of n and q over all test cases does not exceed 2\u22c5105.\nFor each query, output an integer, the minimum number of operations you need to perform in a new line.\nFor the first query, sorted(a[1..5])= abcde and sorted(b[1..5])= abcde, so no operations are necessary.\nFor the second query, you need to set a1= e. Then, sorted(a[1..4])=sorted(b[1..4])= bcde.",
        "time_limit": "time limit per test5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "sortings",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1995B1": {
        "title": "B1. Bouquet (Easy Version)",
        "description": "This is the easy version of the problem. The only difference is that in this version, the flowers are specified by enumeration.\nA girl is preparing for her birthday and wants to buy the most beautiful bouquet. There are a total of nn flowers in the store, each of which is characterized by the number of petals, and a flower with k petals costs k coins. The girl has decided that the difference in the number of petals between any two flowers she will use in her bouquet should not exceed one. At the same time, the girl wants to assemble a bouquet with the maximum possible number of petals. Unfortunately, she only has m coins, and she cannot spend more. What is the maximum total number of petals she can assemble in the bouquet?\nEach test consists of several test cases. The first line contains a single integer t (1\u2264t\u226410000)\u00a0\u2014 the number of test cases. This is followed by descriptions of the test cases.\nThe first line of each test case contains two integers n, m (1\u2264n\u22642\u22c5105,1\u2264m\u22641018)\u00a0\u2014 the number of flowers in the store and the number of coins the girl possesses, respectively. The second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109), where ai is the number of petals of the i-th flower in the store.\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the maximum possible number of petals in the bouquet that the girl can assemble while meeting all the conditions listed above.\nIn the first test case, you can assemble a bouquet with (1,1,2,2),(2,2,3),(1,1),(2,2). The maximum over all valid bouquets not greater than 10 is 7 for (2,2,3). In the third test case, you can assemble a bouquet with only one flower of any type, so the answer is 610. In the fourth test case, you can assemble a bouquet with (4,4,5), which gives you 13 petals, and it is the maximum amount of petals that the girl can buy.",
        "time_limit": "time limit per test1.5 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1994B": {
        "title": "B. Fun Game",
        "description": "Vova really loves the XOR operation (denoted as \u2295). Recently, when he was going to sleep, he came up with a fun game.\nAt the beginning of the game, Vova chooses two binary sequences s and t of length n and gives them to Vanya. A binary sequence is a sequence consisting only of the numbers 0 and 1. Vanya can choose integers l,r such that 1\u2264l\u2264r\u2264n, and for all l\u2264i\u2264r simultaneously replace si with si\u2295si\u2212l+1, where si is the i-th element of the sequence s.\nIn order for the game to be interesting, there must be a possibility to win. Vanya wins if, with an unlimited number of actions, he can obtain the sequence t from the sequence s. Determine if the game will be interesting for the sequences s and t.\nEach test consists of multiple test cases. The first line contains an integer q (1\u2264q\u2264104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the sequences s and t.\nThe second line of each test case contains a binary sequence s of length n.\nThe third line of each test case contains a binary sequence t of length n.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"Yes\" if the game will be interesting, otherwise output \"No\".\nYou can output each letter in any case (for example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as a positive answer).\nIn the first test case, Vanya will not be able to change the sequence s with the only possible action of choosing l=r=1.\nIn the second test case, the sequences s and t are already equal.\nIn the third test case, Vanya can act as follows:",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1993B": {
        "title": "B. Parity and Sum",
        "description": "Given an array a of n positive integers.\nIn one operation, you can pick any pair of indexes (i,j) such that ai and aj have distinct parity, then replace the smaller one with the sum of them. More formally: \nFind the minimum number of operations needed to make all elements of the array have the same parity.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105).\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the minimum number of operations required.\nIn the first test case, all integers already have the same parity. Therefore, no operation is needed.\nIn the third test case, we can perform two operations (1,2) and (1,3). The array a transforms as follows: a=[2,3,4]\u27f6[5,3,4]\u27f6[5,3,9].\nIn the fourth test case, an example of an optimal sequence of operations is (1,2), (1,3), (1,4), and (1,4). The array a transforms as follows: a=[3,2,2,8]\u27f6[3,5,2,8]\u27f6[3,5,5,8]\u27f6[11,5,5,8]\u27f6[11,5,5,19].",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1992D": {
        "title": "D. Test of Love",
        "description": "ErnKor is ready to do anything for Julen, even to swim through crocodile-infested swamps. We decided to test this love. ErnKor will have to swim across a river with a width of 1 meter and a length of n meters.\nThe river is very cold. Therefore, in total (that is, throughout the entire swim from 0 to n+1) ErnKor can swim in the water for no more than k meters. For the sake of humanity, we have added not only crocodiles to the river, but also logs on which he can jump. Our test is as follows:\nInitially, ErnKor is on the left bank and needs to reach the right bank. They are located at the 0 and n+1 meters respectively. The river can be represented as n segments, each with a length of 1 meter. Each segment contains either a log 'L', a crocodile 'C', or just water 'W'. ErnKor can move as follows: \nDetermine if ErnKor can reach the right bank.\nThe first line contains a single integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases.\nThe first line of each test case contains three numbers n,m,k (0\u2264k\u22642\u22c5105, 1\u2264n\u22642\u22c5105, 1\u2264m\u226410)\u00a0\u2014 the length of the river, the distance ErnKor can jump, and the number of meters ErnKor can swim without freezing.\nThe second line of each test case contains a string a of length n. ai denotes the object located at the i-th meter. (ai\u2208{'W','C','L'})\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" if ErnKor can pass the test, and output \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nLet's consider examples: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1991B": {
        "title": "B. AND Reconstruction",
        "description": "You are given an array b of n\u22121 integers.\nAn array a of n integers is called good if bi=ai&ai+1 for 1\u2264i\u2264n\u22121, where & denotes the bitwise AND operator.\nConstruct a good array, or report that no good arrays exist.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n\u22121 integers b1,b2,\u2026,bn\u22121 (0\u2264bi<230)\u00a0\u2014 the elements of the array b.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer \u22121 if no good arrays exist. \nOtherwise, output n space-separated integers a1,a2,\u2026,an (0\u2264ai<230)\u00a0\u2014 the elements of a good array a.\nIf there are multiple solutions, you may output any of them.\nIn the first test case, b=[1]. A possible good array is a=[5,3], because a1&a2=5&3=1=b1.\nIn the second test case, b=[2,0]. A possible good array is a=[3,2,1], because a1&a2=3&2=2=b1 and a2&a3=2&1=0=b2.\nIn the third test case, b=[1,2,3]. It can be shown that no good arrays exist, so the output is \u22121.\nIn the fourth test case, b=[3,5,4,2]. A possible good array is a=[3,7,5,6,3].",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1990B": {
        "title": "B. Array Craft",
        "description": "For an array b of size m, we define:\nYou are given three integers n, x, and y (x>y). Construct an array a of size n satisfying:\nIf there are multiple arrays that meet the conditions, print any. It can be proven that such an array always exists under the given conditions.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nFor each test case: \nIt is guaranteed that the sum of n over all test cases will not exceed 105.\nFor each test case, output n space-separated integers a1,a2,\u2026,an in a new line.\nIn the second test case, \nThus, the array a=[1,\u22121,1,1] is considered correct.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1989B": {
        "title": "B. Substring and Subsequence",
        "description": "You are given two strings a and b, both consisting of lowercase Latin letters. \nA subsequence of a string is a string which can be obtained by removing several (possibly zero) characters from the original string. A substring of a string is a contiguous subsequence of that string.\nFor example, consider the string abac:\nYour task is to calculate the minimum possible length of the string that contains a as a substring and b as a subsequence.\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a string a (1\u2264|a|\u2264100), consisting of lowercase Latin letters.\nThe second line of each test case contains a string b (1\u2264|b|\u2264100), consisting of lowercase Latin letters.\nFor each test case, print a single integer\u00a0\u2014 the minimum possible length of the string that contains a as a substring and b as a subsequence.\nIn the examples below, the characters that correspond to the subsequence equal to b are bolded.\nIn the first example, one of the possible answers is caba.\nIn the second example, one of the possible answers is ercf.\nIn the third example, one of the possible answers is mmm.\nIn the fourth example, one of the possible answers is contest.\nIn the fifth example, one of the possible answers is abcdefg.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1987C": {
        "title": "C. Basil's Garden",
        "description": "There are n flowers in a row, the i-th of them initially has a positive height of hi meters.\nEvery second, the wind will blow from the left, causing the height of some flowers to decrease.\nSpecifically, every second, for each i from 1 to n, in this order, the following happens: \nHow many seconds will pass before hi=0 for all 1\u2264i\u2264n for the first time?\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of flowers.\nThe second line of each test case contains n integers h1,h2,\u2026,hn (1\u2264hi\u2264109)\u00a0\u2014 the heights of the flowers.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer\u00a0\u2014 the number of seconds that will pass before hi=0 for all 1\u2264i\u2264n. \nIn the first test case, the flower heights change as follows: [1,1,2]\u2192[1,1,1]\u2192[1,1,0]\u2192[1,0,0]\u2192[0,0,0].\nIn the second test case, the flower heights change as follows: [3,1]\u2192[2,0]\u2192[1,0]\u2192[0,0].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1987B": {
        "title": "B. K-Sort",
        "description": "You are given an array of integers a of length n. \nYou can apply the following operation any number of times (maybe, zero): \nFind the minimum number of coins needed to make a non-decreasing. That is, a1\u2264a2\u2264\u2026\u2264an.\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer\u00a0\u2014 the minimum number of coins needed to make a non-decreasing.\nIn the first test case, a is already sorted, so you don't have to spend any coins.\nIn the second test case, the optimal sequence of operations is: ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1986C": {
        "title": "C. Update Queries",
        "description": "Let's consider the following simple problem. You are given a string s of length n, consisting of lowercase Latin letters, as well as an array of indices ind of length m (1\u2264indi\u2264n) and a string c of length m, consisting of lowercase Latin letters. Then, in order, you perform the update operations, namely, during the i-th operation, you set sindi=ci. Note that you perform all m operations from the first to the last.\nOf course, if you change the order of indices in the array ind and/or the order of letters in the string c, you can get different results. Find the lexicographically smallest string s that can be obtained after m update operations, if you can rearrange the indices in the array ind and the letters in the string c as you like.\nA string a is lexicographically less than a string b if and only if one of the following conditions is met:\nEach test consists of several sets of input data. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of sets of input data. Then follows their description.\nThe first line of each set of input data contains two integers n and m (1\u2264n,m\u2264105)\u00a0\u2014 the length of the string s and the number of updates.\nThe second line of each set of input data contains a string s of length n, consisting of lowercase Latin letters.\nThe third line of each set of input data contains m integers ind1,ind2,\u2026,indm (1\u2264indi\u2264n)\u00a0\u2014 the array of indices ind.\nThe fourth line of each set of input data contains a string c of length m, consisting of lowercase Latin letters.\nIt is guaranteed that the sum of n over all sets of input data does not exceed 2\u22c5105. Similarly, the sum of m over all sets of input data does not exceed 2\u22c5105.\nFor each set of input data, output the lexicographically smallest string s that can be obtained by rearranging the indices in the array ind and the letters in the string c as you like.\nIn the first set of input data, you can leave the array ind and the string c unchanged and simply perform all operations in that order.\nIn the second set of input data, you can set the array ind=[1,1,4,2] and c= \"zczw\". Then the string s will change as follows: meow\u2192zeow\u2192ceow\u2192ceoz\u2192cwoz.\nIn the third set of input data, you can leave the array ind unchanged and set c= \"admn\". Then the string s will change as follows: abacaba\u2192abacaba\u2192abdcaba\u2192abdcmba\u2192abdcmbn.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1986B": {
        "title": "B. Matrix Stabilization",
        "description": "You are given a matrix of size n\u00d7m, where the rows are numbered from 1 to n from top to bottom, and the columns are numbered from 1 to m from left to right. The element at the intersection of the i-th row and the j-th column is denoted by aij.\nConsider the algorithm for stabilizing matrix a:\nIn this problem, cells (a,b) and (c,d) are considered neighbors if they share a common side, i.e., |a\u2212c|+|b\u2212d|=1.\nYour task is to output the matrix a after the stabilization algorithm has been executed. It can be shown that this algorithm cannot run for an infinite number of iterations.\nEach test consists of multiple sets of input data. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of sets of input data. This is followed by their description.\nThe first line of each set of input data contains two integers n and m (1\u2264n,m\u2264100,n\u22c5m>1)\u00a0\u2014 the number of rows and columns of matrix a. \nThe next n lines describe the corresponding rows of the matrix. The i-th line contains m integers ai1,ai2,\u2026,aim (1\u2264aij\u2264109).\nIt is guaranteed that the sum of n\u22c5m over all sets of input data does not exceed 2\u22c5105.\nFor each set of input data, output n lines with m numbers in each line\u00a0\u2014 the values of the cells of matrix a after the stabilization algorithm.\nIn the first set of input data, the algorithm will select the cell (1,1) twice in a row and then terminate. \nIn the second set of input data, there is no cell whose value is strictly greater than the values of all neighboring cells.\nIn the third set of input data, the algorithm will select the cell (2,2) and then terminate. \nIn the fourth set of input data, the algorithm will select the cell (1,1) three times and then the cell (2,3) twice.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1985E": {
        "title": "E. Secret Box",
        "description": "Ntarsis has a box B with side lengths x, y, and z. It lies in the 3D coordinate plane, extending from (0,0,0) to (x,y,z). \nNtarsis has a secret box S. He wants to choose its dimensions such that all side lengths are positive integers, and the volume of S is k. He can place S somewhere within B such that: \nS is magical, so when placed at an integer location inside B, it will not fall to the ground. \nAmong all possible ways to choose the dimensions of S, determine the maximum number of distinct locations he can choose to place his secret box S inside B. Ntarsis does not rotate S once its side lengths are selected.\nThe first line consists of an integer t, the number of test cases (1\u2264t\u22642000). The description of the test cases follows.\nThe first and only line of each test case contains four integers x,y,z and k (1\u2264x,y,z\u22642000, 1\u2264k\u2264x\u22c5y\u22c5z).\nIt is guaranteed the sum of all x, sum of all y, and sum of all z do not exceed 2000 over all test cases.\nNote that k may not fit in a standard 32-bit integer data type.\nFor each test case, output the answer as an integer on a new line. If there is no way to select the dimensions of S so it fits in B, output 0.\nFor the first test case, it is optimal to choose S with side lengths 2, 2, and 2, which has a volume of 2\u22c52\u22c52=8. It can be shown there are 8 ways to put S inside B.\nThe coordinate with the least x, y, and z values for each possible arrangement of S are: \nThe arrangement of S with a coordinate of (0,0,0) is depicted below:\nFor the second test case, S with side lengths 2, 3, and 3 are optimal.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1985C": {
        "title": "C. Good Prefixes",
        "description": "Alex thinks some array is good if there exists some element that can be represented as the sum of all other elements (the sum of all other elements is 0 if there are no other elements). For example, the array [1,6,3,2] is good since 1+3+2=6. Furthermore, the array [0] is also good. However, the arrays [1,2,3,4] and [1] are not good.\nAlex has an array a1,a2,\u2026,an. Help him count the number of good non-empty prefixes of the array a. In other words, count the number of integers i (1\u2264i\u2264n) such that the length i prefix (i.e. a1,a2,\u2026,ai) is good.\nThe first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u2014 the number of elements in the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109) \u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105. \nFor each test case, output a single integer \u2014 the number of good non-empty prefixes of the array a.\nIn the fourth test case, the array has five prefixes: \nAs you can see, three of them are good, so the answer is 3.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1984B": {
        "title": "B. Large Addition",
        "description": "A digit is large if it is between 55 and 9, inclusive. A positive integer is large if all of its digits are large.\nYou are given an integer x. Can it be the sum of two large positive integers with the same number of digits?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a single integer x (10\u2264x\u22641018).\nFor each test case, output YES if x satisfies the condition, and NO otherwise.\nYou can output YES and NO in any case (for example, strings yES, yes, and Yes will be recognized as a positive response).\nIn the first test case, we can have 658+679=1337.\nIn the second test case, it can be shown that no numbers of equal length and only consisting of large digits can add to 200.\nIn the third test case, we can have 696969+696969=1393938.\nIn the fourth test case, we can have 777+657=1434.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1983B": {
        "title": "B. Corner Twist",
        "description": "You are given two grids of numbers aa and b, with n rows and m columns. All the values in the grid are 0, 1 or 2.\nYou can perform the following operation on a any number of times: \nNote that the operation only changes the values of the corners of the picked subrectangle.\nIs it possible to convert the grid a into grid b by applying the above operation any number of times (possibly zero)?\nThe first line contains an integer t, the number of testcases (1\u2264t\u2264250).\nFor each testcase:\nThe first line contains two integers n and m, the number of rows and columns in the grid (2\u2264n,m\u2264500).\nEach of the next n lines contain m characters \u2014 the j-th character of the i-th line represents ai,j.\nEach of the next n lines contain m characters \u2014 the j-th character of the i-th line represents bi,j (0\u2264ai,j,bi,j\u22642).\nIt is guaranteed that the sum of n over all test cases and the sum of m over all test cases do not exceed 500.\nFor each test case print \"YES\" (without quotes) if it is possible to convert grid a into grid b and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn the first testcase, grid a can be converted into b in the following manner:\n000000000\u21d2102000201\u21d2102012222\u21d2102102102\u21d2111102120\u21d2111111111\nHere, in each operation, the top-right and bottom-left corners highlighted by a box are incremented by 2 modulo 3, while the top-left and bottom-right corners are incremented by 1 modulo 3.\nIn the fourth testcase, it can be proven that it is not possible to convert grid a into grid b using the above-mentioned operations any number of times.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1982C": {
        "title": "C. Boring Day",
        "description": "On another boring day, Egor got bored and decided to do something. But since he has no friends, he came up with a game to play.\nEgor has a deck of n cards, the i-th card from the top has a number ai written on it. Egor wants to play a certain number of rounds until the cards run out. In each round, he takes a non-zero number of cards from the top of the deck and finishes the round. If the sum of the numbers on the cards collected during the round is between l and r, inclusive, the round is won; otherwise, it is lost. \nEgor knows by heart the order of the cards. Help Egor determine the maximum number of rounds he can win in such a game. Note that Egor is not required to win rounds consecutively.\nEach test consists of several test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. This is followed by a description of the test cases.\nThe first line of each test case contains three integers n, l, and r (1\u2264n\u2264105, 1\u2264l\u2264r\u2264109).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the numbers on the cards from top to bottom.\nIt is guaranteed that the sum of n for all test cases does not exceed 2\u22c5105.\nFor each test case, output a single number\u00a0\u2014 the maximum number of rounds Egor can win.\nIn the first test case, Egor can win 3 rounds:\nIn the second test case, Egor cannot win any rounds, no matter how hard he tries.\nIn the third test case, you can take one card in each round, then the first and third rounds will be losing, and the second round will be winning.\nIn the fourth test case, you can take two cards in each round and always win.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "dp",
            "greedy",
            "two pointers",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1982B": {
        "title": "B. Collatz Conjecture",
        "description": "Recently, the first-year student Maxim learned about the Collatz conjecture, but he didn't pay much attention during the lecture, so he believes that the following process is mentioned in the conjecture:\nThere is a variable xx and a constant y. The following operation is performed k times: \nFor example, if the number x=16, y=3, and k=2, then after one operation x becomes 17, and after another operation x becomes 2, because after adding one, x=18 is divisible by 3 twice.\nGiven the initial values of x, y, and k, Maxim wants to know what is the final value of x.\nEach test consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe only line of each test case contains three integers x, y, and k (1\u2264x,k\u2264109, 2\u2264y\u2264109)\u00a0\u2014 the initial variable, constant and the number of operations.\nFor each test case, output a single integer\u00a0\u2014 the number obtained after applying k operations.\nIn the first test case, there is only one operation applied to x=1, resulting in x becoming 2.\nIn the second test case, for x=2, within one operation, one is added to x and it's divided by y=3, resulting in x becoming 1.\nIn the third test case, x changes as follows:",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1979C": {
        "title": "C. Earning on Bets",
        "description": "You have been offered to play a game. In this game, there are n possible outcomes, and for each of them, you must bet a certain integer amount of coins. In the event that the i-th outcome turns out to be winning, you will receive back the amount of coins equal to your bet on that outcome, multiplied by ki. Note that exactly one of the n outcomes will be winning.\nYour task is to determine how to distribute the coins in such a way that you will come out ahead in the event of any winning outcome. More formally, the total amount of coins you bet on all outcomes must be strictly less than the number of coins received back for each possible winning outcome.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u226450)\u00a0\u2014 the number of outcomes.\nThe second line of each test case contains n integers k1,k2,\u2026,kn (2\u2264ki\u226420)\u00a0\u2014 the multiplier for the amount of coins if the i-th outcome turns out to be winning.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \u22121 if there is no way to distribute the coins as required. Otherwise, output n integers x1,x2,\u2026,xn (1\u2264xi\u2264109)\u00a0\u2014 your bets on the outcomes.\nIt can be shown that if a solution exists, there is always a solution that satisfies these constraints.\nIf there are multiple suitable solutions, output any of them.\nIn the first test case, the coins can be distributed as follows: 27 coins on the first outcome, 41 coins on the second outcome, 12 coins on the third outcome. Then the total amount of coins bet on all outcomes is 27+41+12=80 coins. If the first outcome turns out to be winning, you will receive back 3\u22c527=81 coins, if the second outcome turns out to be winning, you will receive back 2\u22c541=82 coins, if the third outcome turns out to be winning, you will receive back 7\u22c512=84 coins. All these values are strictly greater than 80.\nIn the second test case, one way is to bet one coin on each of the outcomes.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "combinatorics",
            "constructive algorithms",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1979B": {
        "title": "B. XOR Sequences",
        "description": "You are given two distinct non-negative integers x and y. Consider two infinite sequences a1,a2,a3,\u2026 and b1,b2,b3,\u2026, where\nHere, x\u2295y denotes the bitwise XOR operation of integers x and y.\nFor example, with x=6, the first 8 elements of sequence a will look as follows: [7,4,5,2,3,0,1,14,\u2026]. Note that the indices of elements start with 1.\nYour task is to find the length of the longest common subsegment\u2020 of sequences a and b. In other words, find the maximum integer m such that ai=bj,ai+1=bj+1,\u2026,ai+m\u22121=bj+m\u22121 for some i,j\u22651.\n\u2020A subsegment of sequence p is a sequence pl,pl+1,\u2026,pr, where 1\u2264l\u2264r.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers x and y (0\u2264x,y\u2264109,x\u2260y)\u00a0\u2014 the parameters of the sequences.\nFor each test case, output a single integer\u00a0\u2014 the length of the longest common subsegment.\nIn the first test case, the first 7 elements of sequences a and b are as follows:\na=[1,2,3,4,5,6,7,\u2026]\nb=[0,3,2,5,4,7,6,\u2026]\nIt can be shown that there isn't a positive integer k such that the sequence [k,k+1] occurs in b as a subsegment. So the answer is 1.\nIn the third test case, the first 20 elements of sequences a and b are as follows:\na=[56,59,58,61,60,63,62,49,48,51,50,53,52,55,54,41, 40, 43, 42,45,\u2026]\nb=[36,39,38,33,32,35,34,45,44,47,46,41, 40, 43, 42,53,52,55,54,49,\u2026]\nIt can be shown that one of the longest common subsegments is the subsegment [41,40,43,42] with a length of 4.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1977B": {
        "title": "B. Binary Colouring",
        "description": "You are given a positive integer x. Find any array of integers a0,a1,\u2026,an\u22121 for which the following holds: \nIt can be proven that under the constraints of the problem, a valid array always exists.\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains a single positive integer x (1\u2264x<230).\nFor each test case, output two lines.\nOn the first line, output an integer n (1\u2264n\u226432)\u00a0\u2014 the length of the array a0,a1,\u2026,an\u22121.\nOn the second line, output the array a0,a1,\u2026,an\u22121.\nIf there are multiple valid arrays, you can output any of them.\nIn the first test case, one valid array is [1], since (1)\u22c520=1.\nIn the second test case, one possible valid array is [0,\u22121,0,0,1], since (0)\u22c520+(\u22121)\u22c521+(0)\u22c522+(0)\u22c523+(1)\u22c524=\u22122+16=14.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1976B": {
        "title": "B. Increase/Decrease/Copy",
        "description": "You are given two integer arrays: array aa of length n and array b of length n+1.\nYou can perform the following operations any number of times in any order: \nYour task is to calculate the minimum number of aforementioned operations (possibly zero) required to transform the array a into the array b. It can be shown that under the constraints of the problem, it is always possible.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nEach test case consists of three lines:\nAdditional constraint on the input: the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the minimum number of operations (possibly zero) required to transform the array a into the array b.\nIn the first example, you can transform a into b as follows: [2]\u2192[2,2]\u2192[1,2]\u2192[1,3].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1975C": {
        "title": "C. Chamo and Mocha's Array",
        "description": "Mocha likes arrays, so before her departure, Chamo gave her an array a consisting of n positive integers as a gift.\nMocha doesn't like arrays containing different numbers, so Mocha decides to use magic to change the array. Mocha can perform the following three-step operation some (possibly, zero) times: \nSuppose a=[1,2,3,4,5] initially: \nMocha will perform the operation until the array contains only the same number. Mocha wants to know what is the maximum possible value of this number.\n\u2020 The median in an array b of length m is an element that occupies position number \u230am+12\u230b after we sort the elements in non-decreasing order. For example, the median of [3,1,4,1,5] is 3 and the median of [5,25,20,24] is 20.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264500). The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output the maximum value of the number.\nIn the first test case, a=[1,2]. Mocha can only choose the interval (l,r)=(1,2). The array will be changed to a=[1,1]. Therefore, the answer is 1.\nIn the second test case, Mocha can perform the following operations:\nThe array contains only the same number, which is 4. It can be proven that the maximum value of the final number cannot be greater than 4.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1975B": {
        "title": "B. 378QAQ and Mocha's Array",
        "description": "Mocha likes arrays, so before her departure, 378QAQ gave her an array a consisting of n positive integers as a gift.\nMocha thinks that a is beautiful if there exist two numbers i and j (1\u2264i,j\u2264n, i\u2260j) such that for all k (1\u2264k\u2264n), ak is divisible\u2020 by either ai or aj.\nDetermine whether a is beautiful.\n\u2020 x is divisible by y if there exists an integer z such that x=y\u22c5z.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264500). The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u2264105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output \"Yes\" if array a is beautiful, and output \"No\" otherwise.\nYou can output \"Yes\" and \"No\" in any case (for example, strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive response).\nIn the first test case, any two numbers in the array are coprime, so the answer is \"No\".\nIn the second test case, we can pick i=2 and j=1. Since every number in the array is divisible by ai=1, the answer is \"Yes\".\nIn the third test case, we can pick i=3 and j=5. 2 and 4 is divisible by ai=2 while 3, 6 and 12 is divisible by aj=3, so the answer is \"Yes\".",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1971D": {
        "title": "D. Binary Cut",
        "description": "You are given a binary string\u2020. Please find the minimum number of pieces you need to cut it into, so that the resulting pieces can be rearranged into a sorted binary string.\nNote that: \n\u2020 A binary string is a string consisting of characters 0 and 1. A sorted binary string is a binary string such that all characters 0 come before all characters 1.\nThe first line contains a single integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a single string s (1\u2264|s|\u2264500) consisting of characters 0 and 1, where |s| denotes the length of the string s.\nFor each test case, output a single integer\u00a0\u2014 the minimum number of pieces needed to be able to rearrange the string into a sorted binary string.\nThe first test case is pictured in the statement. It can be proven that you can't use fewer than 3 pieces.\nIn the second and third test cases, the binary string is already sorted, so only 1 piece is needed.\nIn the fourth test case, you need to make a single cut between the two characters and rearrange them to make the string 01.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1970A1": {
        "title": "A1. Balanced Shuffle (Easy)",
        "description": "A parentheses sequence is a string consisting of characters \"(\" and \")\", for example \"(()((\".\nA balanced parentheses sequence is a parentheses sequence which can become a valid mathematical expression after inserting numbers and operations into it, for example \"(()(()))\".\nThe balance of a parentheses sequence is defined as the number of opening parentheses \"(\" minus the number of closing parentheses \")\". For example, the balance of the sequence \"(()((\" is 3.\nA balanced parentheses sequence can also be defined as a parentheses sequence with balance 0 such that each of its prefixes has a non-negative balance.\nWe define the balanced shuffle operation that takes a parentheses sequence and returns a parentheses sequence as follows: first, for every character of the input sequence, we compute the balance of the prefix of the sequence before that character and write those down in a table together with the positions of the characters in the input sequence, for example:\n\n\nThen, we sort the columns of this table in increasing order of prefix balance, breaking ties in decreasing order of position. In the above example, we get:\n\n\nThe last row of this table forms another parentheses sequence, in this case \"()(()())\". This sequence is called the result of applying the balanced shuffle operation to the input sequence, or in short just the balanced shuffle of the input sequence.\nYou are given a balanced parentheses sequence. Print its balanced shuffle.\nThe only line of input contains a string s consisting only of characters \"(\" and \")\". This string is guaranteed to be a non-empty balanced parentheses sequence with its length not exceeding 500000.\nPrint the parentheses sequence t\u00a0\u2014 the balanced shuffle of s.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1969B": {
        "title": "B. Shifts and Sorting",
        "description": "Let's define a cyclic shift of some string s as a transformation from s1s2\u2026sn\u22121sn into sns1s2\u2026sn\u22121. In other words, you take one last character sn and place it before the first character while moving all other characters to the right.\nYou are given a binary string s (a string consisting of only 0-s and/or 1-s).\nIn one operation, you can choose any substring slsl+1\u2026sr (1\u2264l<r\u2264|s|) and cyclically shift it. The cost of such operation is equal to r\u2212l+1 (or the length of the chosen substring).\nYou can perform the given operation any number of times. What is the minimum total cost to make s sorted in non-descending order?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains a binary string s (2\u2264|s|\u22642\u22c5105; si\u2208 {0, 1})\u00a0\u2014 the string you need to sort.\nAdditional constraint on the input: the sum of lengths of strings over all test cases doesn't exceed 2\u22c5105.\nFor each test case, print the single integer\u00a0\u2014 the minimum total cost to make string sorted using operation above any number of times.\nIn the first test case, you can choose the whole string and perform a cyclic shift: 10 \u2192 01. The length of the substring is 2, so the cost is 2.\nIn the second test case, the string is already sorted, so you don't need to perform any operations.\nIn the third test case, one of the optimal strategies is the next: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1968C": {
        "title": "C. Assembly via Remainders",
        "description": "You are given an array x2,x3,\u2026,xnx2,x3,\u2026,xn. Your task is to find any array a1,\u2026,an, where: \nHere cmodd denotes the remainder of the division of the integer c by the integer d. For example 5mod2=1, 72mod3=0, 143mod14=3.\nNote that if there is more than one a which satisfies the statement, you are allowed to find any.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264500)\u00a0\u2014 the number of elements in a.\nThe second line of each test case contains n\u22121 integers x2,\u2026,xn (1\u2264xi\u2264500)\u00a0\u2014 the elements of x.\nIt is guaranteed that the sum of values n over all test cases does not exceed 2\u22c5105.\nFor each test case output any a1,\u2026,an (1\u2264ai\u2264109) which satisfies the statement.\nIn the first test case a=[3,5,4,9] satisfies the conditions, because: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1966B": {
        "title": "B. Rectangle Filling",
        "description": "There is an n\u00d7m grid of white and black squares. In one operation, you can select any two squares of the same color, and color all squares in the subrectangle between them that color.\nFormally, if you select positions (x1,y1) and (x2,y2), both of which are currently the same color c, set the color of all (x,y) where min(x1,x2)\u2264x\u2264max(x1,x2) and min(y1,y2)\u2264y\u2264max(y1,y2) to c.\nThis diagram shows a sequence of two possible operations on a grid:\nIs it possible for all squares in the grid to be the same color, after performing any number of operations (possibly zero)?\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u2264500)\u00a0\u2014 the number of rows and columns in the grid, respectively.\nEach of the next n lines contains m characters 'W' and 'B'\u00a0\u2014 the initial colors of the squares of the grid. \nIt is guaranteed that the sum of n\u22c5m over all test cases does not exceed 3\u22c5105.\nFor each test case, print \"YES\" if it is possible to make all squares in the grid the same color, and \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn the first example, it is impossible to ever change the color of any square with an operation, so we output NO.\nThe second example is the case pictured above. As shown in that diagram, it is possible for all squares to be white after two operations, so we output YES.\nIn the third and fourth examples, all squares are already the same color, so we output YES.\nIn the fifth example we can do everything in two operations. First, select positions (2,1) and (1,4) and color all squares with 1\u2264x\u22642 and 1\u2264y\u22644 to white. Then, select positions (2,1) and (3,4) and color all squares with 2\u2264x\u22643 and 1\u2264y\u22644 to white. After these two operations all squares are white.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1958A": {
        "title": "A. 1-3-5",
        "description": "In Berland, coins of worth 1, 3 and 5 burles are commonly used (burles are local currency).\nEva has to pay exactly n burles in a shop. She has an infinite amount of coins of all three types. However, she doesn't like to pay using coins worth 1 burle \u2014 she thinks they are the most convenient to use.\nHelp Eva to calculate the minimum number of coins worth 1 burle she has to use, if she has to pay exactly n burles. Note that she can spend any number of coins worth 3 and/or 5 burles.\nThe first line contains one integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nEach test case consists of one line, containing one integer n (1\u2264n\u2264100).\nFor each test case, print one integer \u2014 the minimum number of 1-burle coins Eva has to use.\nIn the first test case, Eva should use 1 coin worth 1 burle, and 2 coins worth 3 burles.\nIn the second test case, Eva should use 1 coin worth 3 burles and 1 coin worth 5 burles.\nIn the third test case, Eva should use 14 coins worth 3 burles.\nIn the fourth test case, Eva should use 2 coins worth 1 burle.\nIn the fifth test case, Eva should use 2 coins worth 3 burles and 1 coin worth 5 burles.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "*special problem",
            "dp",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1957B": {
        "title": "B. A BIT of a Construction",
        "description": "Given integers n and k, construct a sequence of n non-negative (i.e. \u22650) integers a1,a2,\u2026,an such that \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains two integers n and k (1\u2264n\u22642\u22c5105, 1\u2264k\u2264109)\u00a0\u2014 the number of non-negative integers to be printed and the sum respectively.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a sequence a1,a2,\u2026,an on a new line that satisfies the conditions given above.\nIf there are multiple solutions, print any of them.\nIn the first test case, we have to print exactly one integer, hence we can only output 5 as the answer.\nIn the second test case, we output 1,2 which sum up to 3, and 1|2=(11)2 has two 1s in its binary representation, which is the maximum we can achieve in these constraints.\nIn the fourth test case, we output 3,1,1,32,2,12 which sum up to 51, and 3|1|1|32|2|12=(101111)2 has five 1s in its binary representation, which is the maximum we can achieve in these constraints.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1955B": {
        "title": "B. Progressive Square",
        "description": "A progressive square of size n is an n\u00d7n matrix. Maxim chooses three integers a1,1, c, and d and constructs a progressive square according to the following rules:\nai+1,j=ai,j+c\nai,j+1=ai,j+d\nFor example, if n=3, a1,1=1, c=2, and d=3, then the progressive square looks as follows:\n(1473695811)\nLast month Maxim constructed a progressive square and remembered the values of n, c, and d. Recently, he found an array b of n2 integers in random order and wants to make sure that these elements are the elements of that specific square.\nIt can be shown that for any values of n, a1,1, c, and d, there exists exactly one progressive square that satisfies all the rules.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains three integers n, c, and d (2\u2264n\u2264500, 1\u2264c,d\u2264106)\u00a0\u2014 the size of the square and the values of c and d as described in the statement.\nThe second line of each test case contains n\u22c5n integers b1,b2,\u2026,bn\u22c5n (1\u2264bi\u2264109)\u00a0\u2014 the elements found by Maxim.\nIt is guaranteed that the sum of n2 over all test cases does not exceed 25\u22c5104.\nFor each test case, output \"YES\" in a separate line if a progressive square for the given n, c, and d can be constructed from the array elements a, otherwise output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "implementation",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1954C": {
        "title": "C. Long Multiplication",
        "description": "You are given two integers x and y of the same length, consisting of digits from 1 to 9.\nYou can perform the following operation any number of times (possibly zero): swap the i-th digit in x and the i-th digit in y.\nFor example, if x=73 and y=31, you can swap the 2-nd digits and get x=71 and y=33.\nYour task is to maximize the product of x and y using the aforementioned operation any number of times. If there are multiple answers, print any of them.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer x (1\u2264x<10100).\nThe second line of each test case contains a single integer y (1\u2264y<10100).\nAdditional constraint on input: the integers x and y consist only of digits from 1 to 9.\nFor each test case, print two lines\u00a0\u2014 the first line should contain the number x after performing the operations; similarly, the second line should contain the number y after performing the operations. If there are multiple answers, print any of them.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1954B": {
        "title": "B. Make It Ugly",
        "description": "Let's call an array a beautiful if you can make all its elements the same by using the following operation an arbitrary number of times (possibly, zero): \nYou are given a beautiful array a1,a2,\u2026,an. What is the minimum number of elements you have to remove from it in order for it to stop being beautiful? Swapping elements is prohibited. If it is impossible to do so, then output -1.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22643\u22c5105).\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n).\nAdditional constraints on the input:\nFor each test case, output a single integer\u00a0\u2014 the minimum number of elements you have to remove from the array a in order for it to stop being beautiful. If it is impossible, then output -1.\nIn the first testcase, it is impossible to modify the array in such a way that it stops being beautiful. An array consisting of identical numbers will remain beautiful no matter how many numbers we remove from it.\nIn the second testcase, you can remove the number at the index 5, for example.\nThe resulting array will be [1,2,1,2]. Let's check if it is beautiful. Two operations are available: \nThus, the array [1,2,1,2] is not beautiful.\nIn the fourth testcase, you can remove the first three elements, for example. The resulting array [5,3,3,3] is not beautiful.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1951B": {
        "title": "B. Battle Cows",
        "description": "There are nn cows participating in a coding tournament. Cow i has a Cowdeforces rating of ai (all distinct), and is initially in position i. The tournament consists of n\u22121 matches as follows: \nYou are the owner of cow k. For you, winning the tournament is not important; rather, you want your cow to win in as many matches as possible. As an acquaintance of the tournament organizers, you can ask them to swap the position of your cow with another cow only once, or you can choose to do nothing.\nFind the maximum number of wins your cow can achieve.\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (2\u2264n\u2264105,1\u2264k\u2264n)\u00a0\u2014 the number of cows and your cow's index.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the Cowdeforces rating of the cows. It is guaranteed that ai's are pairwise different.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print one integer: the maximum number of wins cow k can achieve if you choose to swap (or do nothing) optimally.\nIn the first test case, it is optimal to do nothing. Let a\u2032 be the Cowdeforces rating of the cows in the original order (with your cow's rating bolded), then \nIn the second test case, it is optimal to swap your cow to position 3. Then, let a\u2032 be the Cowdeforces rating of the cows in the order after the swap. ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1950D": {
        "title": "D. Product of Binary Decimals",
        "description": "Let's call a number a binary decimal if it is a positive integer and all digits in its decimal notation are either 0 or 1. For example, 1010111 is a binary decimal, while 10201 and 787788 are not.\nGiven a number n, you are asked whether or not it is possible to represent n as a product of some (not necessarily distinct) binary decimals.\nThe first line contains a single integer t (1\u2264t\u22645\u22c5104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a single integer n (1\u2264n\u2264105).\nFor each test case, output \"YES\" (without quotes) if n can be represented as a product of binary decimals, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yES\", \"yes\", and \"Yes\" will be recognized as a positive response).\nThe first five test cases can be represented as a product of binary decimals as follows: ",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "implementation",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1948B": {
        "title": "B. Array Fix",
        "description": "You are given an integer array a of length n.\nYou can perform the following operation any number of times (possibly zero): take any element of the array a, which is at least 10, delete it, and instead insert the digits that element consisted of in the same position, in order they appear in that element.\nFor example:\nYour task is to determine whether it is possible to make a sorted in non-descending order using the aforementioned operation any number of times (possibly zero). In other words, you have to determine if it is possible to transform the array a in such a way that a1\u2264a2\u2264\u22ef\u2264ak, where k is the current length of the array a.\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases.\nEach test case consists of two lines:\nFor each test case, print YES if it is possible to make a sorted in non-decreasing order using the aforementioned operation; otherwise, print NO.\nYou can print each letter in any case. For example, yes, Yes, YeS will all be recognized as a positive answer.\nIn the first example, you can split the first element, then the array becomes [1,2,3,45,67].\nIn the second example, there is no way to get a sorted array.\nIn the third example, the array is already sorted.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1946B": {
        "title": "B. Maximum Sum",
        "description": "You have an array a of n integers.\nYou perform exactly k operations on it. In one operation, you select any contiguous subarray of the array a (possibly empty) and insert the sum of this subarray anywhere in the array.\nYour task is to find the maximum possible sum of the array after k such operations.\nAs this number can be very large, output the answer modulo 109+7.\nReminder: the remainder of a number x modulo p is the smallest non-negative y such that there exists an integer q and x=p\u22c5q+y.\nEach test consists of several test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers n and k (1\u2264n,k\u22642\u22c5105)\u00a0\u2014 the length of the array a and the number of operations, respectively.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109)\u00a0\u2014 the array a itself.\nIt is guaranteed that the sum of the values of n and k for all test cases does not exceed 2\u22c5105.\nFor each test, output a single integer\u00a0\u2014 the maximum sum of the array that can be obtained after k operations modulo 109+7.\nIn the first test case, it is advantageous to take an empty subarray of the array twice and insert the sum of the empty subarray (zero) anywhere, then the sum of the resulting array will be (\u22124)+(\u22127)+0+0=\u221211, modulo 109+7 this is 999999996.\nIn the second test case, it is advantageous to take the sum of the entire array three times and place it anywhere in the array, then one of the possible sequences of actions: [2,2,8] \u2192 [2,2,8,12] \u2192 [2,2,8,12,24] \u2192 [2,2,8,12,24,48], the sum of the final array is 2+2+8+12+24+48=96.\nIn the fourth test case, it is advantageous to take a subarray of the array consisting of the first three numbers (i.e. consisting of the numbers 4,\u22122 and 8) and insert its sum at the beginning of the array, thereby obtaining the array [10,4,\u22122,8,\u221212,9], the sum of this array is 17.\nIn the seventh test case, it will always be advantageous for us to take an empty subarray of the array. In this case, the sum of the resulting array will not differ from the sum of the original. The answer will be the sum of the original array, taken modulo\u00a0\u2014 42, because (\u22126\u22c5(109+7)+42=\u22126000000000).",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1945C": {
        "title": "C. Left and Right Houses",
        "description": "In the village of Letovo, there are n houses. The villagers decided to build a big road that will divide the village into left and right sides. Each resident wants to live on either the right or the left side of the street, which is described as a sequence a1,a2,\u2026,an, where aj=0 if the resident of the j-th house wants to live on the left side of the street; otherwise, aj=1.\nThe road will pass between two houses. The houses to the left of it will be declared the left-side, and the houses to the right will be declared the right-side. More formally, let the road pass between houses i and i+1. Then the houses at positions between 1 and i will be on the left side of the street, and at positions between i+1 and n will be on the right side. The road also may pass before the first and after the last house; in this case, the entire village is declared to be either the right or left side, respectively.\nTo make the design fair, it was decided to lay the road so that at least half of the residents on each side of the village are satisfied with the choice. That is, among x residents on one side, at least \u2308x2\u2309 should want to live on that side, where \u2308x\u2309 denotes rounding up a real number x.\nDetermine after which house i the road should be laid in order to satisfy the described condition and be as close to the middle of the village as possible. Formally, among all suitable positions i, minimize |n2\u2212i|.\nIf there are multiple suitable positions i with the minimum |n2\u2212i|, output the smaller one.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22642\u22c5104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u22643\u22c5105). The next line of each test case contains a string a of length n, consisting only of 0 and 1.\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test case, output a single number i\u00a0\u2014 the position of the house after which the road should be laid (if it should be laid before the first house, output 0). We can show that the answer always exists.\nLet's consider the first example of input data.\nIf we lay the road after the first house, there will be one house a1=1 on the left side of the street, the resident of which would like to live on the right side of the street. Then 0 out of 1 residents on the even side will be satisfied with the choice, which means that the road cannot be laid after house 1.\nIf we lay the road after the second house, 1 out of 2 residents on the left side (with preferences a1=1, a2=0) and 1 out of 1 resident on the right side (with preference a3=1) will be satisfied with the choice. More than half of the residents on each side are satisfied with the choice, which means that the road can be laid after house 2. We can show that this is the optimal answer.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1944B": {
        "title": "B. Equal XOR",
        "description": "You are given an array a of length 2n, consisting of each integer from 1 to n exactly twice.\nYou are also given an integer k (1\u2264k\u2264\u230an2\u230b).\nYou need to find two arrays l and r each of length 2k such that: \nIt can be proved that at least one pair of l and r always exists. If there are multiple solutions, you may output any one of them.\n\u2020 A sequence x is a subset of a sequence y if x can be obtained by deleting several (possibly none or all) elements of y and rearranging the elements in any order. For example, [3,1,2,1], [1,2,3], [1,1] and [3,2] are subsets of [1,1,2,3] but [4] and [2,2] are not subsets of [1,1,2,3].\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u22645000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains 2 integers n and k (2\u2264n\u22645\u22c5104, 1\u2264k\u2264\u230an2\u230b).\nThe second line contains 2n integers a1,a2,\u2026,a2n (1\u2264ai\u2264n). It is guaranteed that every integer from 1 to n occurs exactly twice in a.\nIt is guaranteed that the sum of n over all test cases does not exceed 5\u22c5104.\nFor each test case, output two lines. \nOn the first line of output, output 2k integers l1,l2,\u2026,l2k.\nOn the second line of output, output 2k integers r1,r2,\u2026r2k.\nIf there are multiple solutions, you may output any one of them.\nIn the first test case, we choose l=[2,1] and r=[2,1]. [2,1] is a subset of [a1,a2] and [2,1] is a subset of [a3,a4], and 2\u22951=2\u22951=3.\nIn the second test case, 6\u22954=1\u22953=2.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1942B": {
        "title": "B. Bessie and MEX",
        "description": "Farmer John has a permutation p1,p2,\u2026,pn, where every integer from 0 to n\u22121 occurs exactly once. He gives Bessie an array a of length n and challenges her to construct p based on a. \nThe array a is constructed so that ai = MEX(p1,p2,\u2026,pi)\u2212pi, where the MEX of an array is the minimum non-negative integer that does not appear in that array. For example, MEX(1,2,3)=0 and MEX(3,1,0)=2.\nHelp Bessie construct any valid permutation p that satisfies a. The input is given in such a way that at least one valid p exists. If there are multiple possible p, it is enough to print one of them.\nThe first line contains t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the lengths of p and a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212n\u2264ai\u2264n)\u00a0\u2014 the elements of array a.\nIt is guaranteed that there is at least one valid p for the given data.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers on a new line, the elements of p.\nIf there are multiple solutions, print any of them.\nIn the first case, p=[0,1,4,2,3] is one possible output.\na will then be calculated as a1=MEX(0)\u22120=1, a2=MEX(0,1)\u22121=1, a3=MEX(0,1,4)\u22124=\u22122, a4=MEX(0,1,4,2)\u22122=1, a5=MEX(0,1,4,2,3)\u22123=2.\nSo, as required, a will be [1,1,\u22122,1,2].",
        "time_limit": "time limit per test1.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1941D": {
        "title": "D. Rudolf and the Ball Game",
        "description": "Rudolf and Bernard decided to play a game with their friends. nn people stand in a circle and start throwing a ball to each other. They are numbered from 1 to n in the clockwise order.\nLet's call a transition a movement of the ball from one player to his neighbor. The transition can be made clockwise or counterclockwise.\nLet's call the clockwise (counterclockwise) distance from player y1 to player y2 the number of transitions clockwise (counterclockwise) that need to be made to move from player y1 to player y2. For example, if n=7 then the clockwise distance from 2 to 5 is 3, and the counterclockwise distance from 2 to 5 is 4.\nInitially, the ball is with the player number x (players are numbered clockwise). On the i-th move the person with the ball throws it at a distance of ri (1\u2264ri\u2264n\u22121) clockwise or counterclockwise. For example, if there are 7 players, and the 2nd player, after receiving the ball, throws it a distance of 5, then the ball will be caught by either the 7th player (throwing clockwise) or the 4th player (throwing counterclockwise). An illustration of this example is shown below.\nThe game was interrupted after m throws due to unexpected rain. When the rain stopped, the guys gathered again to continue. However, no one could remember who had the ball. As it turned out, Bernard remembered the distances for each of the throws and the direction for some of the throws (clockwise or counterclockwise).\nRudolf asks you to help him and based on the information from Bernard, calculate the numbers of the players who could have the ball after m throws.\nThe first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains three integers n,m,x (2\u2264n\u22641000, 1\u2264m\u22641000, 1\u2264x\u2264n) \u2014 the number of players, the number of throws made, and the number of the player who threw the ball first, respectively.\nThe next m lines contain information about each throw in order. Each of them contains an integer ri (1\u2264ri\u2264n\u22121) \u2014 the distance at which the i-th throw was made, and a symbol ci, equal to '0', '1', or '?':\nIt is guaranteed that the sum n\u22c5m (n multiplied by m) over all test cases does not exceed 2\u22c5105.\nFor each test case, output two lines.\nIn the first line, output the number of players k (1\u2264k\u2264n) who could have the ball at the end of the game.\nIn the next line, output k numbers bi (1\u2264bi\u2264n) \u2014 the numbers of the players in increasing order. All numbers must be different.\nBelow is an illustration of three throws for the first test case. The arrows denote possible throw directions. Players who could have the ball after the throw are highlighted in gray.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "dp",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1941B": {
        "title": "B. Rudolf and 121",
        "description": "Rudolf has an array a of n integers, the elements are numbered from 1 to n.\nIn one operation, he can choose an index i (2\u2264i\u2264n\u22121) and assign:\nRudolf can apply this operation any number of times. Any index i can be used zero or more times.\nCan he make all the elements of the array equal to zero using this operation?\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases in the test.\nThe first line of each case contains a single integer n (3\u2264n\u22642\u22c5105)\u00a0\u2014 the number of elements in the array.\nThe second line of each case contains n integers a1,a2,\u2026,an (0\u2264aj\u2264109)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of the values of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" if it is possible to make all the elements of the array zero using the described operations. Otherwise, output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nIn the first example, the original array is [1,3,5,5,2], to make all its elements zero, Rudolf can act as follows:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1935B": {
        "title": "B. Informatics in MAC",
        "description": "In the Master's Assistance Center, Nyam-Nyam was given a homework assignment in informatics.\nThere is an array a of length n, and you want to divide it into k>1 subsegments\u2020 in such a way that the MEX\u2021 on each subsegment is equal to the same integer.\nHelp Nyam-Nyam find any suitable division, or determine that it does not exist.\n\u2020A division of an array into k subsegments is defined as k pairs of integers (l1,r1),(l2,r2),\u2026,(lk,rk) such that li\u2264ri and for each 1\u2264j\u2264k\u22121, lj+1=rj+1, and also l1=1 and rk=n. These pairs represent the subsegments themselves.\n\u2021MEX of an array is the smallest non-negative integer that does not belong to the array.\nFor example: \nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai<n) \u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer \u22121 if a suitable division does not exist.\nOtherwise, on the first line, output an integer k (2\u2264k\u2264n) \u2014 the number of subsegments in the division.\nThen output k lines \u2014 the division into subsegments. The i-th line should contain two integers li and ri (1\u2264li\u2264ri\u2264n) \u2014 the boundaries of the i-th subsegment.\nThe following conditions must be satisfied:\nIf there are multiple possible solutions, output any of them.\nIn the first test case, the array a can be divided into 2 subsegments with boundaries [1,1] and [2,2]: \nIn the second test case, it can be proven that the required division does not exist.\nIn the third test case, the array a can be divided into 3 subsegments with boundaries [1,3], [4,5], [6,8]: ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1934B": {
        "title": "B. Yet Another Coin Problem",
        "description": "You have 55 different types of coins, each with a value equal to one of the first 5 triangular numbers: 1, 3, 6, 10, and 15. These coin types are available in abundance. Your goal is to find the minimum number of these coins required such that their total value sums up to exactly n.\nWe can show that the answer always exists.\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264109)\u00a0\u2014 the target value.\nFor each test case, output a single number\u00a0\u2014 the minimum number of coins required.\nIn the first test case, for n=1, the answer is 1 since only one 1 value coin is sufficient. 1=1\u22c51.\nIn the fourth test case, for n=5, the answer is 3, which can be achieved using two 1 value coins and one 3 value coin. 5=2\u22c51+1\u22c53.\nIn the seventh test case, for n=12, the answer is 2, which can be achieved using two 6 value coins.\nIn the ninth test case, for n=16, the answer is 2, which can be achieved using one 1 value coin and one 15 value coin or using one 10 value coin and one 6 value coin. 16=1\u22c51+1\u22c515=1\u22c56+1\u22c510.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1933D": {
        "title": "D. Turtle Tenacity: Continual Mods",
        "description": "Given an array a1,a2,\u2026,an, determine whether it is possible to rearrange its elements into b1,b2,\u2026,bn, such that b1modb2mod\u2026modbn\u22600.\nHere xmody denotes the remainder from dividing x by y. Also, the modulo operations are calculated from left to right. That is, xmodymodz=(xmody)modz. For example, 2024mod1000mod8=(2024mod1000)mod8=24mod8=0.\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" if it is possible, \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn the first test case, rearranging the array into b=[1,2,3,4,5,6] (doing nothing) would result in 1mod2mod3mod4mod5mod6=1. Hence it is possible to achieve the goal.\nIn the second test case, the array b must be equal to [3,3,3,3,3], which would result in 3mod3mod3mod3mod3=0. Hence it is impossible to achieve the goal.\nIn the third test case, rearranging the array into b=[3,2,2] would result in 3mod2mod2=1. Hence it is possible to achieve the goal.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1933C": {
        "title": "C. Turtle Fingers: Count the Values of k",
        "description": "You are given three positive integers aa, b and l (a,b,l>0). \nIt can be shown that there always exists a way to choose non-negative (i.e. \u22650) integers k, x, and y such that l=k\u22c5ax\u22c5by. \nYour task is to find the number of distinct possible values of k across all such ways.\nThe first line contains the integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe following t lines contain three integers, a, b and l (2\u2264a,b\u2264100, 1\u2264l\u2264106)\u00a0\u2014 description of a test case.\nOutput t lines, with the i-th (1\u2264i\u2264t) line containing an integer, the answer to the i-th test case.\nIn the first test case, a=2,b=5,l=20. The possible values of k (and corresponding x,y) are as follows: \nIn the second test case, a=2,b=5,l=21. Note that l=21 is not divisible by either a=2 or b=5. Therefore, we can only set x=0,y=0, which corresponds to k=21.\nIn the third test case, a=4,b=6,l=48. The possible values of k (and corresponding x,y) are as follows: ",
        "time_limit": "time limit per test5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1932B": {
        "title": "B. Chaya Calendar",
        "description": "The Chaya tribe believes that there are n signs of the apocalypse. Over time, it has been found out that the i-th sign occurs every ai years (in years ai, 2\u22c5ai, 3\u22c5ai, \u2026).\nAccording to the legends, for the apocalypse to happen, the signs must occur sequentially. That is, first they wait for the first sign to occur, then strictly after it, the second sign will occur, and so on. That is, if the i-th sign occurred in the year x, the tribe starts waiting for the occurrence of the (i+1)-th sign, starting from the year x+1.\nIn which year will the n-th sign occur and the apocalypse will happen?\nThe first line of the input contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. Then follow the descriptions of the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100)\u00a0\u2014 the number of signs.\nThe second line of each test case contains n integers a1,a2,a3,\u2026,an (1\u2264ai\u2264106)\u00a0\u2014 the periodicities of the signs.\nFor each test case, output a single integer\u00a0\u2014 the year in which all n signs will occur.\nIn the first set of input data of the example:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1931C": {
        "title": "C. Make Equal Again",
        "description": "You have an array a of n integers. \nYou can no more than once apply the following operation: select three integers i, j, x (1\u2264i\u2264j\u2264n) and assign all elements of the array with indexes from i to j the value x. The price of this operation depends on the selected indices and is equal to (j\u2212i+1) burles. \nFor example, the array is equal to [1,2,3,4,5,1]. If we choose i=2,j=4,x=8, then after applying this operation, the array will be equal to [1,8,8,8,5,1].\nWhat is the least amount of burles you need to spend to make all the elements of the array equal?\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of input test cases. The descriptions of the test cases follow.\nThe first line of the description of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u2014 the size of the array.\nThe second line of the description of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n) \u2014 array elements.\nIt is guaranteed that the sum of n for all test cases does not exceed 2\u22c5105.\nFor each test case, output one integer \u2014 the minimum number of burles that will have to be spent to make all the elements of the array equal. It can be shown that this can always be done.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1930B": {
        "title": "B. Permutation Printing",
        "description": "You are given a positive integer n.\nFind a permutation\u2020 p of length n such that there do not exist two distinct indices i and j (1\u2264i,j<n; i\u2260j) such that pi divides pj and pi+1 divides pj+1.\nRefer to the Notes section for some examples.\nUnder the constraints of this problem, it can be proven that at least one p exists.\n\u2020 A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u2264105)\u00a0\u2014 the length of the permutation p.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output p1,p2,\u2026,pn.\nIf there are multiple solutions, you may output any one of them.\nIn the first test case, p=[4,1,2,3] is a valid permutation. However, the permutation p=[1,2,3,4] is not a valid permutation as we can choose i=1 and j=3. Then p1=1 divides p3=3 and p2=2 divides p4=4. Note that the permutation p=[3,4,2,1] is also not a valid permutation as we can choose i=3 and j=2. Then p3=2 divides p2=4 and p4=1 divides p3=2.\nIn the second test case, p=[1,2,3] is a valid permutation. In fact, all 6 permutations of length 3 are valid.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1928B": {
        "title": "B. Equalize",
        "description": "Vasya has two hobbies\u00a0\u2014 adding permutations\u2020 to arrays and finding the most frequently occurring element. Recently, he found an array a and decided to find out the maximum number of elements equal to the same number in the array a that he can obtain after adding some permutation to the array a.\nMore formally, Vasya must choose exactly one permutation p1,p2,p3,\u2026,pn of length n, and then change the elements of the array a according to the rule ai:=ai+pi. After that, Vasya counts how many times each number occurs in the array a and takes the maximum of these values. You need to determine the maximum value he can obtain.\n\u2020A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642\u22c5104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single number\u00a0\u2014 the maximum number of elements equal to the same number after the operation of adding a permutation.\nIn the first test case, it is optimal to choose p=[2,1]. Then after applying the operation, the array a will be [3,3], in which the number 3 occurs twice, so the answer is 2.\nIn the second test case, one of the optimal options is p=[2,3,1,4]. After applying the operation, the array a will be [9,4,5,5]. Since the number 5 occurs twice, the answer is 2.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "two pointers",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1927C": {
        "title": "C. Choose the Different Ones!",
        "description": "Given an array a of n integers, an array b of m integers, and an even number k.\nYour task is to determine whether it is possible to choose exactly k2 elements from both arrays in such a way that among the chosen elements, every integer from 1 to k is included.\nFor example:\nNote that you are not required to find a way to choose the elements\u00a0\u2014 your program should only check whether it is possible to choose the elements in the required way.\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains three integers n, m, and k (1\u2264n,m\u22642\u22c5105, 2\u2264k\u22642\u22c5min(n,m), k is even)\u00a0\u2014 the length of array a, the length of array b, and the number of elements to be chosen, respectively.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106)\u00a0\u2014 the elements of array a.\nThe third line of each test case contains m integers b1,b2,\u2026,bm (1\u2264bj\u2264106)\u00a0\u2014 the elements of array b.\nIt is guaranteed that the sum of values n and m over all test cases in a test does not exceed 4\u22c5105.\nOutput t lines, each of which is the answer to the corresponding test case. As the answer, output \"YES\" if it is possible to choose k2 numbers from each array in such a way that among the chosen elements, every integer from 1 to k is included. Otherwise, output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be accepted as a positive answer.\nIn the first test case of the example, it is possible to choose elements equal to 2, 3, and 6 from array a and elements equal to 1, 4, and 5 from array b. Thus, all numbers from 1 to k=6 are included among the chosen elements.\nIn the second test case of the example, it can be shown that it is not possible to choose exactly three elements from each array in the required way.\nIn the third test case of the example, it is possible to choose elements equal to 1 and 3 from array a and elements equal to 2 and 4 from array b. Thus, all numbers from 1 to k=4 are included among the chosen elements.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1926C": {
        "title": "C. Vlad and a Sum of Sum of Digits",
        "description": "Please note that the time limit for this problem is only 0.5 seconds per test.\nVladislav wrote the integers from 1 to n, inclusive, on the board. Then he replaced each integer with the sum of its digits.\nWhat is the sum of the numbers on the board now?\nFor example, if n=12 then initially the numbers on the board are: 1,2,3,4,5,6,7,8,9,10,11,12. Then after the replacement, the numbers become: 1,2,3,4,5,6,7,8,9,1,2,3. The sum of these numbers is 1+2+3+4+5+6+7+8+9+1+2+3=51. Thus, for n=12 the answer is 51.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the largest number Vladislav writes.\nFor each test case, output a single integer\u00a0\u2014 the sum of the numbers at the end of the process.",
        "time_limit": "time limit per test0.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1925B": {
        "title": "B. A Balanced Problemset?",
        "description": "Jay managed to create a problem of difficulty x and decided to make it the second problem for Codeforces Round #921. \nBut Yash fears that this problem will make the contest highly unbalanced, and the coordinator will reject it. So, he decided to break it up into a problemset of n sub-problems such that the difficulties of all the sub-problems are a positive integer and their sum is equal to x. \nThe coordinator, Aleksey, defines the balance of a problemset as the GCD of the difficulties of all sub-problems in the problemset. \nFind the maximum balance that Yash can achieve if he chooses the difficulties of the sub-problems optimally.\nThe first line of input contains a single integer t (1\u2264t\u2264103) denoting the number of test cases.\nEach test case contains a single line of input containing two integers x (1\u2264x\u2264108) and n (1\u2264n\u2264x).\nFor each test case, print a single line containing a single integer denoting the maximum balance of the problemset Yash can achieve.\nFor the first test case, one possible way is to break up the problem of difficulty 10 into a problemset having three problems of difficulties 4, 2 and 4 respectively, giving a balance equal to 2.\nFor the second test case, there is only one way to break up the problem of difficulty 5 into a problemset of 5 problems with each problem having a difficulty 1 giving a balance equal to 1.",
        "time_limit": "time limit per test1.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1923B": {
        "title": "B. Monsters Attack!",
        "description": "You are playing a computer game. The current level of this game can be modeled as a straight line. Your character is in point 00 of this line. There are n monsters trying to kill your character; the i-th monster has health equal to ai and is initially in the point xi.\nEvery second, the following happens:\nCan you survive and kill all n monsters without letting any of them reach your character?\nThe first line of the input contains one integer t (1\u2264t\u22643\u22c5104) \u2014 the number of test cases.\nEach test case consists of three lines:\nAdditional constraint on the input: the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test case, print YES if you can kill all n monsters before they reach your character, or NO otherwise.\nYou can output each letter of the answer in any case (upper or lower). For example, the strings yEs, yes, Yes, and YES will all be recognized as positive responses.\nIn the first example, you can act as follows:\nIn the second example, you can fire only 1 bullet, so you can kill only one of the two monsters during the 1-st second. Then, the remaining monster moves closer and kills your character.",
        "time_limit": "time limit per test2.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1922B": {
        "title": "B. Forming Triangles",
        "description": "You have n sticks, numbered from 1 to n. The length of the i-th stick is 2ai.\nYou want to choose exactly 3 sticks out of the given n sticks, and form a non-degenerate triangle out of them, using the sticks as the sides of the triangle. A triangle is called non-degenerate if its area is strictly greater than 0.\nYou have to calculate the number of ways to choose exactly 3 sticks so that a triangle can be formed out of them. Note that the order of choosing sticks does not matter (for example, choosing the 1-st, 2-nd and 4-th stick is the same as choosing the 2-nd, 4-th and 1-st stick). \nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of two lines:\nAdditional constraint on the input: the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test case, print one integer \u2014 the number of ways to choose exactly 3 sticks so that a triangle can be formed out of them.\nIn the first test case of the example, any three sticks out of the given 7 can be chosen.\nIn the second test case of the example, you can choose the 1-st, 2-nd and 4-th stick, or the 1-st, 3-rd and 4-th stick.\nIn the third test case of the example, you cannot form a triangle out of the given sticks with lengths 2, 4 and 8.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "constructive algorithms",
            "math",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1921D": {
        "title": "D. Very Different Array",
        "description": "Petya has an array ai of n integers. His brother Vasya became envious and decided to make his own array of n integers.\nTo do this, he found m integers bi (m\u2265n), and now he wants to choose some n integers of them and arrange them in a certain order to obtain an array ci of length n.\nTo avoid being similar to his brother, Vasya wants to make his array as different as possible from Petya's array. Specifically, he wants the total difference D=\u2211ni=1|ai\u2212ci| to be as large as possible.\nHelp Vasya find the maximum difference D he can obtain.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. This is followed by a description of the test cases.\nThe first line of each test case contains two integers n and m (1\u2264n\u2264m\u22642\u22c5105).\nThe second line of each test case contains n integers ai (1\u2264ai\u2264109). The third line of each test case contains m integers bi (1\u2264bi\u2264109).\nIt is guaranteed that in a test, the sum of m over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u2014 the maximum total difference D that can be obtained.\nIn the first example, Vasya can, for example, create the array (1,5,7,2). Then the total difference will be D=|6\u22121|+|1\u22125|+|2\u22127|+|4\u22122|=5+4+5+2=16.\nIn the second example, all the integers available to Vasya are equal to 1, so he can only create the array (1,1,1), for which the difference D=0.\nIn the third example, Vasya can, for example, create the array (5,4,3,2,1). Then the total difference will be D=|1\u22125|+|2\u22124|+|3\u22123|+|4\u22122|+|5\u22121|=4+2+0+2+4=12.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1920B": {
        "title": "B. Summation Game",
        "description": "Alice and Bob are playing a game. They have an array a1,a2,\u2026,an. The game consists of two steps:\nAlice wants to maximize the sum of elements of the array while Bob wants to minimize it. Find the sum of elements of the array after the game if both players play optimally.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains three integers n, k, and x (1\u2264n\u22642\u22c5105, 1\u2264x,k\u2264n) \u2014 the number of elements in the array, the limit on the number of elements of the array that Alice can remove, and the limit on the number of elements of the array that Bob can multiply \u22121 to.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u22641000) \u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105. \nFor each test case, output a single integer \u2014 the sum of elements of the array after the game if both players play optimally.\nIn the first test case, it is optimal for Alice to remove the only element of the array. Then, the sum of elements of the array is 0 after the game is over.\nIn the second test case, it is optimal for Alice to not remove any elements. Bob will then multiply 4 by \u22121. So the final sum of elements of the array is 3+1+2\u22124=2.\nIn the fifth test case, it is optimal for Alice to remove 9,9. Bob will then multiply 5,5,3 by \u22121. So the final sum of elements of the array is \u22125\u22125\u22123+3+3+2=\u22125.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "math",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1917B": {
        "title": "B. Erase First or Second Letter",
        "description": "You are given a string ss of length n. Let's define two operations you can apply on the string:\nYour task is to find the number of distinct non-empty strings that can be generated by applying the given operations on the initial string any number of times (possibly zero), in any order.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains n (1\u2264n\u2264105) \u2014 the length of the string.\nThe second line of each test case contains the string s. It is guaranteed that the string only contains lowercase letters of the English alphabet.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer: the number of distinct non-empty strings you can get.\nIn the first test case, we can get the following strings: a, aa, aaa, aaaa, aaaaa.\nIn the third test case, for example, the word ba can be reached in the following way:",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "data structures",
            "dp",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1916C": {
        "title": "C. Training Before the Olympiad",
        "description": "Masha and Olya have an important team olympiad coming up soon. In honor of this, Masha, for warm-up, suggested playing a game with Olya:\nThere is an array a of size n. Masha goes first, and the players take turns. Each move is described by the following sequence of actions:\n\u2219 If the size of the array is 1, the game ends.\n\u2219 The player who is currently playing chooses two different indices i, j (1\u2264i,j\u2264|a|), and performs the following operation\u00a0\u2014 removes ai and aj from the array and adds to the array a number equal to \u230aai+aj2\u230b\u22c52. In other words, first divides the sum of the numbers ai, aj by 2 rounding down, and then multiplies the result by 2.\nMasha aims to maximize the final number, while Olya aims to minimize it.\nMasha and Olya decided to play on each non-empty prefix of the initial array a, and asked for your help.\nFor each k=1,2,\u2026,n, answer the following question. Let only the first k elements of the array a be present in the game, with indices 1,2,\u2026,k respectively. What number will remain at the end with optimal play by both players?\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the size of the array.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the array on which Masha and Olya play.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output n integers. The k-th of these numbers should be equal to the number that will remain at the end with optimal play by both players, on the array consisting of the first k elements of the array a.\nIn the third test case, for a prefix of length 1, the answer is 3. For a prefix of length 2, Masha has only one move, so the answer is 12. For a prefix of length 3, Masha has three possible moves: she chooses 3 and 10, then the final number is 22, 3 and 11, then the final number is 24, 10 and 11, then the final number is 22, so Masha will choose 3 and 11 and get 24.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1916B": {
        "title": "B. Two Divisors",
        "description": "A certain number 1\u2264x\u2264109 is chosen. You are given two integers a and b, which are the two largest divisors of the number x. At the same time, the condition 1\u2264a<b<x is satisfied.\nFor the given numbers a, b, you need to find the value of x.\n\u2020 The number y is a divisor of the number x if there is an integer k such that x=y\u22c5k.\nEach test consists of several test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then follows the description of the test cases.\nThe only line of each test cases contains two integers a, b (1\u2264a<b\u2264109).\nIt is guaranteed that a, b are the two largest divisors for some number 1\u2264x\u2264109.\nFor each test case, output the number x, such that a and b are the two largest divisors of the number x.\nIf there are several answers, print any of them.\nFor the first test case, all divisors less than 6 are equal to [1,2,3], among them the two largest will be 2 and 3.\nFor the third test case, all divisors less than 33 are equal to [1,3,11], among them the two largest will be 3 and 11.\nFor the fifth test case, all divisors less than 20 are equal to [1,2,4,5,10], among them the two largest will be 5 and 10.\nFor the sixth test case, all divisors less than 12 are equal to [1,2,3,4,6], among them the two largest will be 4 and 6.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1914D": {
        "title": "D. Three Activities",
        "description": "Winter holidays are coming up. They are going to last for n days.\nDuring the holidays, Monocarp wants to try all of these activities exactly once with his friends: \nMonocarp knows that, on the i-th day, exactly ai friends will join him for skiing, bi friends will join him for a movie and ci friends will join him for board games.\nMonocarp also knows that he can't try more than one activity in a single day.\nThus, he asks you to help him choose three distinct days x,y,z in such a way that the total number of friends to join him for the activities (ax+by+cz) is maximized.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (3\u2264n\u2264105)\u00a0\u2014 the duration of the winter holidays in days.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264108)\u00a0\u2014 the number of friends that will join Monocarp for skiing on the i-th day.\nThe third line contains n integers b1,b2,\u2026,bn (1\u2264bi\u2264108)\u00a0\u2014 the number of friends that will join Monocarp for a movie on the i-th day.\nThe fourth line contains n integers c1,c2,\u2026,cn (1\u2264ci\u2264108)\u00a0\u2014 the number of friends that will join Monocarp for board games on the i-th day.\nThe sum of n over all testcases doesn't exceed 105.\nFor each testcase, print a single integer\u00a0\u2014 the maximum total number of friends that can join Monocarp for the activities on three distinct days.\nIn the first testcase, Monocarp can choose day 2 for skiing, day 1 for a movie and day 3 for board games. This way, a2=10 friends will join him for skiing, b1=10 friends will join him for a movie and c3=10 friends will join him for board games. The total number of friends is 30.\nIn the second testcase, Monocarp can choose day 1 for skiing, day 4 for a movie and day 2 for board games. 30+20+25=75 friends in total. Note that Monocarp can't choose day 1 for all activities, because he can't try more than one activity in a single day.\nIn the third testcase, Monocarp can choose day 2 for skiing, day 3 for a movie and day 7 for board games. 19+19+17=55 friends in total.\nIn the fourth testcase, Monocarp can choose day 1 for skiing, day 4 for a movie and day 9 for board games. 17+19+20=56 friends in total.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1914C": {
        "title": "C. Quests",
        "description": "Monocarp is playing a computer game. In order to level up his character, he can complete quests. There are n quests in the game, numbered from 1 to n.\nMonocarp can complete quests according to the following rules: \nNote that Monocarp can complete the same quest multiple times.\nFor each completion, the character gets some amount of experience points: \nMonocarp is a very busy person, so he has free time to complete no more than k quests. Your task is to calculate the maximum possible total experience Monocarp can get if he can complete no more than k quests.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n and k (1\u2264n\u22642\u22c5105; 1\u2264k\u22642\u22c5105)\u00a0\u2014 the number of quests and the maximum number of quests Monocarp can complete, respectively.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264103).\nThe third line contains n integers b1,b2,\u2026,bn (1\u2264bi\u2264103).\nAdditional constraint on the input: the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the maximum possible total experience Monocarp can get if he can complete no more than k quests.\nIn the first test case, one of the possible quest completion sequences is as follows: 1,1,2,3,2,4,4; its total experience is equal to 4_+1+3_+1_+1+2_+1=13 (the underlined numbers correspond to the instances when we complete a quest for the first time).\nIn the second test case, one of the possible quest completion sequences is as follows: 1,1; its total experience is equal to 1_+3=4.\nIn the third test case, one of the possible quest completion sequences is as follows: 1,2,2,2,3; its total experience is equal to 3_+2_+3+3+4_=15.",
        "time_limit": "time limit per test2.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1913B": {
        "title": "B. Swap and Delete",
        "description": "You are given a binary string s (a string consisting only of 0-s and 1-s).\nYou can perform two types of operations on s: \nYou can perform these operations any number of times and in any order.\nLet's name a string you've got after performing operations above as t. The string t is good if for each i from 1 to |t| ti\u2260si (|t| is the length of the string t). The empty string is always good. Note that you are comparing the resulting string t with the initial string s.\nWhat is the minimum total cost to make the string t good?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then t test cases follow.\nThe only line of each test case contains a binary string s (1\u2264|s|\u22642\u22c5105; si\u2208{0, 1})\u00a0\u2014 the initial string, consisting of characters 0 and/or 1.\nAdditional constraint on the input: the total length of all strings s doesn't exceed 2\u22c5105.\nFor each test case, print one integer \u2014 the minimum total cost to make string t good.\nIn the first test case, you have to delete a character from s to get the empty string t. Only then t becomes good. One deletion costs 1 coin.\nIn the second test case, you can, for example, delete the second character from s to get the string 01, and then swap the first and second characters to get the string t = 10. String t is good, since t1\u2260s1 and t2\u2260s2. The total cost is 1 coin.\nIn the third test case, you can, for example, swap s1 with s2, swap s3 with s4, swap s5 with s7, s6 with s8 and s9 with s10. You'll get t = 1010001110. All swap operations are free, so the total cost is 0.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "strings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1910A": {
        "title": "A. Username",
        "description": "On the official website of Berland, each account has two parameters: username and ID.\nUsername is a string consisting of lowercase Latin letters and/or digits, which contains at least one letter. For example, user0, 1fox1, zzzz are correct usernames, but 1337 and User22 are not. \nThe ID of the account for a given username is generated as follows: a positive integer without leading zeroes is appended to the end of the username. For example, the ID user0125 can be generated by the following usernames: user012, user01, user0; but neither by user nor us.\nYou are given a string s\u00a0\u2014 a valid ID. Your task is to determine any valid username that can generate the given ID. If there are several correct usernames, you can print any of them.\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains a string s (2\u2264|s|\u226450), consisting of lowercase Latin letters and/or digits.\nAdditional constraint on input: there is at least one valid username that can generate the given ID.\nFor each test case on a separate line, print a string\u00a0\u2014 any valid username that can generate the given ID. If there are multiple correct usernames, you can print any of them.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "*special problem",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1909B": {
        "title": "B. Make Almost Equal With Mod",
        "description": "You are given an array a1,a2,\u2026,an of distinct positive integers. You have to do the following operation exactly once:\nFind a value of k such that 1\u2264k\u22641018 and the array a1,a2,\u2026,an contains exactly 2 distinct values at the end of the operation. It can be shown that, under the constraints of the problem, at least one such k always exists. If there are multiple solutions, you can print any of them.\n\u2020 a\u00a0mod\u00a0b denotes the remainder after dividing a by b. For example: \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264500). The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264100)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u22641017)\u00a0\u2014 the initial state of the array. It is guaranteed that all the ai are distinct.\nNote that there are no constraints on the sum of n over all test cases.\nFor each test case, output a single integer: a value of k (1\u2264k\u22641018) such that the array a1,a2,\u2026,an contains exactly 2 distinct values at the end of the operation.\nIn the first test case, you can choose k=7. The array becomes [8\u00a0mod\u00a07,15\u00a0mod\u00a07,22\u00a0mod\u00a07,30\u00a0mod\u00a07]=[1,1,1,2], which contains exactly 2 distinct values ({1,2}).\nIn the second test case, you can choose k=30. The array becomes [0,0,8,0,8], which contains exactly 2 distinct values ({0,8}). Note that choosing k=10 would also be a valid solution.\nIn the last test case, you can choose k=1018. The array becomes [2,1], which contains exactly 2 distinct values ({1,2}). Note that choosing k=1018+1 would not be valid, because 1\u2264k\u22641018 must be true.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "math",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1907C": {
        "title": "C. Removal of Unattractive Pairs",
        "description": "Vlad found a string s consisting of n lowercase Latin letters, and he wants to make it as short as possible.\nTo do this, he can remove any pair of adjacent characters from s any number of times, provided they are different. For example, if s=racoon, then by removing one pair of characters he can obtain the strings coon, roon, raon, and raco, but he cannot obtain racn (because the removed letters were the same) or rcon (because the removed letters were not adjacent).\nWhat is the minimum length Vlad can achieve by applying any number of deletions?\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Descriptions of the test cases follow.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the string s.\nThe second line of each test case contains the string s consisting of n lowercase Latin letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single number\u2014the minimum length of the string s, after removing pairs of adjacent characters with different values.\nIn the first test case of the example, you need to act as follows: \"aabc\" \u2192 \"ac\" \u2192 \"\". Note that with a different order of deletions, the string will not become empty.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1907B": {
        "title": "B. YetnotherrokenKeoard",
        "description": "Polycarp has a problem \u2014 his laptop keyboard is broken.\nNow, when he presses the 'b' key, it acts like an unusual backspace: it deletes the last (rightmost) lowercase letter in the typed string. If there are no lowercase letters in the typed string, then the press is completely ignored.\nSimilarly, when he presses the 'B' key, it deletes the last (rightmost) uppercase letter in the typed string. If there are no uppercase letters in the typed string, then the press is completely ignored.\nIn both cases, the letters 'b' and 'B' are not added to the typed string when these keys are pressed.\nConsider an example where the sequence of key presses was \"ARaBbbitBaby\". In this case, the typed string will change as follows: \"\" A\u2192 \"A\" R\u2192 \"AR\" a\u2192 \"ARa\" B\u2192 \"Aa\" b\u2192 \"A\" b\u2192 \"A\" i\u2192 \"Ai\" t\u2192 \"Ait\" B\u2192 \"it\" a\u2192 \"ita\" b\u2192 \"it\" y\u2192 \"ity\".\nGiven a sequence of pressed keys, output the typed string after processing all key presses.\nThe first line of the input data contains an integer t (1\u2264t\u22641000), the number of test cases in the test.\nThe following contains t non-empty lines, which consist of lowercase and uppercase letters of the Latin alphabet.\nIt is guaranteed that each line contains at least one letter and the sum of the lengths of the lines does not exceed 106.\nFor each test case, output the result of processing the key presses on a separate line. If the typed string is empty, then output an empty line.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "strings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1906A": {
        "title": "A. Easy As ABC",
        "description": "You are playing a word puzzle. The puzzle starts with a 3 by 3 grid, where each cell contains either the letter A, B, or C.\nThe goal of this puzzle is to find the lexicographically smallest possible word of length 3. The word can be formed by choosing three different cells where the cell containing the first letter is adjacent to the cell containing the second letter, and the cell containing the second letter is adjacent to the cell containing the third letter.\nTwo cells are adjacent to each other if they share a border or a corner, as shown in the following illustration. Formally, if (r,c) denotes the cell in the r-th row and c-th column, then cell (r,c) is adjacent to cell (r,c+1), (r\u22121,c+1), (r\u22121,c), (r\u22121,c\u22121), (r,c\u22121), (r+1,c\u22121), (r+1,c), and (r+1,c+1).\nDetermine the lexicographically smallest possible word of length 3 that you can find within the grid.\nA string s of length n is lexicographically smaller than string t of the same length if there exists an integer 1\u2264i\u2264n such that sj=tj for all 1\u2264j<i, and si<ti in alphabetical order. The following illustration shows some examples on some grids and their the lexicographically smallest possible word of length 3 that you can find within the grids.\nInput consists of three lines, each containing three letters, representing the puzzle grid. Each letter in the grid can only be either A, B, or C.\nOutput the lexicographically smallest possible word of length 3 that you can find within the grid.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test1024 megabytes",
        "tags": [
            "brute force",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1905B": {
        "title": "B. Begginer's Zelda",
        "description": "You are given a tree\u2020. In one zelda-operation you can do follows:\nDetermine the minimum number of zelda-operations required for the tree to have only one vertex.\n\u2020A tree is a connected acyclic undirected graph.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u2014 the number of vertices.\ni-th of the next n\u22121 lines contains two integers ui and vi (1\u2264ui,vi\u2264n,ui\u2260vi) \u2014 the numbers of vertices connected by the i-th edge.\nIt is guaranteed that the given edges form a tree.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single integer \u2014 the minimum number of zelda-operations required for the tree to have only one vertex.\nIn the first test case, it's enough to perform one zelda-operation for vertices 2 and 4.\nIn the second test case, we can perform the following zelda-operations:",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "trees",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1904B": {
        "title": "B. Collecting Game",
        "description": "You are given an array a of n positive integers and a score. If your score is greater than or equal to ai, then you can increase your score by ai and remove ai from the array. \nFor each index i, output the maximum number of additional array elements that you can remove if you remove ai and then set your score to ai. Note that the removal of ai should not be counted in the answer.\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u22645000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output n integers, the i-th of which denotes the maximum number of additional array elements that you can remove if you remove ai from the array and then set your score to ai.\nIn the first test case, the answers are as follows:\nIf we start with i=4, our initial score is a4=4 and a=[20,5,1,2]. We can remove 3 additional elements in the following order: \nIf we start with i=1 we can remove all remaining elements in the array, so the answer is 4.\nIf we start with i=2, we can remove 3 additional elements in the following order: 1, 4, 2.\nIf we start with i=3, we can remove no additional elements.\nIf we start with i=5, we can remove 1 additional element: 1.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "dp",
            "greedy",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1903B": {
        "title": "B. StORage room",
        "description": "In Cyprus, the weather is pretty hot. Thus, Theofanis saw this as an opportunity to create an ice cream company. \nHe keeps the ice cream safe from other ice cream producers by locking it inside big storage rooms. However, he forgot the password. Luckily, the lock has a special feature for forgetful people! \nIt gives you a table M with n rows and n columns of non-negative integers, and to open the lock, you need to find an array a of n elements such that:\nThe lock has a bug, and sometimes it gives tables without any solutions. In that case, the ice cream will remain frozen for the rest of eternity.\nCan you find an array to open the lock? \nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264103)\u00a0\u2014 the size of the hidden array.\nThe next n lines describe the rows of M, line i contains the table values Mi,1,Mi,2,\u2026,Mi,n (0\u2264Mi,j<230).\nIt is guaranteed that Mi,i=0 and Mi,j=Mj,i for all 1\u2264i,j\u2264n.\nIt is also guaranteed that the sum of n over all test cases does not exceed 103.\nFor each test case, if there is a solution print YES and an array that satisfies the property, otherwise print NO.\nIf there are multiple solutions, print any of them.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1902B": {
        "title": "B. Getting Points",
        "description": "Monocarp is a student at Berland State University. Due to recent changes in the Berland education system, Monocarp has to study only one subject\u00a0\u2014 programming.\nThe academic term consists of nn days, and in order not to get expelled, Monocarp has to earn at least P points during those n days. There are two ways to earn points\u00a0\u2014 completing practical tasks and attending lessons. For each practical task Monocarp fulfills, he earns t points, and for each lesson he attends, he earns l points.\nPractical tasks are unlocked \"each week\" as the term goes on: the first task is unlocked on day 1 (and can be completed on any day from 1 to n), the second task is unlocked on day 8 (and can be completed on any day from 8 to n), the third task is unlocked on day 15, and so on.\nEvery day from 1 to n, there is a lesson which can be attended by Monocarp. And every day, Monocarp chooses whether to study or to rest the whole day. When Monocarp decides to study, he attends a lesson and can complete no more than 2 tasks, which are already unlocked and not completed yet. If Monocarp rests the whole day, he skips a lesson and ignores tasks.\nMonocarp wants to have as many days off as possible, i.\u00a0e. he wants to maximize the number of days he rests. Help him calculate the maximum number of days he can rest!\nThe first line contains a single integer tc (1\u2264tc\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains four integers n, P, l and t (1\u2264n,l,t\u2264109; 1\u2264P\u22641018)\u00a0\u2014 the number of days, the minimum total points Monocarp has to earn, the points for attending one lesson and points for completing one task.\nIt's guaranteed for each test case that it's possible not to be expelled if Monocarp will attend all lessons and will complete all tasks.\nFor each test, print one integer\u00a0\u2014 the maximum number of days Monocarp can rest without being expelled from University.\nIn the first test case, the term lasts for 1 day, so Monocarp should attend at day 1. Since attending one lesson already gives 5 points (5\u2265P), so it doesn't matter, will Monocarp complete the task or not.\nIn the second test case, Monocarp can, for example, study at days 8 and 9: at day 8 he will attend a lesson for 109 points and complete two tasks for another 5\u22c5108+5\u22c5108 points. And at day 9 he only attends a lesson for another 109 points.\nIn the third test case, Monocarp can, for example, study at day 42: attending a lesson gives him 1 point and solving 2 out of 6 available tasks gives him another 2\u22c510 points.\nIn the fourth test case, Monocarp has to attend all lessons and complete all tasks to get 8\u22c510+2\u22c520=120 points.\nIn the fifth test case, Monocarp can, for example, study at days: 8\u00a0\u2014 one lesson and first and second tasks; 15\u00a0\u2014 one lesson and the third task; 22\u00a0\u2014 one lesson and the fourth task; 29\u00a0\u2014 one lesson and the fifth task; 36\u00a0\u2014 one lesson and the sixth task.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1901B": {
        "title": "B. Chip and Ribbon",
        "description": "There is a ribbon divided into n cells, numbered from 1 to n from left to right. Initially, an integer 0 is written in each cell.\nMonocarp plays a game with a chip. The game consists of several turns. During the first turn, Monocarp places the chip in the 1-st cell of the ribbon. During each turn except for the first turn, Monocarp does exactly one of the two following actions:\nAt the end of each turn, the integer written in the cell with the chip is increased by 1.\nMonocarp's goal is to make some turns so that the 1-st cell contains the integer c1, the 2-nd cell contains the integer c2, ..., the n-th cell contains the integer cn. He wants to teleport the chip as few times as possible.\nHelp Monocarp calculate the minimum number of times he has to teleport the chip. \nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of two lines: \nIt can be shown that under these constraints, it is always possible to make a finite amount of turns so that the integers in the cells match the sequence c1,c2,\u2026,cn.\nAdditional constraint on the input: the sum of values of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print one integer \u2014 the minimum number of times Monocarp has to teleport the chip.\nIn the first test case of the example, Monocarp can perform the turns as follows:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1899C": {
        "title": "C. Yarik and Array",
        "description": "A subarray is a continuous part of array.\nYarik recently found an array a of n elements and became very interested in finding the maximum sum of a non empty subarray. However, Yarik doesn't like consecutive integers with the same parity, so the subarray he chooses must have alternating parities for adjacent elements.\nFor example, [1,2,3] is acceptable, but [1,2,4] is not, as 2 and 4 are both even and adjacent.\nYou need to help Yarik by finding the maximum sum of such a subarray.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 number of test cases. Each test case is described as follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212103\u2264ai\u2264103)\u00a0\u2014 elements of the array.\nIt is guaranteed that the sum of n for all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the answer to the problem.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1899B": {
        "title": "B. 250 Thousand Tons of TNT",
        "description": "Alex is participating in the filming of another video of BrMeast, and BrMeast asked Alex to prepare 250 thousand tons of TNT, but Alex didn't hear him well, so he prepared n boxes and arranged them in a row waiting for trucks. The i-th box from the left weighs ai tons.\nAll trucks that Alex is going to use hold the same number of boxes, denoted by k. Loading happens the following way:\nUpon loading is completed, each truck must have exactly k boxes. In other words, if at some point it is not possible to load exactly k boxes into the truck, then the loading option with that k is not possible.\nAlex hates justice, so he wants the maximum absolute difference between the total weights of two trucks to be as great as possible. If there is only one truck, this value is 0.\nAlex has quite a lot of connections, so for every 1\u2264k\u2264n, he can find a company such that each of its trucks can hold exactly k boxes. Print the maximum absolute difference between the total weights of any two trucks.\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains one integer n (1\u2264n\u2264150000)\u00a0\u2014 the number of boxes.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the weights of the boxes.\nIt is guaranteed that the sum of n for all test cases does not exceed 150000.\nFor each test case, print a single integer\u00a0\u2014 the answer to the problem.\nIn the first case, we should pick two trucks, so the first one will have only the first box, and the second one will have only the second box.\nIn the second case, we should pick six trucks, so the maximum will be 10, the minimum will be 1, and the answer is 10\u22121=9.\nIn the third case, for any possible k, the trucks will have the same total weight of boxes, so the answer is 0.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1894B": {
        "title": "B. Two Out of Three",
        "description": "You are given an array a1,a2,\u2026,an. You need to find an array b1,b2,\u2026,bn consisting of numbers 1, 2, 3 such that exactly two out of the following three conditions are satisfied:\nIf such an array does not exist, you should report it.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases. Each test case is described as follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264100)\u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264100)\u00a0\u2014 the elements of the array a.\nFor each test case, print -1 if there is no solution. Otherwise, print b1,b2,\u2026,bn\u00a0\u2014 an array consisting of numbers 1, 2, 3 that satisfies exactly two out of three conditions. If there are multiple possible answers, you can print any of them.\nIn the first test case, b=[1,2,3,1,1,1] satisfies condition 1 because for i=4, j=2: ai=aj, bi=1, and bj=2. It also satisfies condition 2 because for i=6, j=3: ai=aj, bi=1, and bj=3. However, it does not satisfy condition 3. In total, exactly two out of three conditions are satisfied.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1891B": {
        "title": "B. Deja Vu",
        "description": "You are given an array a of length n, consisting of positive integers, and an array x of length q, also consisting of positive integers.\nThere are q modification. On the i-th modification (1\u2264i\u2264q), for each j (1\u2264j\u2264n), such that aj is divisible by 2xi, you add 2xi\u22121 to aj. Note that xi (1\u2264xi\u226430) is a positive integer not exceeding 30.\nAfter all modification queries, you need to output the final array.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and q (1\u2264n,q\u2264105) \u2014the length of the array a and the number of queries respectively.\nThe second line of each test case contains n integers a1,a2,a3,\u2026,an \u2014 the elements of the array a (1\u2264ai\u2264109).\nThe third line of each test case contains q integers x1,x2,x3,\u2026,xq \u2014 the elements of the array x (1\u2264xi\u226430), which are the modification queries.\nIt is guaranteed that the sum of n and the sum of q across all test cases does not exceed 2\u22c5105.\nFor each test case, output the array after all of the modification queries.\nIn the first test case, the first query will add 2 to the integers in positions 4 and 5. After this addition, the array would be [1,2,3,6,6]. Other operations will not modify the array.\nIn the second test case, the first modification query does not change the array. The second modification query will add 8 to the integer in position 5, so that the array would look like this: [7,8,12,36,56,6,3]. The third modification query will add 2 to the integers in positions 2,3, 4 and 5. The array would then look like this: [7,10,14,38,58,6,3].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1886B": {
        "title": "B. Fear of the Dark",
        "description": "Monocarp tries to get home from work. He is currently at the point O=(0,0) of a two-dimensional plane; his house is at the point P=(Px,Py).\nUnfortunately, it is late in the evening, so it is very dark. Monocarp is afraid of the darkness. He would like to go home along a path illuminated by something.\nThankfully, there are two lanterns, located in the points A=(Ax,Ay) and B=(Bx,By). You can choose any non-negative number w and set the power of both lanterns to w. If a lantern's power is set to w, it illuminates a circle of radius w centered at the lantern location (including the borders of the circle).\nYou have to choose the minimum non-negative value w for the power of the lanterns in such a way that there is a path from the point O to the point P which is completely illuminated. You may assume that the lanterns don't interfere with Monocarp's movement.\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of three lines:\nAdditional constraint on the input:\nFor each test case, print the answer on a separate line \u2014 one real number equal to the minimum value of w such that there is a completely illuminated path from the point O to the point P.\nYour answer will be considered correct if its absolute or relative error does not exceed 10\u22126 \u2014 formally, if your answer is a, and the jury's answer is b, your answer will be accepted if |a\u2212b|max(1,b)\u226410\u22126.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "geometry",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1884B": {
        "title": "B. Haunted House",
        "description": "You are given a number in binary representation consisting of exactly n bits, possibly, with leading zeroes. For example, for n=5 the number 6 will be given as 00110, and for n=4 the number 9 will be given as 1001.\nLet's fix some integer i such that 1\u2264i\u2264n. In one operation you can swap any two adjacent bits in the binary representation. Your goal is to find the smallest number of operations you are required to perform to make the number divisible by 2i, or say that it is impossible.\nPlease note that for each 1\u2264i\u2264n you are solving the problem independently.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains one integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the binary representation of the number.\nThe second line of each test case contains a string of length n, consisting of 0 and 1,\u00a0\u2014 the binary representation of the number.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, for each 1\u2264i\u2264n output the smallest number of operations required to make the number divisible by 2i, or output \u22121 if it is impossible.\nIn the first test case, we cannot swap any elements, and the number 1 is not divisible by 2.\nIn the second test case, the initial number is 1. It is not divisible by 2, but if we perform the operation, then we obtain the number with binary representation 10, which is equal to 2 in decimal representation, thus, it is divisible by 2. But this number is not divisible by 4 and we cannot obtain any other number using the operations.\nIn the third test case, the initial number is 2. For i=1 we do not have to perform any operations since the initial number is divisible by 2. For i=2 we can perform one operation swapping the first two bits (we would obtain 100 in binary representation, which corresponds to number 4). There is no answer for i=3.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1883C": {
        "title": "C. Raspberries",
        "description": "You are given an array of integers a1,a2,\u2026,an and a number k (2\u2264k\u22645). In one operation, you can do the following:\nFind the minimum number of operations needed to make the product of all the numbers in the array a1\u22c5a2\u22c5\u2026\u22c5an divisible by k.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then follows the description of the test cases.\nThe first line of each test case contains two integers n and k (2\u2264n\u2264105, 2\u2264k\u22645) \u2014 the size of the array a and the number k.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u226410).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the minimum number of operations needed to make the product of all the numbers in the array divisible by k.\nIn the first test case, we need to choose the index i=2 twice. After that, the array will be a=[7,5]. The product of all the numbers in the array is 35.\nIn the fourth test case, the product of the numbers in the array is 120, which is already divisible by 5, so no operations are needed.\nIn the eighth test case, we can perform two operations by choosing i=2 and i=3 in any order. After that, the array will be a=[1,6,10]. The product of the numbers in the array is 60.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1881C": {
        "title": "C. Perfect Square",
        "description": "Kristina has a matrix of size n by n, filled with lowercase Latin letters. The value of n is even.\nShe wants to change some characters so that her matrix becomes a perfect square. A matrix is called a perfect square if it remains unchanged when rotated 90\u2218 clockwise once.\nHere is an example of rotating a matrix by 90\u2218:\nIn one operation, Kristina can choose any cell and replace its value with the next character in the alphabet. If the character is equal to \"z\", its value does not change.\nFind the minimum number of operations required to make the matrix a perfect square.\nFor example, if the 4 by 4 matrix looks like this:\nabbabcbbbccbabba\nthen it is enough to apply 1 operation to the letter b, highlighted in bold.\nThe first line of the input contains a single integer t (1\u2264t\u2264102)\u00a0\u2014 the number of test cases.\nThen follows the description of each test case.\nThe first line of each test case contains a single even integer n (2\u2264n\u2264103)\u00a0\u2014 the number of rows and columns in the matrix.\nThen follows n lines, each containing exactly n lowercase Latin letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 103.\nFor each test case, output a single number on a separate line: the minimum number of operations required for Kristina to obtain a perfect square.\nThe first test case is explained in the problem statement.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1877C": {
        "title": "C. Joyboard",
        "description": "Chaneka, a gamer kid, invented a new gaming controller called joyboard. Interestingly, the joyboard she invented can only be used to play one game.\nThe joyboard has a screen containing n+1 slots numbered from 1 to n+1 from left to right. The n+1 slots are going to be filled with an array of non-negative integers [a1,a2,a3,\u2026,an+1]. Chaneka, as the player, must assign an+1 with an integer between 0 and m inclusive. Then, for each i from n to 1, the value of ai will be equal to the remainder of dividing ai+1 (the adjacent value to the right) by i. In other words, ai=ai+1modi.\nChaneka wants it such that after every slot is assigned with an integer, there are exactly k distinct values in the entire screen (among all n+1 slots). How many valid ways are there for assigning a non-negative integer into slot n+1?\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. The following lines contain the description of each test case.\nThe only line of each test case contains three integers n, m, and k (1\u2264n\u2264109; 0\u2264m\u2264109; 1\u2264k\u2264n+1) \u2014 there are n+1 slots, the integer assigned in slot n+1 must not be bigger than m, and there should be exactly k distinct values.\nFor each test case, output a line containing an integer representing the number of valid ways for assigning a non-negative integer into slot n+1.\nIn the first test case, one of the 2 possible ways for Chaneka is to choose an+1=6. If she does that, then: \nIn the second test case, the 1 possible way for Chaneka is to choose an+1=0. If she does that, then a=[0,0,0]. There is only 1 distinct value.\nIn the third test case, there is no possible way for assigning a non-negative integer into slot n+1.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1876A": {
        "title": "A. Helmets in Night Light",
        "description": "Pak Chanek is the chief of a village named Khuntien. On one night filled with lights, Pak Chanek has a sudden and important announcement that needs to be notified to all of the n residents in Khuntien.\nFirst, Pak Chanek shares the announcement directly to one or more residents with a cost of p for each person. After that, the residents can share the announcement to other residents using a magical helmet-shaped device. However, there is a cost for using the helmet-shaped device. For each i, if the i-th resident has got the announcement at least once (either directly from Pak Chanek or from another resident), he/she can share the announcement to at most ai other residents with a cost of bi for each share.\nIf Pak Chanek can also control how the residents share the announcement to other residents, what is the minimum cost for Pak Chanek to notify all n residents of Khuntien about the announcement?\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases. The following lines contain the description of each test case.\nThe first line contains two integers n and p (1\u2264n\u2264105; 1\u2264p\u2264105) \u2014 the number of residents and the cost for Pak Chanek to share the announcement directly to one resident.\nThe second line contains n integers a1,a2,a3,\u2026,an (1\u2264ai\u2264105) \u2014 the maximum number of residents that each resident can share the announcement to.\nThe third line contains n integers b1,b2,b3,\u2026,bn (1\u2264bi\u2264105) \u2014 the cost for each resident to share the announcement to one other resident.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a line containing an integer representing the minimum cost to notify all n residents of Khuntien about the announcement.\nIn the first test case, the following is a possible optimal strategy: \nThe total cost is 9+4+3=16. It can be shown that there is no other strategy with a smaller cost.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1874A": {
        "title": "A. Jellyfish and Game",
        "description": "Jellyfish has n green apples with values a1,a2,\u2026,an and Gellyfish has m green apples with values b1,b2,\u2026,bm.\nThey will play a game with k rounds. For i=1,2,\u2026,k in this order, they will perform the following actions: \nBoth players want to maximize the sum of the values of their apples.\nSince you are one of the smartest people in the world, Jellyfish wants you to tell her the final sum of the value of her apples after all k rounds of the game. Assume that both Jellyfish and Gellyfish play optimally to maximize the sum of values of their apples.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22642000). The description of the test cases follows.\nThe first line of each test case contains three integers, n, m and k (1\u2264n,m\u226450, 1\u2264k\u2264109)\u00a0\u2014 the number of green apples Jellyfish has, the number of green apples Gellyfish has and the number of rounds of the game respectively.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the values of Jellyfish's green apples.\nThe third line of each test case contains m integers b1,b2,\u2026,bm (1\u2264bi\u2264109)\u00a0\u2014 the values of Gellyfish's green apples.\nDo note that the sum of n and m over all test cases are both not bounded.\nFor each test case, output a single integer\u00a0\u2014 the final sum of the values of Jellyfish's apples.\nIn the first test case, Jellyfish will swap the apple of value 1 and 4.\nIn the second test case, both players will swap the two apples 10,000 times.\nIn the fourth test case, Jellyfish will do nothing.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "games",
            "greedy",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1873E": {
        "title": "E. Building an Aquarium",
        "description": "You love fish, that's why you have decided to build an aquarium. You have a piece of coral made of n columns, the i-th of which is ai units tall. Afterwards, you will build a tank around the coral as follows: \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two positive integers n and x (1\u2264n\u22642\u22c5105; 1\u2264x\u2264109)\u00a0\u2014 the number of columns of the coral and the maximum amount of water you can use.\nThe second line of each test case contains n space-separated integers ai (1\u2264ai\u2264109)\u00a0\u2014 the heights of the coral.\nThe sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output a single positive integer h (h\u22651)\u00a0\u2014 the maximum height the tank can have, so you need at most x units of water to fill up the tank.\nWe have a proof that under these constraints, such a value of h always exists.\nThe first test case is pictured in the statement. With h=4 we need 8 units of water, but if h is increased to 5 we need 13 units of water, which is more than x=9. So h=4 is optimal.\nIn the second test case, we can pick h=4 and add 3 units to each column, using a total of 9 units of water. It can be shown that this is optimal.\nIn the third test case, we can pick h=2 and use all of our water, so it is optimal.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1872D": {
        "title": "D. Plus Minus Permutation",
        "description": "You are given 3 integers\u00a0\u2014 n, x, y. Let's call the score of a permutation\u2020 p1,\u2026,pn the following value:\n(p1\u22c5x+p2\u22c5x+\u2026+p\u230anx\u230b\u22c5x)\u2212(p1\u22c5y+p2\u22c5y+\u2026+p\u230any\u230b\u22c5y)\nIn other words, the score of a permutation is the sum of pi for all indices i divisible by x, minus the sum of pi for all indices i divisible by y.\nYou need to find the maximum possible score among all permutations of length n.\nFor example, if n=7, x=2, y=3, the maximum score is achieved by the permutation [2,6_,1_,7_,5,4__,3] and is equal to (6+7+4)\u2212(1+4)=17\u22125=12.\n\u2020 A permutation of length n is an array consisting of n distinct integers from 1 to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (the number 2 appears twice in the array) and [1,3,4] is also not a permutation (n=3, but the array contains 4).\nThe first line of input contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThen follows the description of each test case.\nThe only line of each test case description contains 3 integers n, x, y (1\u2264n\u2264109, 1\u2264x,y\u2264n).\nFor each test case, output a single integer\u00a0\u2014 the maximum score among all permutations of length n.\nThe first test case is explained in the problem statement above.\nIn the second test case, one of the optimal permutations will be [12,11,2_,4,8,9__,10,6,1_,5,3,7__]. The score of this permutation is (9+7)\u2212(2+9+1+7)=\u22123. It can be shown that a score greater than \u22123 can not be achieved. Note that the answer to the problem can be negative.\nIn the third test case, the score of the permutation will be (p1+p2+\u2026+p9)\u2212p9. One of the optimal permutations for this case is [9,8,7,6,5,4,3,2,1], and its score is 44. It can be shown that a score greater than 44 can not be achieved.\nIn the fourth test case, x=y, so the score of any permutation will be 0.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1872C": {
        "title": "C. Non-coprime Split",
        "description": "You are given two integers l\u2264r. You need to find positive integers a and b such that the following conditions are simultaneously satisfied:\nor report that they do not exist.\ngcd(a,b) denotes the greatest common divisor of numbers a and b. For example, gcd(6,9)=3, gcd(8,9)=1, gcd(4,2)=2.\nThe first line of the input contains an integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases.\nThen the descriptions of the test cases follow.\nThe only line of the description of each test case contains 2 integers l,r (1\u2264l\u2264r\u2264107).\nFor each test case, output the integers a,b that satisfy all the conditions on a separate line. If there is no answer, instead output a single number \u22121.\nIf there are multiple answers, you can output any of them.\nIn the first test case, 11\u22646+9\u226415, gcd(6,9)=3, and all conditions are satisfied. Note that this is not the only possible answer, for example, {4,10},{5,10},{6,6} are also valid answers for this test case.\nIn the second test case, the only pairs {a,b} that satisfy the condition 1\u2264a+b\u22643 are {1,1},{1,2},{2,1}, but in each of these pairs gcd(a,b) equals 1, so there is no answer.\nIn the third sample test, gcd(14,4)=2.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1870B": {
        "title": "B. Friendly Arrays",
        "description": "You are given two arrays of integers \u2014 a1,\u2026,ana1,\u2026,an of length n, and b1,\u2026,bm of length m. You can choose any element bj from array b (1\u2264j\u2264m), and for all 1\u2264i\u2264n perform ai=ai|bj. You can perform any number of such operations.\nAfter all the operations, the value of x=a1\u2295a2\u2295\u2026\u2295an will be calculated. Find the minimum and maximum values of x that could be obtained after performing any set of operations.\nAbove, | is the bitwise OR operation, and \u2295 is the bitwise XOR operation.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. This is followed by the description of the test cases.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u22642\u22c5105) \u2014 the sizes of arrays a and b.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109) \u2014 the array a.\nThe third line of each test case contains m integers b1,b2,\u2026,bm (0\u2264bi\u2264109) \u2014 the array b.\nIt is guaranteed that the sum of values of n and m across all test cases does not exceed 2\u22c5105.\nFor each test case, output 2 numbers: the minimum and maximum possible values of x after performing any set of operations.\nIn the first test case, if we apply the operation with element b1=1, the array a will become [1,1], and x will be 0. If no operations are applied, then x=1.\nIn the second test case, if no operations are applied, then x=2. If we apply the operation with b1=1, then a=[1,1,3], and x=3.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1869B": {
        "title": "B. 2D Traveling",
        "description": "Piggy lives on an infinite plane with the Cartesian coordinate system on it.\nThere are n cities on the plane, numbered from 1 to n, and the first k cities are defined as major cities. The coordinates of the i-th city are (xi,yi).\nPiggy, as a well-experienced traveller, wants to have a relaxing trip after Zhongkao examination. Currently, he is in city a, and he wants to travel to city b by air. You can fly between any two cities, and you can visit several cities in any order while travelling, but the final destination must be city b.\nBecause of active trade between major cities, it's possible to travel by plane between them for free. Formally, the price of an air ticket f(i,j) between two cities i and j is defined as follows:\nf(i,j)={0,if cities\u00a0i\u00a0and\u00a0j\u00a0are both major cities|xi\u2212xj|+|yi\u2212yj|,otherwise\nPiggy doesn't want to save time, but he wants to save money. So you need to tell him the minimum value of the total cost of all air tickets if he can take any number of flights.\nThe first line of input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains four integers n, k, a and b (2\u2264n\u22642\u22c5105, 0\u2264k\u2264n, 1\u2264a,b\u2264n, a\u2260b) \u2014 the number of cities, the number of major cities and the numbers of the starting and the ending cities.\nThen n lines follow, the i-th line contains two integers xi and yi (\u2212109\u2264xi,yi\u2264109) \u2014 the coordinates of the i-th city. The first k lines describe major cities. It is guaranteed that all coordinates are pairwise distinct.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer \u2014 the minimum value of the total price of all air tickets.\nIn the first test case:\nThe optimal way to choose the flights is: 3\u21921\u21922\u21925, which will cost 3+0+1=4. Note that the flight 1\u21922 costs 0, because both city 1 and 2 are major cities.\nIn the second test case, since there are only 2 cities, the only way is to take a flight from city 1 to 2.\nIn the third test case, since city 2 and 4 are both major cities, Piggy can directly take a flight from city 2 to 4, which costs 0.\nIn the fourth test case, Piggy can choose to take the following flights: 3\u21922\u21921, and the cost is 11+11=22.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "geometry",
            "math",
            "shortest paths",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1867B": {
        "title": "B. XOR Palindromes",
        "description": "You are given a binary string ss of length n (a string that consists only of 0 and 1). A number x is good if there exists a binary string l of length n, containing x ones, such that if each symbol si is replaced by si\u2295li (where \u2295 denotes the bitwise XOR operation), then the string s becomes a palindrome.\nYou need to output a binary string t of length n+1, where ti (0\u2264i\u2264n) is equal to 1 if number i is good, and 0 otherwise.\nA palindrome is a string that reads the same from left to right as from right to left. For example, 01010, 1111, 0110 are palindromes.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264105). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105).\nThe second line of each test case contains a binary string s of length n.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single line containing a binary string t of length n+1 - the answer to the problem.\nConsider the first example. ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1864B": {
        "title": "B. Swap and Reverse",
        "description": "You are given a string s of length n consisting of lowercase English letters, and an integer k. In one step you can perform any one of the two operations below:\nYou can make as many steps as you want (possibly, zero). Your task is to find the lexicographically smallest string you can obtain after some number of steps. \nA string a is lexicographically smaller than a string b of the same length if and only if the following holds: \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k<n\u2264105).\nThe second line of each test case contains the string s of length n consisting of lowercase English letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print the lexicographically smallest string after doing some (possibly, zero) steps.\nIn the first test case, we can obtain the string \"aimn\" using the following operations:\nIt can be proven that we cannot obtain any string lexicographically smaller than \"aimn\". Therefore, \"aimn\" is the answer.\nIn the second test case, we can obtain the string \"aandp\" using the following operations:\nIt can be proven that we cannot obtain any string lexicographically smaller than \"aandp\". Therefore, \"aandp\" is the answer.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1863C": {
        "title": "C. MEX Repetition",
        "description": "You are given an array a1,a2,\u2026,an of pairwise distinct integers from 0 to n. Consider the following operation:\nHere MEX of a collection of integers c1,c2,\u2026,cm is defined as the smallest non-negative integer x which does not occur in the collection c. For example, MEX(0,2,2,1,4)=3 and MEX(1,2)=0.\nPrint the array after applying k such operations.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264105). The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264n\u2264105, 1\u2264k\u2264109).\nThe second line contains n pairwise distinct integers a1,a2,\u2026,an (0\u2264ai\u2264n) representing the elements of the array before applying the operations.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print all n elements of the array after applying k operations.\nIn the first test case, here is the entire process:\nThus, the array becomes [1] after two operations.\nIn the second test case, the array changes as follows during one operation: [0_,1,3]\u2192[2,1_,3]\u2192[2,0,3_]\u2192[2,0,1].\nIn the third test case, the array changes as follows during one operation: [0_,2]\u2192[1,2_]\u2192[1,0]. And during the second operation: [1_,0]\u2192[2,0_]\u2192[2,1].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1863B": {
        "title": "B. Split Sort",
        "description": "You are given a permutation\u2020 p1,p2,\u2026,pn of integers 1 to n.\nYou can change the current permutation by applying the following operation several (possibly, zero) times:\nFor example, if the permutation used to be [6,4,3,5,2,1] and you choose x=4, then you will first write down [3,2,1], then append this with [6,4,5]. So the initial permutation will be replaced by [3,2,1,6,4,5].\nFind the minimum number of operations you need to achieve pi=i for i=1,2,\u2026,n. We can show that it is always possible to do so.\n\u2020 A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). The description of the test cases follows.\nThe first line of each test case contains one integer n (1\u2264n\u2264100000).\nThe second line of each test case contains n integers p1,p2,\u2026,pn (1\u2264pi\u2264n). It is guaranteed that p1,p2,\u2026,pn is a permutation.\nIt is guaranteed that the sum of n over all test cases does not exceed 100000.\nFor each test case, output the answer on a separate line.\nIn the first test case, n=1 and p1=1, so there is nothing left to do.\nIn the second test case, we can choose x=2 and we immediately obtain p1=1, p2=2.\nIn the third test case, we can achieve the minimum number of operations in the following way:",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1862C": {
        "title": "C. Flower City Fence",
        "description": "Anya lives in the Flower City. By order of the city mayor, she has to build a fence for herself.\nThe fence consists of n planks, each with a height of ai meters. According to the order, the heights of the planks must not increase. In other words, it is true that ai\u2265aj for all i<j.\nAnya became curious whether her fence is symmetrical with respect to the diagonal. In other words, will she get the same fence if she lays all the planks horizontally in the same order.\nFor example, for n=5, a=[5,4,3,2,1], the fence is symmetrical. Because if all the planks are laid horizontally, the fence will be [5,4,3,2,1], as shown in the diagram.\n On the left is the fence [5,4,3,2,1], on the right is the same fence laid horizontally \nBut for n=3, a=[4,2,1], the fence is not symmetrical. Because if all the planks are laid horizontally, the fence will be [3,2,1,1], as shown in the diagram.\n On the left is the fence [4,2,1], on the right is the same fence laid horizontally \nHelp Anya and determine whether her fence is symmetrical.\nThe first line of the input contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. \nThe description of the test cases follows.\nThe first line of a test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the fence.\nThe second line of a test case contains n integers a1\u2265a2\u2265a3\u2265\u22ef\u2265an (1\u2264ai\u2264109)\u00a0\u2014 the heights of the planks.\nThe sum of the values of n for all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" if the fence is symmetrical, otherwise output \"NO\".\nYou can output each letter in any case (lowercase or uppercase). For example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be accepted as a positive answer.\nIn the first and second test cases of the example, the fence is symmetrical.\nIn the third test case of the example, the fence is not symmetrical. If the planks are laid horizontally, the fence will be [3,2,1,1].\nIn the fourth test case of the example, the fence is not symmetrical. If the planks are laid horizontally, the fence will be [1,1].\nIn the fifth and sixth test cases of the example, the fence is symmetrical.\nIn the seventh test case of the example, the fence is not symmetrical. If the planks are laid horizontally, the fence will be [2,1,1,1,1,1].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "implementation",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1861B": {
        "title": "B. Two Binary Strings",
        "description": "You are given two strings a and b of equal length, consisting of only characters 0 and/or 1; both strings start with character 0 and end with character 1. \nYou can perform the following operation any number of times (possibly zero): \nFormally, you choose one of these two strings (let the chosen string be s), then pick two integers l and r such that 1\u2264l<r\u2264|s| and sl=sr, then replace every character si such that l<i<r with sl.\nFor example, if the chosen string is 010101, you can transform it into one of the following strings by applying one operation:\nYou have to determine if it's possible to make the given strings equal by applying this operation any number of times.\nThe first line contains a single integer t (1\u2264t\u22642000) \u00a0\u2014 the number of test cases.\nEach test case consists of two lines: \nAdditional constraints on the input: \nFor each test case, print YES if it is possible to make the strings equal. Otherwise, print NO. You can print each letter in any register.\nIn the first test case, we can perform the following operations: \nIn the second test case, the strings are already equal.\nIn the third test case, we can perform the following operations: \nIn the fourth and fifth test cases, it's impossible to make the given strings equal.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1860B": {
        "title": "B. Fancy Coins",
        "description": "Monocarp is going to make a purchase with cost of exactly m burles.\nHe has two types of coins, in the following quantities: \nMonocarp wants to make his purchase in such a way that there's no change\u00a0\u2014 the total worth of provided coins is exactly m. He can use both regular and fancy coins. However, he wants to spend as little fancy coins as possible.\nWhat's the smallest total number of fancy coins he can use to make a purchase?\nThe first line contains a single integer t (1\u2264t\u22643\u22c5104)\u00a0\u2014 the number of testcases.\nThe only line of each testcase contains four integers m,k,a1 and ak (1\u2264m\u2264108; 2\u2264k\u2264108; 0\u2264a1,ak\u2264108)\u00a0\u2014 the cost of the purchase, the worth of the second type of coin and the amounts of regular coins of both types, respectively.\nFor each testcase, print a single integer\u00a0\u2014 the smallest total number of fancy coins Monocarp can use to make a purchase.\nIn the first testcase, there are no regular coins of either type. Monocarp can use 2 fancy coins worth 1 burle and 3 fancy coins worth 3 (since k=3) burles to get 11 total burles with 5 total fancy coins.\nIn the second testcase, Monocarp has a lot of regular coins of both types. He can use 11 regular coins worth 1 burle, for example. Notice that Monocarp doesn't have to minimize the total number of used coins. That way he uses 0 fancy coins.\nIn the third testcase, Monocarp can use 5 regular coins worth 1 burle and 1 regular coin worth 3 burles. That will get him to 8 total burles when he needs 11. So, 1 fancy coin worth 3 burles is enough.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1859C": {
        "title": "C. Another Permutation Problem",
        "description": "Andrey is just starting to come up with problems, and it's difficult for him. That's why he came up with a strange problem about permutations\u2020 and asks you to solve it. Can you do it?\nLet's call the cost of a permutation p of length n the value of the expression:\nFind the maximum cost among all permutations of length n.\n\u2020A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u226430) \u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains a single integer n (2\u2264n\u2264250) \u2014 the length of the permutation.\nIt is guaranteed that the sum of n over all test cases does not exceed 500.\nFor each test case, output a single integer \u2014 the maximum cost among all permutations of length n.\nIn the first test case, the permutation with the maximum cost is [2,1]. The cost is equal to 2\u22c51+1\u22c52\u2212max(2\u22c51,1\u22c52)=2+2\u22122=2.\nIn the second test case, the permutation with the maximum cost is [1,2,4,3]. The cost is equal to 1\u22c51+2\u22c52+4\u22c53+3\u22c54\u22124\u22c53=17.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1859B": {
        "title": "B. Olya and Game with Arrays",
        "description": "Artem suggested a game to the girl Olya. There is a list of n arrays, where the i-th array contains mi\u22652 positive integers ai,1,ai,2,\u2026,ai,mi.\nOlya can move at most one (possibly 0) integer from each array to another array. Note that integers can be moved from one array only once, but integers can be added to one array multiple times, and all the movements are done at the same time.\nThe beauty of the list of arrays is defined as the sum \u2211ni=1minmij=1ai,j. In other words, for each array, we find the minimum value in it and then sum up these values.\nThe goal of the game is to maximize the beauty of the list of arrays. Help Olya win this challenging game!\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u226425000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u226425000) \u2014 the number of arrays in the list.\nThis is followed by descriptions of the arrays. Each array description consists of two lines.\nThe first line contains a single integer mi (2\u2264mi\u226450000) \u2014 the number of elements in the i-th array.\nThe next line contains mi integers ai,1,ai,2,\u2026,ai,mi (1\u2264ai,j\u2264109) \u2014 the elements of the i-th array.\nIt is guaranteed that the sum of mi over all test cases does not exceed 50000.\nFor each test case, output a single line containing a single integer \u2014 the maximum beauty of the list of arrays that Olya can achieve.\nIn the first test case, we can move the integer 3 from the second array to the first array. Then the beauty is min(1,2,3)+min(4)=5. It can be shown that this is the maximum possible beauty.\nIn the second test case, there is only one array, so regardless of the movements, the beauty will be min(100,1,6)=1.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1858C": {
        "title": "C. Yet Another Permutation Problem",
        "description": "Alex got a new game called \"GCD permutations\" as a birthday present. Each round of this game proceeds as follows:\nAlex has already played several rounds so he decided to find a permutation a1,a2,\u2026,an such that its score is as large as possible.\nRecall that gcd(x,y) denotes the greatest common divisor (GCD) of numbers x and y, and xmody denotes the remainder of dividing x by y.\n\u2020A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nEach test case consists of one line containing a single integer n (2\u2264n\u2264105).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print n distinct integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 the permutation with the largest possible score.\nIf there are several permutations with the maximum possible score, you can print any one of them.\nIn the first test case, Alex wants to find a permutation of integers from 1 to 5. For the permutation a=[1,2,4,3,5], the array d is equal to [1,2,1,1,1]. It contains 2 distinct integers. It can be shown that there is no permutation of length 5 with a higher score.\nIn the second test case, Alex wants to find a permutation of integers from 1 to 2. There are only two such permutations: a=[1,2] and a=[2,1]. In both cases, the array d is equal to [1,1], so both permutations are correct.\nIn the third test case, Alex wants to find a permutation of integers from 1 to 7. For the permutation a=[1,2,3,6,4,5,7], the array d is equal to [1,1,3,2,1,1,1]. It contains 3 distinct integers so its score is equal to 3. It can be shown that there is no permutation of integers from 1 to 7 with a score higher than 3.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1857C": {
        "title": "C. Assembly via Minimums",
        "description": "Sasha has an array a of n integers. He got bored and for all i, j (i<j), he wrote down the minimum value of ai and aj. He obtained a new array b of size n\u22c5(n\u22121)2.\nFor example, if a= [2,3,5,1], he would write [min(2,3),min(2,5),min(2,1),min(3,5),min(3,1),min(5,1)] = [2,2,1,3,1,1].\nThen, he randomly shuffled all the elements of the array b.\nUnfortunately, he forgot the array a, and your task is to restore any possible array a from which the array b could have been obtained.\nThe elements of array a should be in the range [\u2212109,109].\nThe first line contains a single integer t (1\u2264t\u2264200)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264103)\u00a0\u2014 the length of array a.\nThe second line of each test case contains n\u22c5(n\u22121)2 integers b1,b2,\u2026,bn\u22c5(n\u22121)2 (\u2212109\u2264bi\u2264109)\u00a0\u2014 the elements of array b.\nIt is guaranteed that the sum of n over all tests does not exceed 103 and for each array b in the test, there exists an original array.\nFor each test case, output any possible array a of length n.\nIn the first sample, Sasha chose the array [1,3,3], then the array b will look like [min(a1,a2)=1,min(a1,a3)=1,min(a2,a3)=3], after shuffling its elements, the array can look like [1,3,1].\nIn the second sample, there is only one pair, so the array [10,10] is suitable. Another suitable array could be [15,10].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1857B": {
        "title": "B. Maximum Rounding",
        "description": "Given a natural number x. You can perform the following operation: \nNote that the positions are numbered from right to left, starting from zero. If the number has k digits, it is considered that the digit at the k-th position is equal to 0.\nThe rounding is done as follows: \n \n \nYour task is to make x as large as possible, if you can perform the operation as many times as you want.\nFor example, if x is equal to 3451, then if you choose consecutively: \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nEach test case consists of positive integer x with a length of up to 2\u22c5105. It is guaranteed that there are no leading zeros in the integer.\nIt is guaranteed that the sum of the lengths of all integers x over all test cases does not exceed 2\u22c5105.\nFor each set of input data, output the maximum possible value of x after the operations. The number should not have leading zeros in its representation.\nIn the first sample, it is better not to perform any operations.\nIn the second sample, you can perform one operation and obtain 10.\nIn the third sample, you can choose k=1 or k=2. In both cases the answer will be 100.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1853B": {
        "title": "B. Fibonaccharsis",
        "description": "Ntarsis has received two integers n and k for his birthday. He wonders how many fibonacci-like sequences of length k can be formed with n as the k-th element of the sequence. \nA sequence of non-decreasing non-negative integers is considered fibonacci-like if fi=fi\u22121+fi\u22122 for all i>2, where fi denotes the i-th element in the sequence. Note that f1 and f2 can be arbitrary.\nFor example, sequences such as [4,5,9,14] and [0,1,1] are considered fibonacci-like sequences, while [0,0,0,1,1], [1,2,1,3], and [\u22121,\u22121,\u22122] are not: the first two do not always satisfy fi=fi\u22121+fi\u22122, the latter does not satisfy that the elements are non-negative.\nImpress Ntarsis by helping him with this task.\nThe first line contains an integer t (1\u2264t\u22642\u22c5105), the number of test cases. The description of each test case is as follows.\nEach test case contains two integers, n and k (1\u2264n\u22642\u22c5105, 3\u2264k\u2264109).\nIt is guaranteed the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case output an integer, the number of fibonacci-like sequences of length k such that the k-th element in the sequence is n. That is, output the number of sequences f of length k so f is a fibonacci-like sequence and fk=n. It can be shown this number is finite.\nThere are 4 valid fibonacci-like sequences for n=22, k=4:\nFor n=3, k=9, it can be shown that there are no fibonacci-like sequences satisfying the given conditions.\nFor n=55, k=11, [0,1,1,2,3,5,8,13,21,34,55] is the only fibonacci-like sequence.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1851C": {
        "title": "C. Tiles Comeback",
        "description": "Vlad remembered that he had a series of nn tiles and a number k. The tiles were numbered from left to right, and the i-th tile had colour ci.\nIf you stand on the first tile and start jumping any number of tiles right, you can get a path of length p. The length of the path is the number of tiles you stood on.\nVlad wants to see if it is possible to get a path of length p such that: \nFor example, let n=14, k=3.\nThe colours of the tiles are contained in the array c = [1,2,1,1,7,5,3,3,1,3,4,4,2,4]. Then we can construct a path of length 6 consisting of 2 blocks:\nc1\u2192c3\u2192c4\u2192c11\u2192c12\u2192c14\nAll tiles from the 1-st block will have colour 1, from the 2-nd block will have colour 4.\nIt is also possible to construct a path of length 9 in this example, in which all tiles from the 1-st block will have colour 1, from the 2-nd block will have colour 3, and from the 3-rd block will have colour 4.\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105)\u2014the number of tiles in the series and the length of the block.\nThe second line of each test case contains n integers c1,c2,c3,\u2026,cn (1\u2264ci\u2264n) \u2014 the colours of the tiles.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output on a separate line: \nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as positive response).\nIn the first test case, you can jump from the first tile to the last tile;\nThe second test case is explained in the problem statement.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1850E": {
        "title": "E. Cardboard for Pictures",
        "description": "Mircea has n pictures. The i-th picture is a square with a side length of si centimeters. \nHe mounted each picture on a square piece of cardboard so that each picture has a border of w centimeters of cardboard on all sides. In total, he used c square centimeters of cardboard. Given the picture sizes and the value c, can you find the value of w?\nPlease note that the piece of cardboard goes behind each picture, not just the border.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two positive integers n (1\u2264n\u22642\u22c5105) and c (1\u2264c\u22641018)\u00a0\u2014 the number of paintings, and the amount of used square centimeters of cardboard.\nThe second line of each test case contains n space-separated integers si (1\u2264si\u2264104)\u00a0\u2014 the sizes of the paintings.\nThe sum of n over all test cases doesn't exceed 2\u22c5105.\nAdditional constraint on the input: Such an integer w exists for each test case.\nPlease note, that some of the input for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).\nFor each test case, output a single integer\u00a0\u2014 the value of w (w\u22651) which was used to use exactly c squared centimeters of cardboard.\nThe first test case is explained in the statement.\nFor the second test case, the chosen w was 2, thus the only cardboard covers an area of c=(2\u22c52+6)2=102=100 squared centimeters.\nFor the third test case, the chosen w was 4, which obtains the covered area c=(2\u22c54+2)2\u00d75=102\u00d75=100\u00d75=500 squared centimeters.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "geometry",
            "implementation",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1849B": {
        "title": "B. Monsters",
        "description": "Monocarp is playing yet another computer game. And yet again, his character is killing some monsters. There are n monsters, numbered from 1 to n, and the i-th of them has ai health points initially.\nMonocarp's character has an ability that deals k damage to the monster with the highest current health. If there are several of them, the one with the smaller index is chosen. If a monster's health becomes less than or equal to 0 after Monocarp uses his ability, then it dies.\nMonocarp uses his ability until all monsters die. Your task is to determine the order in which monsters will die.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n and k (1\u2264n\u22643\u22c5105; 1\u2264k\u2264109)\u00a0\u2014 the number of monsters and the damage which Monocarp's ability deals.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the initial health points of monsters.\nThe sum of n over all test cases doesn't exceed 3\u22c5105.\nFor each test case, print n integers\u00a0\u2014 the indices of monsters in the order they die. \nIn the first example, the health points change as follows: [1,2,3_]\u2192[1,2_,1]\u2192[1_,0,1]\u2192[\u22121,0,1_]\u2192[\u22121,0,\u22121]. The monster that is going to take damage the next time Monocarp uses his ability is underlined.\nIn the second example, the health points change as follows: [1_,1]\u2192[\u22122,1_]\u2192[\u22122,\u22122].\nIn the third example, the health points change as follows: [2,8_,3,5]\u2192[2,5_,3,5]\u2192[2,2,3,5_]\u2192[2,2,3_,2]\u2192[2_,2,0,2]\u2192[\u22121,2_,0,2]\u2192[\u22121,\u22121,0,2_]\u2192[\u22121,\u22121,0,\u22121]. ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1848B": {
        "title": "B. Vika and the Bridge",
        "description": "In the summer, Vika likes to visit her country house. There is everything for relaxation: comfortable swings, bicycles, and a river.\nThere is a wooden bridge over the river, consisting of n planks. It is quite old and unattractive, so Vika decided to paint it. And in the shed, they just found cans of paint of k colors.\nAfter painting each plank in one of k colors, Vika was about to go swinging to take a break from work. However, she realized that the house was on the other side of the river, and the paint had not yet completely dried, so she could not walk on the bridge yet.\nIn order not to spoil the appearance of the bridge, Vika decided that she would still walk on it, but only stepping on planks of the same color. Otherwise, a small layer of paint on her sole will spoil the plank of another color. Vika also has a little paint left, but it will only be enough to repaint one plank of the bridge.\nNow Vika is standing on the ground in front of the first plank. To walk across the bridge, she will choose some planks of the same color (after repainting), which have numbers 1\u2264i1<i2<\u2026<im\u2264n (planks are numbered from 1 from left to right). Then Vika will have to cross i1\u22121,i2\u2212i1\u22121,i3\u2212i2\u22121,\u2026,im\u2212im\u22121\u22121,n\u2212im planks as a result of each of m+1 steps.\nSince Vika is afraid of falling, she does not want to take too long steps. Help her and tell her the minimum possible maximum number of planks she will have to cross in one step, if she can repaint one (or zero) plank a different color while crossing the bridge.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105)\u00a0\u2014 the number of planks in the bridge and the number of different colors of paint.\nThe second line of each test case contains n integers c1,c2,c3,\u2026,cn (1\u2264ci\u2264k)\u00a0\u2014 the colors in which Vika painted the planks of the bridge.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the minimum possible maximum number of planks that Vika will have to step over in one step.\nIn the first test case, Vika can repaint the plank in the middle in color 1 and walk across the bridge without stepping over any planks.\nIn the second test case, Vika can repaint the plank in the middle in color 2 and walk across the bridge, stepping over only one plank each time.\nIn the third test case, Vika can repaint the penultimate plank in color 2 and walk across the bridge, stepping only on planks with numbers 2 and 5. Then Vika will have to step over 1, 2 and 1 plank each time she steps, so the answer is 2.\nIn the fourth test case, Vika can simply walk across the bridge without repainting it, stepping over two planks each time, walking on planks of color 3.\nIn the fifth test case, Vika can simply walk across the bridge without repainting it, without stepping over any planks.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "implementation",
            "math",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1847B": {
        "title": "B. Hamon Odyssey",
        "description": "Jonathan is fighting against DIO's Vampire minions. There are n of them with strengths a1,a2,\u2026,an. \nDenote (l,r) as the group consisting of the vampires with indices from l to r. Jonathan realizes that the strength of any such group is in its weakest link, that is, the bitwise AND. More formally, the strength level of the group (l,r) is defined as f(l,r)=al&al+1&al+2&\u2026&ar. Here, & denotes the bitwise AND operation. \nBecause Jonathan would like to defeat the vampire minions fast, he will divide the vampires into contiguous groups, such that each vampire is in exactly one group, and the sum of strengths of the groups is minimized. Among all ways to divide the vampires, he would like to find the way with the maximum number of groups.\nGiven the strengths of each of the n vampires, find the maximum number of groups among all possible ways to divide the vampires with the smallest sum of strengths.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of vampires.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109)\u00a0\u2014 the individual strength of each vampire.\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the maximum number of groups among all possible ways to divide the vampires with the smallest sum of strengths.\nIn the first test case, the optimal way is to take all the n vampires as a group. So, f(1,3)=1&2&3=0.\nIn the second test case, the optimal way is to make 2 groups, (2,3,1) and (5,2). So, f(1,3)+f(4,5)=(2&3&1)+(5&2)=0+0=0.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "two pointers",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1846D": {
        "title": "D. Rudolph and Christmas Tree",
        "description": "Rudolph drew a beautiful Christmas tree and decided to print the picture. However, the ink in the cartridge often runs out at the most inconvenient moment. Therefore, Rudolph wants to calculate in advance how much green ink he will need.\nThe tree is a vertical trunk with identical triangular branches at different heights. The thickness of the trunk is negligible.\nEach branch is an isosceles triangle with base d and height h, whose base is perpendicular to the trunk. The triangles are arranged upward at an angle, and the trunk passes exactly in the middle. The base of the i-th triangle is located at a height of yi.\nThe figure below shows an example of a tree with d=4,h=2 and three branches with bases at heights [1,4,5].\nHelp Rudolph calculate the total area of the tree branches.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThen follow the descriptions of the test cases.\nThe first line of each test case contains three integers n,d,h (1\u2264n,d,h\u22642\u22c5105)\u00a0\u2014 the number of branches, the length of the base, and the height of the branches, respectively.\nThe second line of each test case contains n integers yi (1\u2264yi\u2264109,y1<y2<...<yn) \u2014 the heights of the bases of the branches.\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single real number on a separate line \u2014 the total area of the tree branches. The answer will be considered correct if its absolute or relative error does not exceed 10\u22126.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "geometry",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1846C": {
        "title": "C. Rudolf and the Another Competition",
        "description": "Rudolf has registered for a programming competition that will follow the rules of ICPC. The rules imply that for each solved problem, a participant gets 11 point, and also incurs a penalty equal to the number of minutes passed from the beginning of the competition to the moment of solving the problem. In the final table, the participant with the most points is ranked higher, and in case of a tie in points, the participant with the lower penalty is ranked higher.\nIn total, n participants have registered for the competition. Rudolf is a participant with index 1. It is known that m problems will be proposed. And the competition will last h minutes.\nA powerful artificial intelligence has predicted the values ti,j, which represent the number of minutes it will take for the i-th participant to solve the j-th problem.\nRudolf realized that the order of solving problems will affect the final result. For example, if h=120, and the times to solve problems are [20,15,110], then if Rudolf solves the problems in the order:\nRudolf became interested in what place he will take in the competition if each participant solves problems in the optimal order based on the predictions of the artificial intelligence. It will be assumed that in case of a tie in points and penalty, Rudolf will take the best place.\nThe first line contains an integer t (1\u2264t\u2264103) \u2014 the number of test cases.\nThen follow the descriptions of the test cases.\nThe first line of each test case contains three integers n,m,h (1\u2264n\u22c5m\u22642\u22c5105,1\u2264h\u2264106) \u2014 the number of participants, the number of problems, and the duration of the competition, respectively.\nThen there are n lines, each containing m integers ti,j (1\u2264ti,j\u2264106) \u2014 the number of minutes it will take for the i-th participant to solve the j-th problem.\nThe sum of n\u22c5m over all test cases does not exceed 2\u22c5105.\nFor each test case, output an integer \u2014 Rudolf's place in the final table if all participants solve problems in the optimal order.\nIn the first example, Rudolf will get 2 points and 50 penalty minutes. The second participant will solve only one problem and get 1 point and 90 penalty minutes. And the third participant will solve all 3 problems and get 3 points and 240 penalty minutes. Thus, Rudolf will take the second place.\nIn the second example, both participants will get 1 point and 30 penalty minutes. In case of a tie in points, Rudolf gets the better position, so he will take the first place.\nIn the third example, Rudolf is the only participant, so he will take the first place.\nIn the fourth example, all participants can solve two problems with penalty of 25=8+(8+9), 24=7+(7+10) and 26=8+(8+10), respectively, thanks to the penalty, the second participant gets the first place, and Rudolf gets the second.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "dp",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1844B": {
        "title": "B. Permutations & Primes",
        "description": "You are given a positive integer n.\nIn this problem, the MEX of a collection of integers c1,c2,\u2026,ck is defined as the smallest positive integer x which does not occur in the collection c. \nThe primality of an array a1,\u2026,an is defined as the number of pairs (l,r) such that 1\u2264l\u2264r\u2264n and MEX(al,\u2026,ar) is a prime number. \nFind any permutation of 1,2,\u2026,n with the maximum possible primality among all permutations of 1,2,\u2026,n. \nNote: \nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe only line of each test case contains a single integer n (1\u2264n\u22642\u22c5105).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers: a permutation of 1,2,\u2026,n that achieves the maximum possible primality.\nIf there are multiple solutions, print any of them.\nIn the first test case, there are 3 pairs (l,r) with 1\u2264l\u2264r\u22642, out of which 2 have a prime MEX(al,\u2026,ar): \nIn the second test case, MEX(1)=2 is prime, so the primality is 1.\nIn the third test case, the maximum possible primality is 8.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1843D": {
        "title": "D. Apple Tree",
        "description": "Timofey has an apple tree growing in his garden; it is a rooted tree of n vertices with the root in vertex 1 (the vertices are numbered from 1 to n). A tree is a connected graph without loops and multiple edges.\nThis tree is very unusual\u00a0\u2014 it grows with its root upwards. However, it's quite normal for programmer's trees.\nThe apple tree is quite young, so only two apples will grow on it. Apples will grow in certain vertices (these vertices may be the same). After the apples grow, Timofey starts shaking the apple tree until the apples fall. Each time Timofey shakes the apple tree, the following happens to each of the apples:\nLet the apple now be at vertex u.\nIt can be shown that after a finite time, both apples will fall from the tree.\nTimofey has q assumptions in which vertices apples can grow. He assumes that apples can grow in vertices x and y, and wants to know the number of pairs of vertices (a, b) from which apples can fall from the tree, where a\u00a0\u2014 the vertex from which an apple from vertex x will fall, b\u00a0\u2014 the vertex from which an apple from vertex y will fall. Help him do this.\nThe first line contains integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the number of vertices in the tree.\nThen there are n\u22121 lines describing the tree. In line i there are two integers ui and vi (1\u2264ui,vi\u2264n, ui\u2260vi)\u00a0\u2014 edge in tree.\nThe next line contains a single integer q (1\u2264q\u22642\u22c5105)\u00a0\u2014 the number of Timofey's assumptions.\nEach of the next q lines contains two integers xi and yi (1\u2264xi,yi\u2264n)\u00a0\u2014 the supposed vertices on which the apples will grow for the assumption i.\nIt is guaranteed that the sum of n does not exceed 2\u22c5105. Similarly, It is guaranteed that the sum of q does not exceed 2\u22c5105.\nFor each Timofey's assumption output the number of ordered pairs of vertices from which apples can fall from the tree if the assumption is true on a separate line.\nIn the first example: \nFor the second example, there are 4 of possible pairs of vertices from which apples can fall: (2,3),(2,2),(3,2),(3,3). For the second assumption, there is only one possible pair: (2,3). For the third assumption, there are two pairs: (3,2),(3,3).",
        "time_limit": "time limit per test4 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "combinatorics",
            "dfs and similar",
            "dp",
            "math",
            "trees",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1842B": {
        "title": "B. Tenzing and Books",
        "description": "Tenzing received 3n books from his fans. The books are arranged in 3 stacks with n books in each stack. Each book has a non-negative integer difficulty rating.\nTenzing wants to read some (possibly zero) books. At first, his knowledge is 0.\nTo read the books, Tenzing will choose a non-empty stack, read the book on the top of the stack, and then discard the book. If Tenzing's knowledge is currently u, then his knowledge will become u|v after reading a book with difficulty rating v. Here | denotes the bitwise OR operation. Note that Tenzing can stop reading books whenever he wants.\nTenzing's favourite number is x. Can you help Tenzing check if it is possible for his knowledge to become x?\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers n and x (1\u2264n\u2264105, 0\u2264x\u2264109)\u00a0\u2014 the number of books in each stack and Tenzing's favourite number.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109) \u00a0\u2014 the difficulty rating of the books in the first stack, from top to bottom.\nThe third line of each test case contains n integers b1,b2,\u2026,bn (0\u2264bi\u2264109) \u00a0\u2014 the difficulty rating of the books in the second stack, from top to bottom.\nThe fourth line of each test case contains n integers c1,c2,\u2026,cn (0\u2264ci\u2264109) \u00a0\u2014 the difficulty rating of the books in the third stack, from top to bottom.\nIt is guaranteed that the sum of n does not exceed 105.\nFor each test case, output \"Yes\" (without quotes) if Tenzing can make his knowledge equal to x, and \"No\" (without quotes) otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nFor the first test case, Tenzing can read the following 4 books: \nAfter reading all books, Tenzing's knowledge is 7.\nFor the third test case, Tenzing can read 0 books to make his final knowledge equals to 0.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1841B": {
        "title": "B. Keep it Beautiful",
        "description": "The array [a1,a2,\u2026,ak] is called beautiful if it is possible to remove several (maybe zero) elements from the beginning of the array and insert all these elements to the back of the array in the same order in such a way that the resulting array is sorted in non-descending order.\nIn other words, the array [a1,a2,\u2026,ak] is beautiful if there exists an integer i\u2208[0,k\u22121] such that the array [ai+1,ai+2,\u2026,ak\u22121,ak,a1,a2,\u2026,ai] is sorted in non-descending order.\nFor example:\nNote that any array consisting of zero elements or one element is beautiful.\nYou are given an array a, which is initially empty. You have to process q queries to it. During the i-th query, you will be given one integer xi, and you have to do the following:\nAfter each query, report whether you appended the given integer xi, or not.\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of two lines. The first line contains one integer q (1\u2264q\u22642\u22c5105) \u2014 the number of queries. The second line contains q integers x1,x2,\u2026,xq (0\u2264xi\u2264109).\nAdditional constraint on the input: the sum of q over all test cases does not exceed 2\u22c5105).\nFor each test case, print one string consisting of exactly q characters. The i-th character of the string should be 1 if you appended the integer during the i-th query; otherwise, it should be 0.\nConsider the first test case of the example. Initially, the array is [].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1840C": {
        "title": "C. Ski Resort",
        "description": "Dima Vatrushin is a math teacher at school. He was sent on vacation for n days for his good work. Dima has long dreamed of going to a ski resort, so he wants to allocate several consecutive days and go skiing. Since the vacation requires careful preparation, he will only go for at least k days.\nYou are given an array a containing the weather forecast at the resort. That is, on the i-th day, the temperature will be ai degrees.\nDima was born in Siberia, so he can go on vacation only if the temperature does not rise above q degrees throughout the vacation.\nUnfortunately, Dima was so absorbed in abstract algebra that he forgot how to count. He asks you to help him and count the number of ways to choose vacation dates at the resort.\nThe first line of the input contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThen follow the descriptions of the test cases.\nThe first line of each test case contains three integers n, k, q (1\u2264n\u22642\u22c5105, 1\u2264k\u2264n, \u2212109\u2264q\u2264109)\u00a0\u2014 the length of the array a, the minimum number of days at the resort, and the maximum comfortable temperature for Dima.\nThe second line of each test case contains n integers a1,a2,a3,\u2026,an (\u2212109\u2264ai\u2264109)\u00a0\u2014 the temperature at the ski resort.\nThe sum of all n values over all test cases does not exceed 2\u22c5105.\nOutput t integers, each of which is the answer to the corresponding test case\u00a0\u2014 the number of ways for Dima to choose vacation dates at the resort.\nIn the first test case of the example, Dima can go on any day, so the suitable dates for him are [1], [2], [3], [1, 2], [2, 3], [1, 2, 3].\nIn the second and fourth test cases of the example, Dima cannot go on any day due to the high temperature, so there are no suitable dates.\nIn the third test case of the example, Dima can only go on the dates [1, 2, 3].",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "two pointers",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1840B": {
        "title": "B. Binary Cafe",
        "description": "Once upon a time, Toma found himself in a binary cafe. It is a very popular and unusual place.\nThe cafe offers visitors k different delicious desserts. The desserts are numbered from 0 to k\u22121. The cost of the i-th dessert is 2i coins, because it is a binary cafe! Toma is willing to spend no more than n coins on tasting desserts. At the same time, he is not interested in buying any dessert more than once, because one is enough to evaluate the taste.\nIn how many different ways can he buy several desserts (possibly zero) for tasting?\nThe first line of the input contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThen follows t lines, each of which describes one test case.\nEach test case is given on a single line and consists of two integers n and k (1\u2264n,k\u2264109)\u00a0\u2014 the number of coins Toma is willing to spend and the number of desserts in the binary cafe.\nOutput t integers, the i-th of which should be equal to the answer for the i-th test case\u00a0\u2014 the number of ways to buy desserts for tasting.\nVariants for 1st sample: {}, {1}\nVariants for 2nd sample: {}, {1}\nVariants for 3rd sample: {}, {1}, {2}\nVariants for 4th sample: {}, {1}, {2}, {1, 2}",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "combinatorics",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1839B": {
        "title": "B. Lamps",
        "description": "You have n lamps, numbered by integers from 1 to n. Each lamp i has two integer parameters ai and bi.\nAt each moment each lamp is in one of three states: it may be turned on, turned off, or broken.\nInitially all lamps are turned off. In one operation you can select one lamp that is turned off and turn it on (you can't turn on broken lamps). You receive bi points for turning lamp i on. The following happens after each performed operation: \nPlease note that broken lamps never count as turned on and that after a turned on lamp breaks, you still keep points received for turning it on.\nYou can perform an arbitrary number of operations.\nFind the maximum number of points you can get.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of lamps.\nEach of the next n lines contains two integers ai and bi (1\u2264ai\u2264n,1\u2264bi\u2264109)\u00a0\u2014 parameters of the i-th lamp.\nIt is guaranteed that sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output one integer\u00a0\u2014 the maximum number of points you can get.\nIn first test case n=4. One of ways to get the maximum number of points is as follows: \nYour receive 13+2=15 points in total. It can be shown that this is the maximum number of points you can get, so the answer for the first test case is 15.\nIn the second test case, one of the ways to get the maximum number of points is as follows:\nYou receive 2+5+4+3=14 points in total. It can be shown that this is the maximum number of points you can get.\nIn the third test case, one of the ways to get the maximum number of points is as follows:\nYou receive 4+4+3+4+5=20 points in total. It can be shown that this is the maximum number of points you can get.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1838B": {
        "title": "B. Minimize Permutation Subarrays",
        "description": "You are given a permutation p of size n. You want to minimize the number of subarrays of p that are permutations. In order to do so, you must perform the following operation exactly once:\nFor example, if p=[5,1,4,2,3] and we choose i=2, j=3, the resulting array will be [5,4,1,2,3]. If instead we choose i=j=5, the resulting array will be [5,1,4,2,3].\nWhich choice of i and j will minimize the number of subarrays that are permutations?\nA permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nAn array a is a subarray of an array b if a can be obtained from b by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nThe first line of the input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u22642\u22c5105)\u00a0\u2014 the size of the permutation.\nThe next line of each test case contains n integers p1,p2,\u2026pn (1\u2264pi\u2264n, all pi are distinct)\u00a0\u2014 the elements of the permutation p.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output two integers i and j (1\u2264i,j\u2264n) \u00a0\u2014 the indices to swap in p.\nIf there are multiple solutions, print any of them.\nFor the first test case, there are four possible arrays after the swap: \nFor the third sample case, after we swap elements at positions 2 and 5, the resulting array is [1,4,2,5,3]. The only subarrays that are permutations are [1] and [1,4,2,5,3]. We can show that this is minimal.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1837C": {
        "title": "C. Best Binary String",
        "description": "You are given a string s consisting of the characters 0, 1 and/or ?. Let's call it a pattern.\nLet's say that the binary string (a string where each character is either 0 or 1) matches the pattern if you can replace each character ? with 0 or 1 (for each character, the choice is independent) so that the strings become equal. For example, 0010 matches ?01?, but 010 doesn't match 1??, ??, or ????.\nLet's define the cost of the binary string as the minimum number of operations of the form \"reverse an arbitrary contiguous substring of the string\" required to sort the string in non-descending order.\nYou have to find a binary string with the minimum possible cost among those that match the given pattern. If there are multiple answers, print any of them.\nThe first line contains a single integer t (1\u2264t\u22643\u22c5104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains the string s (1\u2264|s|\u22643\u22c5105) consisting of characters 0, 1, and/or ?.\nThe sum of the string lengths over all test cases does not exceed 3\u22c5105.\nFor each test case, print a binary string with the minimum possible cost among those that match the given pattern. If there are multiple answers, print any of them.\nIn the first test case of the example, the cost of the resulting string is 0.\nIn the second test case, the cost of the resulting string is 2: we can reverse the substring from the 1-st character to the 5-th character, and we obtain the string 00101. Then we reverse the substring from the 3-rd to the 4-th character, and we obtain the string 00011, which is sorted in non-descending order.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1836B": {
        "title": "B. Astrophysicists",
        "description": "In many, many years, far, far away, there will be a launch of the first flight to Mars. To celebrate the success, n astrophysicists working on the project will be given bonuses of a total value of k gold coins.\nYou have to distribute the money among the astrophysicists, and to make it easier, you have to assign bonuses in silver coins. Each gold coin is worth g silver coins, so you have to distribute all k\u22c5g silver coins among n people.\nUnfortunately, the company has some financial troubles right now. Therefore, instead of paying the number of silver coins written on the bonus, they decided to round this amount to the nearest integer number of gold coins.\nThe rounding procedure is as follows. If an astrophysicist has bonus equal to x silver coins, and we denote r=xmodg, then: \nYou aim to distribute the bonuses so that the company saves as many silver coins due to rounding as possible. Please note that there is always a distribution in which the company spends no more than k\u22c5g silver coins.\nIn the first line of input, there is one integer t (1\u2264t\u2264104) denoting the number of test cases.\nEach of the following t lines describes one test case and contains three integers n, k, g (1\u2264n\u2264109, 0\u2264k\u2264109, 2\u2264g\u2264109) \u2014 respectively the number of astrophysicists in the company, total number of gold coins to assign and the number of silver coins that one gold coin corresponds to.\nIn a separate line for each test case, output a single integer \u2014 the maximum number of silver coins that could be saved due to rounding.\nIn the first test case, one of the optimal assignments could be the following:\nIn the second test case, we could have the following assignment: \nIf the bonuses are assigned to 7 silver coins for both astrophysicists, then the company would have to pay an additional gold coin to cover the bonuses.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1834C": {
        "title": "C. Game with Reversing",
        "description": "Alice and Bob are playing a game. They have two strings S and T of the same length n consisting of lowercase latin letters. Players take turns alternately, with Alice going first.\nOn her turn, Alice chooses an integer i from 1 to n, one of the strings S or T, and any lowercase latin letter c, and replaces the i-th symbol in the chosen string with the character c.\nOn his turn, Bob chooses one of the strings S or T, and reverses it. More formally, Bob makes the replacement S:=rev(S) or T:=rev(T), where rev(P)=PnPn\u22121\u2026P1.\nThe game lasts until the strings S and T are equal. As soon as the strings become equal, the game ends instantly.\nDefine the duration of the game as the total number of moves made by both players during the game. For example, if Alice made 2 moves in total, and Bob made 1 move, then the duration of this game is 3.\nAlice's goal is to minimize the duration of the game, and Bob's goal is to maximize the duration of the game.\nWhat will be the duration of the game, if both players play optimally? It can be shown that the game will end in a finite number of turns.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the strings S and T.\nThe second line of each test case contains a string S of length n consisting of lowercase latin letters.\nThe third line of each test case contains a string T of length n consisting of lowercase latin letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output a single number on a separate line\u00a0\u2014 the duration of the described game, if both players play optimally.\nIn the first test case, in her turn, Alice can replace the third symbol of the string S with x. After that, both strings will become equal to \"abxde\" and the game will end after one move. Since Alice's goal is to finish the game in as few moves as possible, this move will be one of her optimal first moves, and the final answer will be 1.\nIn the second test case, in her turn, Alice can replace the fifth symbol of the string T with h. After this move, S= \"hello\", T= \"olleh\". Then Bob makes his turn. In his turn, he must reverse one of the strings. If Bob chooses the string S, then after his turn both strings will be equal to \"olleh\", and if he chooses the string T, then after his turn both strings will be equal to \"hello\". Thus, after the presented first move of Alice, the game will definitely end in 2 moves. It can be shown that there is no strategy for Alice to finish the game in less than 2 moves, with both players playing optimally. The final answer is 2.\nIn the third test case, in her first move, Alice can replace the second symbol of the string S with c. After this move, S= \"ac\", T= \"cd\". Then Bob makes his turn. If Bob reverses the string S, then after his turn S= \"ca\", T= \"cd\". Then it is easy to see that in this case Alice can definitely finish the game on the 3-rd move, by replacing the second symbol of the string T with a, after which both strings will become equal to \"ca\". If Bob reverses the string T, then after his turn S= \"ac\", T= \"dc\". In this case, Alice can also definitely finish the game on the 3rd move, by replacing the first symbol of the string S with d, after which both strings will become equal to \"dc\". Thus, Alice can definitely finish the game in 3 moves regardless of Bob's moves. It can be shown that the game cannot end in less than 3 moves, with both players playing optimally.\nIn the fifth test case, the strings S and T are equal, so the game will end without starting, in 0 moves.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "math",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1834B": {
        "title": "B. Maximum Strength",
        "description": "Fedya is playing a new game called \"The Legend of Link\", in which one of the character's abilities is to combine two materials into one weapon. Each material has its own strength, which can be represented by a positive integer xx. The strength of the resulting weapon is determined as the sum of the absolute differences of the digits in the decimal representation of the integers at each position.\nFormally, let the first material have strength X=\u00afx1x2\u2026xn, and the second material have strength Y=\u00afy1y2\u2026yn. Then the strength of the weapon is calculated as |x1\u2212y1|+|x2\u2212y2|+\u2026+|xn\u2212yn|. If the integers have different lengths, then the shorter integer is padded with leading zeros.\nFedya has an unlimited supply of materials with all possible strengths from L to R, inclusive. Help him find the maximum possible strength of the weapon he can obtain.\nAn integer C=\u00afc1c2\u2026ck is defined as an integer obtained by sequentially writing the digits c1,c2,\u2026,ck from left to right, i.e. 10k\u22121\u22c5c1+10k\u22122\u22c5c2+\u2026+ck.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264500). The description of the test cases follows.\nThe first line of each test case contains two integers L and R (1\u2264L\u2264R<10100)\u00a0\u2014 the decimal representation of the integers representing the minimum and maximum strength of the materials that Fedya has. It is guaranteed that the integers L and R do not contain leading zeros.\nNote that the input data may not fit into standard 32-bit or 64-bit integer data types.\nFor each test case print one integer\u00a0\u2014 the maximum possible strength of the weapon that Fedya can obtain from the given materials.\nIn the first test case, the weapon made from materials with strengths 53 and 57 will have the maximum possible strength: |5\u22125|+|3\u22127|=4.\nIn the second test case, the maximum strength is achieved with materials with strengths 190 and 209: |1\u22122|+|9\u22120|+|0\u22129|=19.\nIn the fourth test case, there is only one valid strength, so the answer is 0.\nIn the sixth test case, the maximum strength is achieved with materials with strengths 1909 and 90: |1\u22120|+|9\u22120|+|0\u22129|+|9\u22120|=28. Note that the shorter integer was padded with leading zeros.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1832C": {
        "title": "C. Contrast Value",
        "description": "For an array of integers [a1,a2,\u2026,an], let's call the value |a1\u2212a2|+|a2\u2212a3|+\u22ef+|an\u22121\u2212an| the contrast of the array. Note that the contrast of an array of size 1 is equal to 0.\nYou are given an array of integers a. Your task is to build an array of b in such a way that all the following conditions are met:\nWhat is the minimum possible size of the array b?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22643\u22c5105)\u00a0\u2014 the size of the array a.\nThe second line contains n integers a1,a2,\u22c5,an (0\u2264ai\u2264109)\u00a0\u2014 elements of the array itself.\nThe sum of n over all test cases doesn't exceed 3\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the minimum possible size of the array b.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1832B": {
        "title": "B. Maximum Sum",
        "description": "You are given an array a1,a2,\u2026,ana1,a2,\u2026,an, where all elements are different.\nYou have to perform exactly k operations with it. During each operation, you do exactly one of the following two actions (you choose which to do yourself):\nYou have to calculate the maximum possible sum of elements in the resulting array.\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of two lines: \nAdditional constraint on the input: the sum of n does not exceed 2\u22c5105.\nFor each test case, print one integer \u2014 the maximum possible sum of elements in the resulting array.\nIn the first testcase, applying the first operation produces the following outcome: \n21 is the best answer.\nIn the second testcase, it's optimal to first erase two minimums, then a maximum.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1831B": {
        "title": "B. Array merging",
        "description": "You are given two arrays a and b both of length n.\nYou will merge\u2020 these arrays forming another array c of length 2\u22c5n. You have to find the maximum length of a subarray consisting of equal values across all arrays c that could be obtained.\n\u2020 A merge of two arrays results in an array c composed by successively taking the first element of either array (as long as that array is nonempty) and removing it. After this step, the element is appended to the back of c. We repeat this operation as long as we can (i.e. at least one array is nonempty).\nEach test contains multiple test cases. The first line of input contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array a and b.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u22642\u22c5n)\u00a0\u2014 the elements of array a.\nThe third line of each test case contains n integers b1,b2,\u2026,bn (1\u2264bi\u22642\u22c5n)\u00a0\u2014 the elements of array b.\nIt is guaranteed that the sum of n across all test cases does not exceed 2\u22c5105.\nFor each test case, output the maximum length of a subarray consisting of equal values across all merges.\nIn the first test case, we can only make c=[2,2], thus the answer is 2.\nIn the second test case, since all values are distinct, the answer must be 1.\nIn the third test case, the arrays c we can make are [1,2,1,2], [1,2,2,1], [2,1,1,2], [2,1,2,1]. We can see that the answer is 2 when we choose c=[1,2,2,1]. ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1829E": {
        "title": "E. The Lakes",
        "description": "You are given an n\u00d7m grid a of non-negative integers. The value ai,j represents the depth of water at the i-th row and j-th column. \nA lake is a set of cells such that:\nThe volume of a lake is the sum of depths of all the cells in the lake.\nFind the largest volume of a lake in the grid.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n,m (1\u2264n,m\u22641000)\u00a0\u2014 the number of rows and columns of the grid, respectively.\nThen n lines follow each with m integers ai,j (0\u2264ai,j\u22641000)\u00a0\u2014 the depth of the water at each cell.\nIt is guaranteed that the sum of n\u22c5m over all test cases does not exceed 106.\nFor each test case, output a single integer\u00a0\u2014 the largest volume of a lake in the grid.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "dsu",
            "graphs",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1829D": {
        "title": "D. Gold Rush",
        "description": "Initially you have a single pile with n gold nuggets. In an operation you can do the following: \nOne possible move is to take a pile of size 6 and split it into piles of sizes 2 and 4, which is valid since 4 is twice as large as 2. \nThe first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe only line of each test case contains two integers n and m (1\u2264n,m\u2264107)\u00a0\u2014 the starting and target pile sizes, respectively.\nFor each test case, output \"YES\" if you can make a pile of size exactly m, and \"NO\" otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nThe first test case is pictured in the statement. We can make a pile of size 4.\nIn the second test case, we can perform the following operations: {9}\u2192{6,3}\u2192{4,2,3}. The pile that is split apart is colored red before each operation.\nIn the third test case, we can't perform a single operation.\nIn the fourth test case, we can't end up with a larger pile than we started with.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "dp",
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1827A": {
        "title": "A. Counting Orders",
        "description": "You are given two arrays a and b each consisting of n integers. All elements of a are pairwise distinct.\nFind the number of ways to reorder a such that ai>bi for all 1\u2264i\u2264n, modulo 109+7.\nTwo ways of reordering are considered different if the resulting arrays are different.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array a and b.\nThe second line of each test case contains n distinct integers a1, a2, \u2026, an (1\u2264ai\u2264109)\u00a0\u2014 the array a. It is guaranteed that all elements of a are pairwise distinct.\nThe second line of each test case contains n integers b1, b2, \u2026, bn (1\u2264bi\u2264109)\u00a0\u2014 the array b.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the number of ways to reorder array a such that ai>bi for all 1\u2264i\u2264n, modulo 109+7.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "math",
            "sortings",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1826B": {
        "title": "B. Lunatic Never Content",
        "description": "You have an array a of n non-negative integers. Let's define f(a,x)=[a1modx,a2modx,\u2026,anmodx] for some positive integer x. Find the biggest x, such that f(a,x) is a palindrome.\nHere, amodx is the remainder of the integer division of a by x.\nAn array is a palindrome if it reads the same backward as forward. More formally, an array a of length n is a palindrome if for every i (1\u2264i\u2264n) ai=an\u2212i+1.\nThe first line contains a single integer t (1\u2264t\u2264105) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105).\nThe second line of each test case contains n integers ai (0\u2264ai\u2264109).\nIt's guaranteed that the sum of all n does not exceed 105.\nFor each test case output the biggest x, such that f(a,x) is a palindrome. If x can be infinitely large, output 0 instead.\nIn the first example, f(a,x=1)=[0,0] which is a palindrome.\nIn the second example, f(a,x=2)=[1,0,1,0,0,1,0,1] which is a palindrome.\nIt can be proven that in the first two examples, no larger x satisfies the condition.\nIn the third example, f(a,x)=[0] for any x, so we can choose it infinitely large, so the answer is 0.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1826A": {
        "title": "A. Trust Nobody",
        "description": "There is a group of nn people. Some of them might be liars, who always tell lies. Other people always tell the truth. The i-th person says \"There are at least li liars amongst us\". Determine if what people are saying is contradictory, or if it is possible. If it is possible, output the number of liars in the group. If there are multiple possible answers, output any one of them.\nThe first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100).\nThe second line of each test case contains n integers li (0\u2264li\u2264n) \u2014 the number said by the i-th person.\nIt's guaranteed that the sum of all n does not exceed 104.\nFor each test case output a single integer. If what people are saying is contradictory, output \u22121. Otherwise, output the number of liars in the group. If there are multiple possible answers, output any one of them.\nIn the first example, the only possible answer is that the second person is a liar, so the answer is 1 liar.\nIn the second example, it can be proven that we can't choose the liars so that all the requirements are satisfied.\nIn the third example, everybody tells the truth, so the answer is 0 liars.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1825B": {
        "title": "B. LuoTianyi and the Table",
        "description": "LuoTianyi gave an array b of n\u22c5m integers. She asks you to construct a table a of size n\u00d7m, filled with these n\u22c5m numbers, and each element of the array must be used exactly once. Also she asked you to maximize the following value:\nThis means that we consider n\u22c5m subtables with the upper left corner in (1,1) and the bottom right corner in (i,j) (1\u2264i\u2264n, 1\u2264j\u2264m), for each such subtable calculate the difference of the maximum and minimum elements in it, then sum up all these differences. You should maximize the resulting sum.\nHelp her find the maximal possible value, you don't need to reconstruct the table itself.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264200) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers n and m (2\u2264n,m\u2264100) \u2014 the number of rows and columns of the table.\nThe second line of each test case contains n\u22c5m integers b1,b2,\u2026,bn\u22c5m (\u2212105\u2264bi\u2264105) \u2014 the numbers you can put in the table.\nNote, that integers in the array b can be negative.\nIt is guaranteed that the sum of n\u22c5m over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output a single integer \u2014 the maximal value, that can be obtained.\nIn the first test case, the table is follows:\n\n\nIn the subtable with the bottom right corner in (1,1), the difference of the maximal and minimal elements is 4\u22124=0.\nIn the subtable with the bottom right corner in (1,2), the difference of the maximal and minimal elements is 4\u22121=3.\nIn the subtable with the bottom right corner in (2,1), the difference of the maximal and minimal elements is 4\u22121=3.\nIn the subtable with the bottom right corner in (2,2), the difference of the maximal and minimal elements is 4\u22121=3.\nThen the maximum possible value is 0+3+3+3=9.\nIn the second test case, all elements are equal, so all differences are 0, and the answer is 0.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1822D": {
        "title": "D. Super-Permutation",
        "description": "A permutation is a sequence nn integers, where each integer from 1 to n appears exactly once. For example, [1], [3,5,2,1,4], [1,3,2] are permutations, while [2,3,2], [4,3,1], [0] are not.\nGiven a permutation a, we construct an array b, where bi=(a1+a2+\u00a0\u2026\u00a0+ai)modn.\nA permutation of numbers [a1,a2,\u2026,an] is called a super-permutation if [b1+1,b2+1,\u2026,bn+1] is also a permutation of length n.\nGrisha became interested whether a super-permutation of length n exists. Help him solve this non-trivial problem. Output any super-permutation of length n, if it exists. Otherwise, output \u22121.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nEach test case consists of a single line containing one integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the desired permutation.\nThe sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output in a separate line:\nIf there are several suitable permutations, output any of them.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1821B": {
        "title": "B. Sort the Subarray",
        "description": "Monocarp had an array a consisting of n integers. He has decided to choose two integers l and r such that 1\u2264l\u2264r\u2264n, and then sort the subarray a[l..r] (the subarray a[l..r] is the part of the array a containing the elements al,al+1,al+2,\u2026,ar\u22121,ar) in non-descending order. After sorting the subarray, Monocarp has obtained a new array, which we denote as a\u2032.\nFor example, if a=[6,7,3,4,4,6,5], and Monocarp has chosen l=2,r=5, then a\u2032=[6,3,4,4,7,6,5].\nYou are given the arrays a and a\u2032. Find the integers l and r that Monocarp could have chosen. If there are multiple pairs of values (l,r), find the one which corresponds to the longest subarray.\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of three lines:\nAdditional constraints on the input:\nFor each test case, print two integers \u2014 the values of l and r (1\u2264l\u2264r\u2264n). If there are multiple answers, print the values that correspond to the longest subarray. If there are still multiple answers, print any of them.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1820B": {
        "title": "B. JoJo's Incredible Adventures",
        "description": "Did you think there was going to be a JoJo legend here? But no, that was me, Dio!\nGiven a binary string s of length n, consisting of characters 0 and 1. Let's build a square table of size n\u00d7n, consisting of 0 and 1 characters as follows.\nIn the first row of the table write the original string s. In the second row of the table write cyclic shift of the string s by one to the right. In the third row of the table, write the cyclic shift of line s by two to the right. And so on. Thus, the row with number k will contain a cyclic shift of string s by k to the right. The rows are numbered from 0 to n\u22121 top-to-bottom.\nIn the resulting table we need to find the rectangle consisting only of ones that has the largest area.\nWe call a rectangle the set of all cells (i,j) in the table, such that x1\u2264i\u2264x2 and y1\u2264j\u2264y2 for some integers 0\u2264x1\u2264x2<n and 0\u2264y1\u2264y2<n.\nRecall that the cyclic shift of string s by k to the right is the string sn\u2212k+1\u2026sns1s2\u2026sn\u2212k. For example, the cyclic shift of the string \"01011\" by 0 to the right is the string itself \"01011\", its cyclic shift by 3 to the right is the string \"01101\".\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642\u22c5104)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first and the only line of each test case contains a single binary string s (1\u2264|s|\u22642\u22c5105), consisting of characters 0 and 1.\nIt is guaranteed that the sum of string lengths |s| over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the maximum area of a rectangle consisting only of ones. If there is no such rectangle, output 0.\nIn the first test case, there is a table 1\u00d71 consisting of a single character 0, so there are no rectangles consisting of ones, and the answer is 0.\nIn the second test case, there is a table 1\u00d71, consisting of a single character 1, so the answer is 1.\nIn the third test case, there is a table:\nIn the fourth test case, there is a table:\nIn the fifth test case, there is a table:\nRectangles with maximum area are shown in bold.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "strings",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1816B": {
        "title": "B. Grid Reconstruction",
        "description": "Consider a 2\u00d7n grid, where n is an even integer. You may place the integers 1,2,\u2026,2n on the grid, using each integer exactly once.\nA path is a sequence of cells achieved by starting at (1,1), then repeatedly walking either downwards or to the right, and stopping when (2,n) is reached. The path should not extend beyond the grid.\nThe cost of a path is the alternating sum of the numbers written on the cells in a path. That is, let the numbers written on the cells be a1,a2,\u2026,ak (in the order that it is visited), the cost of the path is a1\u2212a2+a3\u2212a4+\u2026=\u2211ki=1ai\u22c5(\u22121)i+1.\nConstruct a way to place the integers 1,2,\u2026,2n on the grid, such that the minimum cost over all paths from (1,1) to (2,n) is maximized. If there are multiple such grids that result in the maximum value, output any of them.\nThe first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases. The description of test cases follows.\nThe first and the only line of each test case contains a single integer n (2\u2264n\u2264105, n is even) \u2014 the number of the columns in the grid.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output 2 lines, each containing n integers \u2014 the desired grid. If there are multiple solutions, output any of them.\nIn the first test case, there are only two paths from cell (1,1) to cell (2,2). Their costs are 3\u22121+4=6 and 3\u22122+4=5. Then the minimum cost is 5, which is the maximum possible value.\nIn the second test case, there are four paths from cell (1,1) to cell (2,4). Their costs are 8\u22121+5\u22123+7=16, 8\u22122+5\u22123+7=15, 8\u22122+6\u22123+7=16, and 8\u22122+6\u22124+7=15. Then the minimum value is 15, which is the maximum possible value.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1811C": {
        "title": "C. Restore the Array",
        "description": "Kristina had an array a of length n consisting of non-negative integers.\nShe built a new array b of length n\u22121, such that bi=max(ai,ai+1) (1\u2264i\u2264n\u22121).\nFor example, suppose Kristina had an array a = [3,0,4,0,5] of length 5. Then she did the following: \nYou only know the array b. Find any matching array a that Kristina may have originally had.\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains one integer n (2\u2264n\u22642\u22c5105) \u2014 the number of elements in the array a that Kristina originally had.\nThe second line of each test case contains exactly n\u22121 non-negative integer \u2014 elements of array b (0\u2264bi\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105, and that array b was built correctly from some array a.\nFor each test case on a separate line, print exactly n non-negative integers \u2014 the elements of the array a that Kristina originally had.\nIf there are several possible answers \u2014 output any of them.\nThe first test case is explained in the problem statement.\nIn the second test case, we can get array b = [2,2,1] from the array a = [2,2,1,1]: \nIn the third test case, all elements of the array b are zeros. Since each bi is the maximum of two adjacent elements of array a, array a can only consist entirely of zeros.\nIn the fourth test case, we can get array b = [0,3,4,4,3] from the array a = [0,0,3,4,3,3] : ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1811B": {
        "title": "B. Conveyor Belts",
        "description": "Conveyor matrix mn is matrix of size n\u00d7n, where n is an even number. The matrix consists of concentric ribbons moving clockwise.\nIn other words, the conveyor matrix for n=2 is simply a matrix 2\u00d72, whose cells form a cycle of length 4 clockwise. For any natural k\u22652, the matrix m2k is obtained by adding to the matrix m2k\u22122 an outer layer forming a clockwise cycle.\nYou are standing in a cell with coordinates x1,y1 and you want to get into a cell with coordinates x2,y2. A cell has coordinates x,y if it is located at the intersection of the xth row and the yth column.\nStanding on some cell, every second you will move to the cell next in the direction of movement of the tape on which you are. You can also move to a neighboring cell by spending one unit of energy. Movements happen instantly and you can make an unlimited number of them at any time.\nYour task is to find the minimum amount of energy that will have to be spent to get from the cell with coordinates x1,y1 to the cell with coordinates x2,y2.\nFor example, n=8 initially you are in a cell with coordinates 1,3 and you want to get into a cell with coordinates 6,4. You can immediately make 2 movements, once you are in a cell with coordinates 3,3, and then after 8 seconds you will be in the right cell.\nThe first line contains an integer t (1\u2264t\u22642\u22c5105) \u2014 the number of test cases.\nThe descriptions of the test cases follow.\nThe description of each test case consists of one string containing five integers n, x1, y1, x2 and y2 (1\u2264x1,y1,x2,y2\u2264n\u2264109) \u2014 matrix size and the coordinates of the start and end cells. It is guaranteed that the number n is even.\nFor each test case, print one integer in a separate line \u2014 the minimum amount of energy that will have to be spent to get from the cell with coordinates x1,y1 to the cell with coordinates x2,y2.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1809B": {
        "title": "B. Points on Plane",
        "description": "You are given a two-dimensional plane, and you need to place n chips on it. \nYou can place a chip only at a point with integer coordinates. The cost of placing a chip at the point (x,y) is equal to |x|+|y| (where |a| is the absolute value of a).\nThe cost of placing n chips is equal to the maximum among the costs of each chip.\nYou need to place n chips on the plane in such a way that the Euclidean distance between each pair of chips is strictly greater than 1, and the cost is the minimum possible.\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Next t cases follow.\nThe first and only line of each test case contains one integer n (1\u2264n\u22641018)\u00a0\u2014 the number of chips you need to place.\nFor each test case, print a single integer\u00a0\u2014 the minimum cost to place n chips if the distance between each pair of chips must be strictly greater than 1.\nIn the first test case, you can place the only chip at point (0,0) with total cost equal to 0+0=0.\nIn the second test case, you can, for example, place chips at points (\u22121,0), (0,1) and (1,0) with costs |\u22121|+|0|=1, |0|+|1|=1 and |0|+|1|=1. Distance between each pair of chips is greater than 1 (for example, distance between (\u22121,0) and (0,1) is equal to \u221a2). The total cost is equal to max(1,1,1)=1.\nIn the third test case, you can, for example, place chips at points (\u22121,\u22121), (\u22121,1), (1,1), (0,0) and (0,2). The total cost is equal to max(2,2,2,0,2)=2.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1808B": {
        "title": "B. Playing in a Casino",
        "description": "Galaxy Luck, a well-known casino in the entire solar system, introduces a new card game.\nIn this game, there is a deck that consists of n cards. Each card has m numbers written on it. Each of the n players receives exactly one card from the deck.\nThen all players play with each other in pairs, and each pair of players plays exactly once. Thus, if there are, for example, four players in total, then six games are played: the first against the second, the first against the third, the first against the fourth, the second against the third, the second against the fourth and the third against the fourth.\nEach of these games determines the winner in some way, but the rules are quite complicated, so we will not describe them here. All that matters is how many chips are paid out to the winner. Let the first player's card have the numbers a1,a2,\u2026,am, and the second player's card\u00a0\u2014 b1,b2,\u2026,bm. Then the winner of the game gets |a1\u2212b1|+|a2\u2212b2|+\u22ef+|am\u2212bm| chips from the total pot, where |x| denotes the absolute value of x.\nTo determine the size of the total pot, it is necessary to calculate the winners' total winnings for all games. Since there can be many cards in a deck and many players, you have been assigned to write a program that does all the necessary calculations.\nEach test consists of several test cases. The first line contains one integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n\u22c5m\u22643\u22c5105)\u00a0\u2014 the number of cards in the deck and the count of numbers on the one card.\nEach of the following n lines of the test case set contains m integers ci,j (1\u2264ci,j\u2264106)\u00a0\u2014 a description of the i-th card.\nIt is guaranteed that the total n\u22c5m in all tests does not exceed 3\u22c5105.\nFor each test case, print one number\u00a0\u2014 the total amount of winnings from all games.\nConsider the first test case.\nIn the game between the first and second player, the winner receives |1\u22127|+|4\u22129|+|2\u22122|+|8\u22121|+|5\u22124|=19 chips.\nIn the game between the first and third player, the winner receives |1\u22123|+|4\u22128|+|2\u22125|+|8\u22123|+|5\u22121|=18 in chips.\nIn the game between the second and third player, the winner receives |7\u22123|+|9\u22128|+|2\u22125|+|1\u22123|+|4\u22121|=13 chips.\nThe total is 19+18+13=50 chips.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1807G2": {
        "title": "G2. Subsequence Addition (Hard Version)",
        "description": "The only difference between the two versions is that in this version, the constraints are higher.\nInitially, array a contains just the number 1. You can perform several operations in order to change the array. In an operation, you can select some subsequence\u2020 of a and add into a an element equal to the sum of all elements of the subsequence. \nYou are given a final array c. Check if c can be obtained from the initial array a by performing some number (possibly 0) of operations on the initial array.\n\u2020 A sequence b is a subsequence of a sequence a if b can be obtained from a by the deletion of several (possibly zero, but not all) elements. In other words, select k (1\u2264k\u2264|a|) distinct indices i1,i2,\u2026,ik and insert anywhere into a a new element with the value equal to ai1+ai2+\u22ef+aik.\nThe first line of the input contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u00a0\u2014 the number of elements the final array c should have.\nThe second line of each test case contains n space-separated integers ci (1\u2264ci\u22642\u22c5105) \u00a0\u2014 the elements of the final array c that should be obtained from the initial array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output \"YES\" (without quotes) if such a sequence of operations exists, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nFor the first test case, the initial array a is already equal to [1], so the answer is \"YES\".\nFor the second test case, performing any amount of operations will change a to an array of size at least two which doesn't only have the element 2, thus obtaining the array [2] is impossible and the answer is \"NO\".\nFor the third test case, we can perform the following operations in order to obtain the final given array c:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1807G1": {
        "title": "G1. Subsequence Addition (Easy Version)",
        "description": "The only difference between the two versions is that in this version, the constraints are lower.\nInitially, array a contains just the number 1. You can perform several operations in order to change the array. In an operation, you can select some subsequence\u2020 of a and add into a an element equal to the sum of all elements of the subsequence. \nYou are given a final array c. Check if c can be obtained from the initial array a by performing some number (possibly 0) of operations on the initial array.\n\u2020 A sequence b is a subsequence of a sequence a if b can be obtained from a by the deletion of several (possibly zero, but not all) elements. In other words, select k (1\u2264k\u2264|a|) distinct indices i1,i2,\u2026,ik and insert anywhere into a a new element with the value equal to ai1+ai2+\u22ef+aik.\nThe first line of the input contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22645000) \u00a0\u2014 the number of elements the final array c should have.\nThe second line of each test case contains n space-separated integers ci (1\u2264ci\u22645000) \u00a0\u2014 the elements of the final array c that should be obtained from the initial array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 5000.\nFor each test case, output \"YES\" (without quotes) if such a sequence of operations exists, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nFor the first test case, the initial array a is already equal to [1], so the answer is \"YES\".\nFor the second test case, performing any amount of operations will change a to an array of size at least two which doesn't only have the element 2, thus obtaining the array [2] is impossible and the answer is \"NO\".\nFor the third test case, we can perform the following operations in order to obtain the final given array c:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "dp",
            "greedy",
            "implementation",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1804B": {
        "title": "B. Vaccination",
        "description": "Ethan runs a vaccination station to help people combat the seasonal flu. He analyses the historical data in order to develop an optimal strategy for vaccine usage.\nConsider there are n patients coming to the station on a particular day. The i-th patient comes at the moment ti. We know that each of these patients can be asked to wait for no more than w time moments. That means the i-th patient can get vaccine at moments ti,ti+1,\u2026,ti+w.\nVaccines come in packs, each pack consists of k doses. Each patient needs exactly one dose. Packs are stored in a special fridge. After a pack is taken out of the fridge and opened, it can no longer be put back. The lifetime of the vaccine outside the fridge is d moments of time. Thus, if the pack was taken out of the fridge and opened at moment x, its doses can be used to vaccinate patients at moments x,x+1,\u2026,x+d. At moment x+d+1 all the remaining unused doses of this pack are thrown away.\nAssume that the vaccination station has enough staff to conduct an arbitrary number of operations at every moment of time. What is the minimum number of vaccine packs required to vaccinate all n patients?\nThe first line of the input contains the number of test cases t (1\u2264t\u2264104). Then follow t descriptions of the test cases.\nThe first line of each test case contains four integers n, k, d and w (1\u2264n,k\u22642\u22c5105, 0\u2264d,w\u2264106). They are the number of patients, the number of doses per vaccine pack, the number of moments of time the vaccine can live outside the fridge, and the number of moments of time each of the patients can wait, respectively.\nThe second line of each test case contains a non-decreasing sequence t1,t2,\u2026,tn (0\u2264t1\u2264t2\u2264\u2026\u2264tn\u2264106). The i-th element of this sequence is the moment when the i-th patient comes to the vaccination station.\nIt is guaranteed that the sum of n over all test cases won't exceed 2\u22c5105.\nOutput one integer, the minimum number of vaccine packs required to vaccinate all n patients.\nIn the first example, the first pack can be opened at moment 1 to vaccinate patient 1. The vaccine is durable enough to be used at moments 2 and 3 for patients 2 and 3, respectively. Then the staff needs to ask patients 4 and 5 to wait for moment 13. At moment 13 the staff opens the second vaccine pack and serves patients 4 and 5. Finally, the last patient comes at moment 18 and immediately gets the last dose of the second pack while it is still fine.\nIn the second example, the vaccine should be used exactly at the moment it is taken out of the fridge. Moreover, all the patients want to be served at exactly the same moment they come. That means the staff needs to open two packs at moment 3 and use five doses on patients 1, 2, 3, 4, and 5. There will be three doses left ouf of these two packs but they can't be used for patient 6. When patient 6 comes at moment 4 the staff needs to open a new pack just to use only one dose out of it.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1802B": {
        "title": "B. Settlement of Guinea Pigs",
        "description": "Dasha loves guinea pigs very much. In this regard, she decided to settle as many guinea pigs at home as possible and developed a plan for the next n days. Every day, she will either buy a new guinea pig or call a doctor to examine all her pets.\nUnfortunately, the store where she was going to buy guinea pigs does not understand them. Therefore, it cannot determine their gender. Dasha can't do it either. The only one who can help is a doctor. \nTo keep guinea pigs, aviaries are needed. Dasha plans to buy them in the same store. Unfortunately, only one species is sold there \u2014 a double aviary. No more than two guinea pigs can live in it.\nSince Dasha does not want to cause moral injury to her pets \u2014 she will not settle two guinea pigs of different genders in one aviary.\nHelp Dasha calculate how many aviaries in the worst case you need to buy so that you can be sure that at no moment of time do two guinea pigs of different genders live in the same aviary.\nAs part of this task, we believe that guinea pigs have only two genders \u2014 male and female.\nThe first line of input data contains one number t (1\u2a7dt\u2a7d105) \u2014 the number of input data sets.\nThe first line of each input data set contains one number n (1\u2a7dn\u2a7d105) \u2014 the number of days Dasha has a plan for.\nThe next line contains n numbers b1,b2,b3,\u2026,bn (1\u2a7dbi\u2a7d2) \u2014 Dasha's plan. If bi=1, then on the ith day, Dasha will buy a new guinea pig. If bi=2, then on the ith day, a doctor will come to Dasha and help determine the sex of all guinea pigs that Dasha already has.\nIt is guaranteed that the sum of n for all input data sets does not exceed 105.\nFor each set of input data, output one number \u2014 the minimum number of aviaries Dasha needs to buy so that no matter what the genders of the pigs turn out to be, we can settle them so that at no point in time do two guinea pigs of different genders live together.\nIn the first set of input data, Dasha needs to put each guinea pig in a separate enclosure, since she does not know their gender.\nIn the second set of input data, Dasha will buy 0 guinea pigs, which means she will need 0 aviaries.\nIn the third set of input data, you even need 3 aviaries to put each guinea pig in a separate aviary before the doctor arrives at the 4th day. When she finds out their gender, at least two guinea pigs will be of the same gender and they can be placed in one aviary, and the third in another aviary. Thus, she will have one free aviary in which she can settle a new guinea pig. So answer is 3.\nIn the fourth set of input data, we show that 4 is the optimal answer. \nTo begin with, we note that the first four guinea pigs can be placed one at a time in an aviary. Then a doctor will come and determine their gender. Among these four guinea pigs there will be at least one pair of the same gender, because: either male guinea pigs are at least 2, or they are not more than 1, which means that the female is at least 3. Now we can put this couple in one aviary, and the other two in separate ones. We will have one more empty aviary where we can put a new pig.\nNow let's show that the answer is at least 4. Let's say that among the first 4 guinea pigs, 3 are female and 1 is male. We need at least 3 aviaries to settle them. Then, when we buy a new guinea pig, we will need another aviary in which we will put it, since we do not know its gender.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1800D": {
        "title": "D. Remove Two Letters",
        "description": "Dmitry has a string s, consisting of lowercase Latin letters.\nDmitry decided to remove two consecutive characters from the string s and you are wondering how many different strings can be obtained after such an operation.\nFor example, Dmitry has a string \"aaabcc\". You can get the following different strings: \"abcc\"(by deleting the first two or second and third characters), \"aacc\"(by deleting the third and fourth characters),\"aaac\"(by deleting the fourth and the fifth character) and \"aaab\" (by deleting the last two).\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 number of test cases. \nThe descriptions of the test cases follow.\nThe first line of the description of each test case contains an integer n (3\u2264n\u22642\u22c5105).\nThe second line of the description of each test case contains a string s of length n consisting of lowercase Latin letters.\nIt is guaranteed that the sum of n for all test cases does not exceed 2\u22c5105.\nFor each test case print one integer \u2014 the number of distinct strings that can be obtained by removing two consecutive letters.\nThe first example is explained in the statement.\nIn the third example, the following strings are obtained: \"cdef\", \"adef\", \"abef\", \"abcf\", \"abcd\".\nIn the seventh example, any deletion will result in the string \"aba\".",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "hashing",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1800C2": {
        "title": "C2. Powering the Hero (hard version)",
        "description": "This is a hard version of the problem. It differs from the easy one only by constraints on n and t.\nThere is a deck of n cards, each of which is characterized by its power. There are two types of cards:\nYou can do the following with the deck:\nYour task is to use such actions to gather an army with the maximum possible total power.\nThe first line of input data contains single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases in the test.\nThe first line of each test case contains one integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of cards in the deck.\nThe second line of each test case contains n integers s1,s2,\u2026,sn (0\u2264si\u2264109)\u00a0\u2014 card powers in top-down order.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nOutput t numbers, each of which is the answer to the corresponding test case \u2014 the maximum possible total power of the army that can be achieved.\nIn the first sample, you can take bonuses 1 and 2. Both hero cards will receive 3 power. If you take all the bonuses, one of them will remain unused.\nIn the second sample, the hero's card on top of the deck cannot be powered up, and the rest can be powered up with 2 and 3 bonuses and get 6 total power.\nIn the fourth sample, you can take bonuses 1, 2, 3, 5 and skip the bonus 6, then the hero 4 will be enhanced with a bonus 3 by 5, and the hero 7 with a bonus 5 by 4. 4+5=9.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1800C1": {
        "title": "C1. Powering the Hero (easy version)",
        "description": "This is an easy version of the problem. It differs from the hard one only by constraints on n and t.\nThere is a deck of n cards, each of which is characterized by its power. There are two types of cards:\nYou can do the following with the deck:\nYour task is to use such actions to gather an army with the maximum possible total power.\nThe first line of input data contains single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases in the test.\nThe first line of each test case contains one integer n (1\u2264n\u22645000)\u00a0\u2014 the number of cards in the deck.\nThe second line of each test case contains n integers s1,s2,\u2026,sn (0\u2264si\u2264109)\u00a0\u2014 card powers in top-down order.\nIt is guaranteed that the sum of n over all test cases does not exceed 5000.\nOutput t numbers, each of which is the answer to the corresponding test case \u2014 the maximum possible total power of the army that can be achieved.\nIn the first sample, you can take bonuses 1 and 2. Both hero cards will receive 3 power. If you take all the bonuses, one of them will remain unused.\nIn the second sample, the hero's card on top of the deck cannot be powered up, and the rest can be powered up with 2 and 3 bonuses and get 6 total power.\nIn the fourth sample, you can take bonuses 1, 2, 3, 5 and skip the bonus 6, then the hero 4 will be enhanced with a bonus 3 by 5, and the hero 7 with a bonus 5 by 4. 4+5=9.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1800B": {
        "title": "B. Count the Number of Pairs",
        "description": "Kristina has a string ss of length n, consisting only of lowercase and uppercase Latin letters. For each pair of lowercase letter and its matching uppercase letter, Kristina can get 1 burl. However, pairs of characters cannot overlap, so each character can only be in one pair.\nFor example, if she has the string s = \"aAaaBACacbE\", she can get a burl for the following character pairs: \nKristina wants to get more burles for her string, so she is going to perform no more than k operations on it. In one operation, she can:\nFor example, when k = 2 and s = \"aAaaBACacbE\" it can perform one operation: choose s3 = \"a\" and make it uppercase. Then she will get another pair of s3 = \"A\" and s8 = \"a\"\nFind maximum number of burles Kristina can get for her string.\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains two integers n (1\u2264n\u22642\u22c5105) and k (0\u2264k\u2264n) \u2014 the number of characters in the string and the maximum number of operations that can be performed on it.\nThe second line of each test case contains a string s of length n, consisting only of lowercase and uppercase Latin letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print exactly one integer on a separate line: the maximum number of burles that Kristina can get for her string s.\nThe first test case is explained in the problem statement.\nIn the second test case, it is not possible to get any pair by performing any number of operations.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1799B": {
        "title": "B. Equalize by Divide",
        "description": "You are given an array a1,a2,\u2026,an of positive integers.\nYou can make this operation multiple (possibly zero) times:\nIs it possible to make all array elements equal by some sequence of operations (possibly empty)? If yes, print any way to do it in at most 30n operations.\nIt can be proven, that under the problem constraints, if some way exists to make all elements equal, there exists a way with at most 30n operations.\nThe first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases. Descriptions of test cases follow.\nThe first line of each test case description contains a single integer n (1\u2264n\u2264100).\nThe second line of each test case description contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed, that the sum of n for all test cases does not exceed 1000.\nFor each test case print a single integer q (\u22121\u2264q\u226430n). If q=\u22121, there is no solution, otherwise q is equal to the number of operations.\nIf q\u22650, on the next q lines print two integers i, j (1\u2264i,j\u2264n, i\u2260j) \u2014 descriptions of operations.\nIf there are multiple solutions, you can print any.\nIn the first and second, fourth test cases all numbers are equal, so it is possible to do nothing.\nIn the third test case, it is impossible to make all numbers equal.\nIn the fifth test case: [4,3,2]\u2192[2,3,2]\u2192[2,2,2].\nIn the sixth test case: [3,3,4,4]\u2192[3,3,2,4]\u2192[3,3,2,2]\u2192[2,3,2,2]\u2192[2,2,2,2].\nHere the red numbers are i indices (that will be assigned), blue numbers are j indices.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1798B": {
        "title": "B. Three Sevens",
        "description": "Lottery \"Three Sevens\" was held for m days. On day i, ni people with the numbers ai,1,\u2026,ai,ni participated in the lottery.\nIt is known that in each of the m days, only one winner was selected from the lottery participants. The lottery winner on day i was not allowed to participate in the lottery in the days from i+1 to m.\nUnfortunately, the information about the lottery winners has been lost. You need to find any possible list of lottery winners on days from 1 to m or determine that no solution exists.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u226450000). The description of the test cases follows.\nThe first line of each test case contains a single integer m (1\u2264m\u226450000)\u00a0\u2014 the number of days in which the lottery was held.\nNext, for each i from 1 to m, follows a two-line block of data.\nThe first line of each block contains a single integer ni (1\u2264ni\u226450000)\u00a0\u2014 the number of lottery participants on day i.\nThe second line of the block contains integers ai,1,\u2026,ai,ni (1\u2264ai,j\u226450000)\u00a0\u2014 lottery participants on day i. It is guaranteed that all the numbers ai,1,\u2026,ai,ni are pairwise distinct.\nIt is guaranteed that the sum of ni over all blocks of all test cases does not exceed 50000.\nFor each test case, if there is no solution, print a single integer \u22121.\nOtherwise, print m integers p1,p2,\u2026,pm (1\u2264pi\u226450000)\u00a0\u2014 lottery winners on days from 1 to m. If there are multiple solutions, print any of them.\nIn the first test case, one of the answers is [8,2,1] since the participant with the number 8 participated on day 1, but did not participate on days 2 and 3; the participant with the number 2 participated on day 2, but did not participate on day 3; and the participant with the number 1 participated on day 3. Note that this is not the only possible answer, for example, [8,9,4] is also a correct answer.\nIn the second test case, both lottery participants participated on both days, so any possible lottery winner on the day 1 must have participated on the day 2, which is not allowed. Thus, there is no correct answer.\nIn the third test case, only one participant participated on days 2, 3, 4, and on day 1 there is only one participant who did not participate in the lottery on days 2,3,4\u00a0\u2014 participant 2, which means [2,1,4,3] is the only correct answer to this test case.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1797B": {
        "title": "B. Li Hua and Pattern",
        "description": "Li Hua has a pattern of size n\u00d7n, each cell is either blue or red. He can perform exactly k operations. In each operation, he chooses a cell and changes its color from red to blue or from blue to red. Each cell can be chosen as many times as he wants. Is it possible to make the pattern, that matches its rotation by 180\u2218?\nSuppose you were Li Hua, please solve this problem.\nThe first line contains the single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n,k (1\u2264n\u2264103,0\u2264k\u2264109)\u00a0\u2014 the size of the pattern and the number of operations.\nEach of next n lines contains n integers ai,j (ai,j\u2208{0,1})\u00a0\u2014 the initial color of the cell, 0 for blue and 1 for red.\nIt's guaranteed that sum of n over all test cases does not exceed 103.\nFor each set of input, print \"YES\" if it's possible to make the pattern, that matches its rotation by 180\u2218 after applying exactly k of operations, and \"NO\" otherwise.\nYou can output the answer in any case (upper or lower). For example, the strings \"yEs\", \"yes\", \"Yes\", and \"YES\" will be recognized as positive responses.\nIn test case 1, you can't perform any operation. The pattern after rotation is on the right.\nIn test case 2, you can perform operations on (2,1),(3,2),(3,4). The pattern after operations is in the middle and the pattern after rotation is on the right.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1796B": {
        "title": "B. Asterisk-Minor Template",
        "description": "You are given two strings a and b, consisting of lowercase Latin letters.\nA template t is string, consisting of lowercase Latin letters and asterisks (character '*'). A template is called asterisk-minor if the number of asterisks in it is less than or equal to the number of letters in it.\nA string s is said to be matching a template t if you can replace each asterisk in t with a string of lowercase Latin letters (possibly, an empty string) so that it becomes equal to s.\nFind an asterisk-minor template such that both a and b match it, or report that such a template doesn't exist. If there are multiple answers, print any of them.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a string a (1\u2264|a|\u226450, where |a| is the length of a), consisting of lowercase Latin letters.\nThe second line contains a string b (1\u2264|b|\u226450), consisting of lowercase Latin letters.\nFor each testcase, output \"NO\", if there doesn't exist an asterisk-minor template that both a and b match. Otherwise, print \"YES\" in the first line and the template in the second line. If there are multiple answers, print any of them.\nA template should consist only of lowercase Latin letters and asterisks (character '*'). The number of asterisks should be less than or equal to the number of letters.\nIn the first testcase, for a template \"*b\", you can replace the only asterisk with \"aaa\" to get \"aaab\" (which is equal to a) or with \"zzz\" to get \"zzzb\" (which is equal to b).\nIn the third testcase, a template \"*o*\" is not asterisk-minor, as it contains more asterisks than letters. There are no asterisk-minor templates that both a and b match.\nIn the fourth testcase, for a template \"a*a*a*a\", you can replace all asterisks with empty strings to get \"aaaa\" (which is equal to a) or two of them with \"a\" and two of them with an empty string to get \"aaaaaa\" (which is equal to b).\nIn the fifth testcase, there are no asterisks in a template \"abcd\", so only \"abcd\" can match it (which is coincidentally both a and b).",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1793C": {
        "title": "C. Dora and Search",
        "description": "As you know, the girl Dora is always looking for something. This time she was given a permutation, and she wants to find such a subsegment of it that none of the elements at its ends is either the minimum or the maximum of the entire subsegment. More formally, you are asked to find the numbers l and r (1\u2264l\u2264r\u2264n) such that al\u2260min(al,al+1,\u2026,ar), al\u2260max(al,al+1,\u2026,ar) and ar\u2260min(al,al+1,\u2026,ar), ar\u2260max(al,al+1,\u2026,ar).\nA permutation of length n is an array consisting of n distinct integers from 1 to n in any order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 occurs twice in the array) and [1,3,4] is also not a permutation (n=3, but 4 is present in the array).\nHelp Dora find such a subsegment, or tell her that such a subsegment does not exist.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of the test cases follows.\nFor each test case, the first line contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the length of permutation.\nThe second line contains n distinct integers a1,a2,\u2026,an (1\u2264ai\u2264n) \u2014 the elements of permutation. \nIt is guarented that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output \u22121 if the desired subsegment does not exist.\nOtherwise, output two indexes l,r such that [al,al+1,\u2026,ar] satisfies all conditions.\nIf there are several solutions, then output any of them.\nIn the first and fourth test cases, it can be shown that there are no desired subsegments.\nIn the second test case, the subsegment [1,4] satisfies all the conditions, because max(a1,a2,a3,a4)=4,min(a1,a2,a3,a4)=1, as we see, all the conditions are met.\nIn the third test case, the subsegment [2,6] also satisfies all the conditions described.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "two pointers",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1793B": {
        "title": "B. Fedya and Array",
        "description": "For his birthday recently Fedya was given an array a of n integers arranged in a circle, For each pair of neighboring numbers (a1 and a2, a2 and a3, \u2026, an\u22121 and an, an and a1) the absolute difference between them is equal to 1.\nLet's call a local maximum an element, which is greater than both of its neighboring elements. Also call a local minimum an element, which is less than both of its neighboring elements. Note, that elements a1 and an are neighboring elements.\nUnfortunately, Fedya lost an array, but he remembered in it the sum of local maximums x and the sum of local minimums y.\nGiven x and y, help Fedya find any matching array of minimum length.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nEach line of each test case contain two integers x and y (\u2212109\u2264y<x\u2264109) \u2014 the sum of local maximums and the sum of local minimums, respectively.\nFor each test case, in the first line print one integer n \u2014 the minimum length of matching arrays.\nIn the second line print n integers a1,a2,\u2026,an (\u2212109\u2a7dai\u2a7d109) \u2014 the array elements such that the the absolute difference between each pair of neighboring is equal to 1.\nIf there are multiple solutions, print any of them.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nIn the first test case, the local maximums are the numbers at 3,7 and 10 positions, and the local minimums are the numbers at 1,6 and 8 positions. x=a3+a7+a10=2+0+1=3, y=a1+a6+a8=0+(\u22121)+(\u22121)=\u22122.\nIn the second test case, the local maximums are the numbers at 2 and 10 positions, and the local minimums are the numbers at 1 and 3 positions. x=a2+a10=\u22121+5=4, y=a1+a3=\u22122+(\u22122)=\u22124.\nIn the third test case, the local maximums are the numbers at 1 and 5 positions, and the local minimums are the numbers at 3 and 6 positions.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1792B": {
        "title": "B. Stand-up Comedian",
        "description": "Eve is a beginner stand-up comedian. Her first show gathered a grand total of two spectators: Alice and Bob.\nEve prepared a1+a2+a3+a4a1+a2+a3+a4 jokes to tell, grouped by their type: \nInitially, both spectators have their mood equal to 0. When a spectator hears a joke he/she likes, his/her mood increases by 1. When a spectator hears a joke he/she doesn't like, his/her mood decreases by 1. If the mood of a spectator becomes negative (strictly below zero), he/she leaves.\nWhen someone leaves, Eve gets sad and ends the show. If no one leaves, and Eve is out of jokes, she also ends the show.\nThus, Eve wants to arrange her jokes in such a way that the show lasts as long as possible. Help her to calculate the maximum number of jokes she can tell before the show ends.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe only line of each testcase contains four integers a1,a2,a3,a4 (0\u2264a1,a2,a3,a4\u2264108; a1+a2+a3+a4\u22651)\u00a0\u2014 the number of jokes of each type Eve prepared.\nFor each testcase, print a single integer\u00a0\u2014 the maximum number of jokes Eve can tell before at least one of the spectators leaves or before she runs out of jokes.\nIn the first testcase, Eve only has jokes of the first type. Thus, there's no order to choose. She tells all her jokes, both Alice and Bob like them. Their mood becomes 5. The show ends after Eve runs out of jokes.\nIn the second testcase, Eve only has jokes of the fourth type. Thus, once again no order to choose. She tells a joke, and neither Alice, nor Bob likes it. Their mood decrease by one, becoming \u22121. They both have negative mood, thus, both leave, and the show ends.\nIn the third testcase, first, Eve tells both jokes of the first type. Both Alice and Bob has mood 2. Then she can tell 2 jokes of the third type. Alice's mood becomes 0. Bob's mood becomes 4. Then 4 jokes of the second type. Alice's mood becomes 4. Bob's mood becomes 0. Then another 4 jokes of the third type. Alice's mood becomes 0. Bob's mood becomes 4. Then the remaining joke of the second type. Alice's mood becomes 1. Bob's mood becomes 3. Then one more joke of the third type, and a joke of the fourth type, for example. Alice's mood becomes \u22121, she leaves, and the show ends. \nIn the fourth testcase, Eve should first tell the jokes both spectators like, then the jokes they don't. She can tell 4 jokes of the fourth type until the spectators leave.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1791G1": {
        "title": "G1. Teleporters (Easy Version)",
        "description": "The only difference between the easy and hard versions are the locations you can teleport to.\nConsider the points 0,1,\u2026,n on the number line. There is a teleporter located on each of the points 1,2,\u2026,n. At point i, you can do the following:\nYou have c coins, and you start at point 0. What's the most number of teleporters you can use?\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains two integers n and c (1\u2264n\u22642\u22c5105; 1\u2264c\u2264109) \u00a0\u2014 the length of the array and the number of coins you have respectively.\nThe following line contains n space-separated integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the costs to use the teleporters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the maximum number of teleporters you can use.\nIn the first test case, you can move one unit to the right, use the teleporter at index 1 and teleport to point 0, move two units to the right and use the teleporter at index 2. You are left with 6\u22121\u22121\u22122\u22121=1 coins you don't have enough coins to use another teleporter. You have used two teleporters, so the answer is two.\nIn the second test case, you go four units to the right and use the teleporter to go to 0, then go six units right and use the teleporter at index 6 to go to 0. The total cost will be 4+6+6+4=20. You are left with 12 coins, but it is not enough to reach any other teleporter and use it so the answer is 2.\nIn the third test case, you don't have enough coins to use any teleporter, so the answer is zero.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1791E": {
        "title": "E. Negatives and Positives",
        "description": "Given an array a consisting of n elements, find the maximum possible sum the array can have after performing the following operation any number of times: \nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The descriptions of the test cases follow.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe following line contains n space-separated integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the maximum possible sum the array can have after performing the described operation any number of times.\nFor the first test case, by performing the operation on the first two elements, we can change the array from [\u22121,\u22121,\u22121] to [1,1,\u22121], and it can be proven this array obtains the maximum possible sum which is 1+1+(\u22121)=1.\nFor the second test case, by performing the operation on \u22125 and 0, we change the array from [1,5,\u22125,0,2] to [1,5,\u2212(\u22125),\u22120,2]=[1,5,5,0,2], which has the maximum sum since all elements are non-negative. So, the answer is 1+5+5+0+2=13.\nFor the third test case, the array already contains only positive numbers, so performing operations is unnecessary. The answer is just the sum of the whole array, which is 1+2+3=6.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1791D": {
        "title": "D. Distinct Split",
        "description": "Let's denote the f(x) function for a string x as the number of distinct characters that the string contains. For example f(abc)=3, f(bbbbb)=1, and f(babacaba)=3.\nGiven a string s, split it into two non-empty strings a and b such that f(a)+f(b) is the maximum possible. In other words, find the maximum possible value of f(a)+f(b) such that a+b=s (the concatenation of string a and string b is equal to string s).\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the string s.\nThe second line contains the string s, consisting of lowercase English letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u00a0\u2014 the maximum possible value of f(a)+f(b) such that a+b=s.\nFor the first test case, there is only one valid way to split aa into two non-empty strings a and a, and f(a)+f(a)=1+1=2.\nFor the second test case, by splitting abcabcd into abc and abcd we can get the answer of f(abc)+f(abcd)=3+4=7 which is maximum possible.\nFor the third test case, it doesn't matter how we split the string, the answer will always be 2.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "strings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1790D": {
        "title": "D. Matryoshkas",
        "description": "Matryoshka is a wooden toy in the form of a painted doll, inside which you can put a similar doll of a smaller size.\nA set of nesting dolls contains one or more nesting dolls, their sizes are consecutive positive integers. Thus, a set of nesting dolls is described by two numbers: s \u2014 the size of a smallest nesting doll in a set and m \u2014 the number of dolls in a set. In other words, the set contains sizes of s,s+1,\u2026,s+m\u22121 for some integer s and m (s,m>0).\nYou had one or more sets of nesting dolls. Recently, you found that someone mixed all your sets in one and recorded a sequence of doll sizes \u2014 integers a1,a2,\u2026,an.\nYou do not remember how many sets you had, so you want to find the minimum number of sets that you could initially have.\nFor example, if a given sequence is a=[2,2,3,4,3,1]. Initially, there could be 2 sets: \nAccording to a given sequence of sizes of nesting dolls a1,a2,\u2026,an, determine the minimum number of nesting dolls that can make this sequence.\nEach set is completely used, so all its nesting dolls are used. Each element of a given sequence must correspond to exactly one doll from some set.\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains one integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the total number of matryoshkas that were in all sets.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u00a0\u2014 the sizes of the matryoshkas. \nIt is guaranteed that the sum of values of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print one integer k \u2014 the minimum possible number of matryoshkas sets.\nThe first test case is described in the problem statement.\nIn the second test case, all matryoshkas could be part of the same set with minimum size s=7.\nIn the third test case, each matryoshka represents a separate set.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1790C": {
        "title": "C. Premutation",
        "description": "A sequence of n numbers is called permutation if it contains all integers from 1 to n exactly once. For example, the sequences [3,1,4,2], [1] and [2,1] are permutations, but [1,2,1], [0,1] and [1,3,4]\u00a0\u2014 are not.\nKristina had a permutation p of n elements. She wrote it on the whiteboard n times in such a way that: \nFor example, suppose Kristina had a permutation p = [4,2,1,3] of length 4. Then she did the following: \nYou know all n of sequences that have been written on the whiteboard, but you do not know the order in which they were written. They are given in arbitrary order. Reconstruct the original permutation from them.\nFor example, if you know the sequences [4,2,1], [4,2,3], [2,1,3], [4,1,3], then the original permutation will be p = [4,2,1,3].\nThe first line of input data contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe description of the test cases follows.\nThe first line of each test case contains one integer n (3\u2264n\u2264100).\nThis is followed by n lines, each containing exactly n\u22121 integers and describing one of the sequences written out on the whiteboard.\nIt is guaranteed that all sequences could be obtained from some permutation p, and that the sum n2 over all input sets does not exceed 2\u22c5105.\nFor each test case, output on a separate line a permutation p such that the given n sequences could be obtained from it.\nIt is guaranteed that the answer exists and it is the only one. In other words, for each test case the required permutation is sure to exist.\nThe first test case is described in the problem statement.\nIn the second test case, the sequences are written in the correct order.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1788B": {
        "title": "B. Sum of Two Numbers",
        "description": "The sum of digits of a non-negative integer a is the result of summing up its digits together when written in the decimal system. For example, the sum of digits of 123 is 6 and the sum of digits of 10 is 1. In a formal way, the sum of digits of a=\u221e\u2211i=0ai\u22c510i, where 0\u2264ai\u22649, is defined as \u221e\u2211i=0ai.\nGiven an integer n, find two non-negative integers x and y which satisfy the following conditions.\nIt can be shown that such x and y always exist.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u226410000). \nEach test case consists of a single integer n (1\u2264n\u2264109)\nFor each test case, print two integers x and y.\nIf there are multiple answers, print any.\nIn the second test case, the sum of digits of 67 and the sum of digits of 94 are both 13.\nIn the third test case, the sum of digits of 60 is 6, and the sum of digits of 7 is 7.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "probabilities",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1787B": {
        "title": "B. Number Factorization",
        "description": "Given an integer n.\nConsider all pairs of integer arrays a and p of the same length such that n=\u220fapii (i.e. ap11\u22c5ap22\u22c5\u2026) (ai>1;pi>0) and ai is the product of some (possibly one) distinct prime numbers.\nFor example, for n=28=22\u22c571=41\u22c571 the array pair a=[2,7], p=[2,1] is correct, but the pair of arrays a=[4,7], p=[1,1] is not, because 4=22 is a product of non-distinct prime numbers.\nYour task is to find the maximum value of \u2211ai\u22c5pi (i.e. a1\u22c5p1+a2\u22c5p2+\u2026) over all possible pairs of arrays a and p. Note that you do not need to minimize or maximize the length of the arrays.\nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u22641000) \u2014 the number of test cases. \nEach test case contains only one integer n (2\u2264n\u2264109).\nFor each test case, print the maximum value of \u2211ai\u22c5pi.\nIn the first test case, 100=102 so that a=[10], p=[2] when \u2211ai\u22c5pi hits the maximum value 10\u22c52=20. Also, a=[100], p=[1] does not work since 100 is not made of distinct prime factors.\nIn the second test case, we can consider 10 as 101, so a=[10], p=[1]. Notice that when 10=21\u22c551, \u2211ai\u22c5pi=7.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1784A": {
        "title": "A. Monsters (easy version)",
        "description": "This is the easy version of the problem. In this version, you only need to find the answer once. In this version, hacks are not allowed.\nIn a computer game, you are fighting against n monsters. Monster number i has ai health points, all ai are integers. A monster is alive while it has at least 1 health point.\nYou can cast spells of two types:\nDealing 1 damage to a monster reduces its health by 1.\nSpells of type 1 can be cast any number of times, while a spell of type 2 can be cast at most once during the game.\nWhat is the smallest number of times you need to cast spells of type 1 to kill all monsters?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nEach test case consists of two lines. The first line contains a single integer n\u00a0(1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of monsters.\nThe second line contains n integers a1,a2,\u2026,an\u00a0(1\u2264ai\u2264n)\u00a0\u2014 monsters' health points.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the smallest number of times you need to cast spells of type 1 to kill all monsters.\nIn the first test case, the initial health points of the monsters are [3,1,2]. It is enough to cast a spell of type 2: \nSince it is possible to use no spells of type 1 at all, the answer is 0.\nIn the second test case, the initial health points of the monsters are [4,1,5,4,1,1]. Here is one of the optimal action sequences: \nSpells of type 1 are cast 4 times in total. It can be shown that this is the smallest possible number.",
        "time_limit": "time limit per test4 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1783B": {
        "title": "B. Matrix of Differences",
        "description": "For a square matrix of integers of size n\u00d7nn\u00d7n, let's define its beauty as follows: for each pair of side-adjacent elements x and y, write out the number |x\u2212y|, and then find the number of different numbers among them.\nFor example, for the matrix (1342) the numbers we consider are |1\u22123|=2, |1\u22124|=3, |3\u22122|=1 and |4\u22122|=2; there are 3 different numbers among them (2, 3 and 1), which means that its beauty is equal to 3.\nYou are given an integer n. You have to find a matrix of size n\u00d7n, where each integer from 1 to n2 occurs exactly once, such that its beauty is the maximum possible among all such matrices.\nThe first line contains a single integer t (1\u2264t\u226449)\u00a0\u2013 the number of test cases.\nThe first (and only) line of each test case contains a single integer n (2\u2264n\u226450).\nFor each test case, print n rows of n integers\u00a0\u2014 a matrix of integers of size n\u00d7n, where each number from 1 to n2 occurs exactly once, such that its beauty is the maximum possible among all such matrices. If there are multiple answers, print any of them.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1781B": {
        "title": "B. Going to the Cinema",
        "description": "A company of n people is planning a visit to the cinema. Every person can either go to the cinema or not. That depends on how many other people will go. Specifically, every person i said: \"I want to go to the cinema if and only if at least ai other people will go, not counting myself\". That means that person i will become sad if: \nIn how many ways can a set of people going to the cinema be chosen so that nobody becomes sad?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). The description of the test cases follows.\nEach test case consists of two lines. The first line contains a single integer n\u00a0(2\u2264n\u22642\u22c5105)\u00a0\u2014 the number of people in the company.\nThe second line contains n integers a1,a2,\u2026,an\u00a0(0\u2264ai\u2264n\u22121)\u00a0\u2014 integers from peoples' claims.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the number of different ways to choose a set of people going to the cinema so that nobody becomes sad.\nIn the first test case, both people want to go to the cinema if and only if the other person goes. There are two valid options: either both people go, or neither of them goes. However, if just one of them goes, both will be sad.\nIn the second test case, everyone has to go to the cinema. In any other case, someone will be sad.\nIn the third test case, there are three valid options: person number 2 goes to the cinema; or persons with indices 2,3,4,7 go; or all eight people go.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1780B": {
        "title": "B. GCD Partition",
        "description": "While at Kira's house, Josuke saw a piece of paper on the table with a task written on it.\nThe task sounded as follows. There is an array aa of length n. On this array, do the following:\nThe task is to find such a partition that the score is maximum possible. Josuke is interested in this task but is not strong in computer science. Help him to find the maximum possible score.\n\u2020 A division of an array into k subsegments is k pairs of numbers (l1,r1),(l2,r2),\u2026,(lk,rk) such that li\u2264ri and for every 1\u2264j\u2264k\u22121 lj+1=rj+1, also l1=1 and rk=n. These pairs represent the subsegments.\n\u2021 gcd(b1,b2,\u2026,bk) stands for the greatest common divisor (GCD) of the array b.\nThe first line contains a single number t (1\u2264t\u2264104) \u2014 the number of test cases.\nFor each test case, the first line contains one integer n (2\u2264n\u22642\u22c5105) \u2014 the length of the array a.\nThe second line contains n integers a1,a2,a3,\u2026,an (1\u2264ai\u2264109) \u2014 the array a itself.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case print a single integer \u2014 the maximum score for the optimal partition.\nIn the first test case, you can choose k=2 and split the array into subsegments (1,2) and (3,4).\nThen the score of such a partition will be equal to gcd(a1+a2,a3+a4)=gcd(2+2,1+3)=gcd(4,4)=4.\nIn the fourth test case, you can choose k=3 and split the array into subsegments (1,2),(3,5),(6,6).\nThe split score is gcd(1+2,1+1+1,3)=3.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1772C": {
        "title": "C. Different Differences",
        "description": "An array a consisting of k integers is strictly increasing if a1<a2<\u22ef<ak. For example, the arrays [1,3,5], [1,2,3,4], [3,5,6] are strictly increasing; the arrays [2,2], [3,7,5], [7,4,3], [1,2,2,3] are not.\nFor a strictly increasing array a of k elements, let's denote the characteristic as the number of different elements in the array [a2\u2212a1,a3\u2212a2,\u2026,ak\u2212ak\u22121]. For example, the characteristic of the array [1,3,4,7,8] is 3 since the array [2,1,3,1] contains 3 different elements: 2, 1 and 3.\nYou are given two integers k and n (k\u2264n). Construct an increasing array of k integers from 1 to n with maximum possible characteristic.\nThe first line contains one integer t (1\u2264t\u2264819) \u2014 the number of test cases.\nEach test case consists of one line containing two integers k and n (2\u2264k\u2264n\u226440).\nFor each test case, print k integers \u2014 the elements of the strictly increasing array a with the maximum possible characteristic. If there are multiple answers, print any of them.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1770B": {
        "title": "B. Koxia and Permutation",
        "description": "Reve has two integers n and k.\nLet p be a permutation\u2020 of length n. Let c be an array of length n\u2212k+1 such that ci=max(pi,\u2026,pi+k\u22121)+min(pi,\u2026,pi+k\u22121). Let the cost of the permutation p be the maximum element of c.\nKoxia wants you to construct a permutation with the minimum possible cost.\n\u2020 A permutation of length n is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array), and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers p1,p2,\u2026,pn, which is a permutation with minimal cost. If there is more than one permutation with minimal cost, you may output any of them.\nIn the first test case,\nTherefore, the cost is max(6,4,6)=6. It can be proven that this is the minimal cost.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1770A": {
        "title": "A. Koxia and Whiteboards",
        "description": "Kiyora has nn whiteboards numbered from 1 to n. Initially, the i-th whiteboard has the integer ai written on it.\nKoxia performs m operations. The j-th operation is to choose one of the whiteboards and change the integer written on it to bj.\nFind the maximum possible sum of integers written on the whiteboards after performing all m operations.\nEach test consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u2264100).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nThe third line of each test case contains m integers b1,b2,\u2026,bm (1\u2264bi\u2264109).\nFor each test case, output a single integer \u2014 the maximum possible sum of integers written on whiteboards after performing all m operations.\nIn the first test case, Koxia can perform the operations as follows:\nAfter performing all operations, the numbers on the three whiteboards are 4, 5 and 3 respectively, and their sum is 12. It can be proven that this is the maximum possible sum achievable.\nIn the second test case, Koxia can perform the operations as follows:\nThe sum is 4+5=9. It can be proven that this is the maximum possible sum achievable.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1769C1": {
        "title": "C1. \u041f\u043e\u0434\u043a\u0440\u0443\u0442\u043a\u0430 I",
        "description": "\u0412 \u044d\u0442\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u0437\u0430\u0434\u0430\u0447\u0438 n\u226450 \u0438 ai\u2264100.\n\u0412\u0438\u043a\u0430 \u0437\u0430 \u0432\u0440\u0435\u043c\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0432 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0438 VK \u0443\u0436\u0435 \u0441\u0434\u0435\u043b\u0430\u043b\u0430 n \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u0435 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f \u0432\u0435\u0440\u0441\u0438\u0439. i-\u0439 \u043a\u043e\u043c\u043c\u0438\u0442 \u0431\u044b\u043b \u0441\u0434\u0435\u043b\u0430\u043d \u0432 ai-\u0439 \u0434\u0435\u043d\u044c \u0440\u0430\u0431\u043e\u0442\u044b \u0412\u0438\u043a\u0438 \u0432 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u0438. \u0412 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0434\u043d\u0438 \u0412\u0438\u043a\u0430 \u043c\u043e\u0433\u043b\u0430 \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432, \u0430 \u0432 \u0434\u0440\u0443\u0433\u0438\u0435\u00a0\u2014 \u043d\u0435 \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0438 \u043e\u0434\u043d\u043e\u0433\u043e.\n\u0412\u0438\u043a\u0443 \u0438\u043d\u0442\u0435\u0440\u0435\u0441\u0443\u044e\u0442 \u0442\u0430\u043a\u0438\u0435 \u043e\u0442\u0440\u0435\u0437\u043a\u0438 \u043f\u043e\u0434\u0440\u044f\u0434 \u0438\u0434\u0443\u0449\u0438\u0445 \u0434\u043d\u0435\u0439, \u0447\u0442\u043e \u0432 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u044d\u0442\u0438\u0445 \u0434\u043d\u0435\u0439 \u0443 \u043d\u0435\u0451 \u0435\u0441\u0442\u044c \u0445\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u043a\u043e\u043c\u043c\u0438\u0442. \u0427\u0435\u043c \u0434\u043b\u0438\u043d\u043d\u0435\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u0430\u043c\u044b\u0439 \u0434\u043b\u0438\u043d\u043d\u044b\u0439 \u0442\u0430\u043a\u043e\u0439 \u043e\u0442\u0440\u0435\u0437\u043e\u043a, \u0442\u0435\u043c \u0431\u043e\u043b\u0435\u0435 \u043f\u0440\u043e\u0434\u0443\u043a\u0442\u0438\u0432\u043d\u044b\u043c \u0441\u043e\u0442\u0440\u0443\u0434\u043d\u0438\u043a\u043e\u043c \u043e\u043d\u0430 \u0431\u0443\u0434\u0435\u0442 \u0441\u0435\u0431\u044f \u043e\u0449\u0443\u0449\u0430\u0442\u044c.\n\u041d\u0435\u0434\u0430\u0432\u043d\u043e \u0412\u0438\u043a\u0430 \u043d\u0430\u0448\u043b\u0430 \u0441\u043f\u043e\u0441\u043e\u0431 \u043f\u043e\u0434\u043a\u0440\u0443\u0442\u0438\u0442\u044c \u0432\u0440\u0435\u043c\u044f \u043b\u044e\u0431\u043e\u0433\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u0430 \u0432\u043f\u0435\u0440\u0451\u0434, \u043d\u043e \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 \u0447\u0435\u043c \u043d\u0430 \u0441\u0443\u0442\u043a\u0438. \u0422\u0430\u043a\u0438\u043c \u043e\u0431\u0440\u0430\u0437\u043e\u043c, i-\u0439 \u043a\u043e\u043c\u043c\u0438\u0442 \u0442\u0435\u043f\u0435\u0440\u044c \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u00ab\u0441\u0434\u0435\u043b\u0430\u043d\u00bb \u043b\u0438\u0431\u043e \u0432 ai-\u0439, \u043b\u0438\u0431\u043e \u0432 (ai+1)-\u0439 \u0434\u0435\u043d\u044c. \u0412\u0440\u0435\u043c\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u0430 \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u0434\u043a\u0440\u0443\u0442\u0438\u0442\u044c \u043d\u0435\u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e \u043e\u0442 \u0434\u0440\u0443\u0433\u0438\u0445\u00a0\u2014 \u0432 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438, \u043c\u043e\u0436\u043d\u043e \u043a\u0430\u043a \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0432\u0441\u0435\u043c \u043a\u043e\u043c\u043c\u0438\u0442\u0430\u043c \u0438\u0441\u0445\u043e\u0434\u043d\u043e\u0435 \u0432\u0440\u0435\u043c\u044f, \u0442\u0430\u043a \u0438 \u043f\u0435\u0440\u0435\u043d\u0435\u0441\u0442\u0438 \u0432\u0441\u0435 \u043a\u043e\u043c\u043c\u0438\u0442\u044b \u0440\u043e\u0432\u043d\u043e \u043d\u0430 \u0434\u0435\u043d\u044c \u0432\u043f\u0435\u0440\u0451\u0434.\n\u041d\u0430\u0439\u0434\u0438\u0442\u0435 \u0434\u043b\u0438\u043d\u0443 \u0441\u0430\u043c\u043e\u0433\u043e \u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0433\u043e \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u043f\u043e\u0434\u0440\u044f\u0434 \u0438\u0434\u0443\u0449\u0438\u0445 \u0434\u043d\u0435\u0439, \u0432 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0443 \u0412\u0438\u043a\u0438 \u0432 \u043f\u0440\u043e\u0444\u0438\u043b\u0435 \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0442\u044c\u0441\u044f \u0445\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u043a\u043e\u043c\u043c\u0438\u0442, \u043f\u043e\u0441\u043b\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0439 \u043f\u043e\u0434\u043a\u0440\u0443\u0442\u043a\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432.\n\u041a\u0430\u0436\u0434\u044b\u0439 \u0442\u0435\u0441\u0442 \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0438\u0437 \u043d\u0435\u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u043d\u0430\u0431\u043e\u0440\u043e\u0432 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445. \u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u043e\u0434\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e t (1\u2264t\u2264100)\u00a0\u2014 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u0430\u0431\u043e\u0440\u043e\u0432 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445. \u0414\u0430\u043b\u0435\u0435 \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u043d\u0430\u0431\u043e\u0440\u043e\u0432 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445.\n\u041f\u0435\u0440\u0432\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043d\u0430\u0431\u043e\u0440\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043e\u0434\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e n (1\u2264n\u226450)\u00a0\u2014 \u0447\u0438\u0441\u043b\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432.\n\u0412\u0442\u043e\u0440\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 n \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b a1,a2,\u2026,an \u0432 \u043d\u0435\u0443\u0431\u044b\u0432\u0430\u044e\u0449\u0435\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435 (1\u2264a1\u2264a2\u2264\u2026\u2264an\u2264100)\u00a0\u2014 \u043d\u043e\u043c\u0435\u0440\u0430 \u0434\u043d\u0435\u0439, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u0431\u044b\u043b\u0438 \u0441\u0434\u0435\u043b\u0430\u043d\u044b \u043a\u043e\u043c\u043c\u0438\u0442\u044b.\n\u0414\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u043d\u0430\u0431\u043e\u0440\u0430 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0432\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u043e\u0434\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\u00a0\u2014 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u0443\u044e \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u0443\u044e \u0434\u043b\u0438\u043d\u0443 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0434\u043d\u0435\u0439, \u0432 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u0443 \u0412\u0438\u043a\u0438 \u0432 \u043f\u0440\u043e\u0444\u0438\u043b\u0435 \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0442\u044c\u0441\u044f \u0445\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u043a\u043e\u043c\u043c\u0438\u0442, \u043f\u043e\u0441\u043b\u0435 \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0439 \u043f\u043e\u0434\u043a\u0440\u0443\u0442\u043a\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432 \u0432\u043f\u0435\u0440\u0451\u0434 \u043d\u0435 \u0431\u043e\u043b\u0435\u0435 \u0447\u0435\u043c \u043d\u0430 \u0441\u0443\u0442\u043a\u0438.\n\u0412 \u043f\u0435\u0440\u0432\u043e\u043c \u043d\u0430\u0431\u043e\u0440\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c \u0434\u0430\u0442\u0443 \u043a\u043e\u043c\u043c\u0438\u0442\u0430 \u0432 \u0434\u0435\u043d\u044c 3 \u043d\u0430 \u0434\u0435\u043d\u044c 4, \u0434\u0430\u0442\u0443 \u043a\u043e\u043c\u043c\u0438\u0442\u0430 \u0432 \u0434\u0435\u043d\u044c 4\u00a0\u2014 \u043d\u0430 \u0434\u0435\u043d\u044c 5, \u0430 \u0434\u0430\u0442\u0443 \u043b\u044e\u0431\u043e\u0433\u043e \u0438\u0437 \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432 \u0432 \u0434\u0435\u043d\u044c 6\u00a0\u2014 \u043d\u0430 \u0434\u0435\u043d\u044c 7. \u0422\u043e\u0433\u0434\u0430 \u0432 \u043a\u0430\u0436\u0434\u044b\u0439 \u0438\u0437 \u0434\u043d\u0435\u0439 4, 5, 6, 7 \u0438 8 \u0432 \u043f\u0440\u043e\u0444\u0438\u043b\u0435 \u0412\u0438\u043a\u0438 \u0431\u0443\u0434\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u0442\u044c\u0441\u044f \u0445\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u0438\u043d \u043a\u043e\u043c\u043c\u0438\u0442, \u0438 \u043d\u0430\u0438\u0431\u043e\u043b\u044c\u0448\u0438\u0439 \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0438\u0437 \u043f\u043e\u0434\u0440\u044f\u0434 \u0438\u0434\u0443\u0449\u0438\u0445 \u0434\u043d\u0435\u0439 \u0441 \u043a\u043e\u043c\u043c\u0438\u0442\u0430\u043c\u0438\u00a0\u2014 [4;8]\u00a0\u2014 \u0431\u0443\u0434\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u0434\u043b\u0438\u043d\u0443 5.\n\u0412\u043e \u0432\u0442\u043e\u0440\u043e\u043c \u043d\u0430\u0431\u043e\u0440\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u043c\u043e\u0436\u043d\u043e \u043b\u0438\u0431\u043e \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u0432\u0441\u0435 \u043a\u043e\u043c\u043c\u0438\u0442\u044b \u043a\u0430\u043a \u0435\u0441\u0442\u044c, \u043b\u0438\u0431\u043e \u043f\u0435\u0440\u0435\u043d\u0435\u0441\u0442\u0438 \u043a\u0430\u0436\u0434\u044b\u0439 \u043a\u043e\u043c\u043c\u0438\u0442 \u043d\u0430 \u0434\u0435\u043d\u044c \u0432\u043f\u0435\u0440\u0451\u0434. \u0412 \u043b\u044e\u0431\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u0434\u043b\u0438\u043d\u0430 \u043e\u0442\u0440\u0435\u0437\u043a\u0430 \u0434\u043d\u0435\u0439 \u0441\u043e\u0441\u0442\u0430\u0432\u0438\u0442 6.\n\u0412 \u0442\u0440\u0435\u0442\u044c\u0435\u043c \u043d\u0430\u0431\u043e\u0440\u0435 \u0432\u0445\u043e\u0434\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0412\u0438\u043a\u0430 \u0441\u0434\u0435\u043b\u0430\u043b\u0430 \u043c\u043d\u043e\u0433\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u043e\u0432, \u043d\u043e \u0432\u0441\u0435 \u0432 \u043e\u0434\u0438\u043d \u0438 \u0442\u043e\u0442 \u0436\u0435 \u0434\u0435\u043d\u044c \u0441 \u043d\u043e\u043c\u0435\u0440\u043e\u043c 10. \u0412 \u043b\u0443\u0447\u0448\u0435\u043c \u0441\u043b\u0443\u0447\u0430\u0435 \u043e\u0442\u0440\u0435\u0437\u043e\u043a \u0434\u043d\u0435\u0439 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0435\u0442 \u0434\u043b\u0438\u043d\u044b 2\u00a0\u2014 \u0435\u0441\u043b\u0438 \u043a\u0430\u043a\u0438\u0435-\u0442\u043e \u043a\u043e\u043c\u043c\u0438\u0442\u044b \u043e\u0441\u0442\u0430\u0432\u0438\u0442\u044c \u043d\u0430 \u0434\u0435\u043d\u044c 10, \u0430 \u0434\u0440\u0443\u0433\u0438\u0435 \u043f\u0435\u0440\u0435\u043d\u0435\u0441\u0442\u0438 \u043d\u0430 \u0434\u0435\u043d\u044c 11.",
        "time_limit": "\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0430 \u0442\u0435\u0441\u04422 \u0441\u0435\u043a\u0443\u043d\u0434\u044b",
        "memory_limit": "\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u043f\u0430\u043c\u044f\u0442\u0438 \u043d\u0430 \u0442\u0435\u0441\u0442512 \u043c\u0435\u0433\u0430\u0431\u0430\u0439\u0442",
        "tags": [
            "*special problem",
            "brute force",
            "dp",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not available"
    },
    "1769B1": {
        "title": "B1. \u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u043e\u0432 I",
        "description": "\u0412 \u044d\u0442\u043e\u0439 \u0432\u0435\u0440\u0441\u0438\u0438 \u0437\u0430\u0434\u0430\u0447\u0438 \u0440\u0430\u0437\u043c\u0435\u0440\u044b \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c\u044b\u0445 \u0444\u0430\u0439\u043b\u043e\u0432 \u043d\u0435 \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u044e\u0442 10001000 \u0431\u0430\u0439\u0442.\n\u0412\u044b \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u0442\u0435 \u0441 \u043e\u0434\u043d\u043e\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043d\u0430 \u0434\u0440\u0443\u0433\u043e\u0439 n \u0444\u0430\u0439\u043b\u043e\u0432 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u043c a1,a2,\u2026,an \u0431\u0430\u0439\u0442. \u0424\u0430\u0439\u043b\u044b \u043a\u043e\u043f\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u0432 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435.\n\u041f\u0440\u0438 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0432\u044b \u0432\u0438\u0434\u0438\u0442\u0435 \u0434\u0432\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430: \u043f\u0435\u0440\u0432\u044b\u0439 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u043f\u0440\u043e\u0446\u0435\u043d\u0442 \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u0442\u0435\u043a\u0443\u0449\u0435\u043c \u0444\u0430\u0439\u043b\u0435, \u0430 \u0432\u0442\u043e\u0440\u043e\u0439\u00a0\u2014 \u043e\u0431\u0449\u0438\u0439 \u043f\u0440\u043e\u0446\u0435\u043d\u0442 \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u043e \u0432\u0441\u0435\u043c n \u0444\u0430\u0439\u043b\u0430\u043c. \u041e\u0431\u0430 \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u0430 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0430\u044e\u0442\u0441\u044f \u043e\u043a\u0440\u0443\u0433\u043b\u0451\u043d\u043d\u044b\u043c\u0438 \u0432\u043d\u0438\u0437 \u0434\u043e \u0446\u0435\u043b\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430. \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043d\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430\u0445 \u043e\u0431\u043d\u043e\u0432\u043b\u044f\u044e\u0442\u0441\u044f \u043f\u043e\u0441\u043b\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0431\u0430\u0439\u0442\u0430.\n\u0424\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u043e, \u043f\u043e\u0441\u043b\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u0430\u0439\u0442\u0430 \u043d\u043e\u043c\u0435\u0440 x \u0438\u0437 \u0444\u0430\u0439\u043b\u0430 \u043d\u043e\u043c\u0435\u0440 i \u043f\u0435\u0440\u0432\u044b\u0439 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u230a100\u22c5xai\u230b \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432, \u0430 \u0432\u0442\u043e\u0440\u043e\u0439\u00a0\u2014 \u230a100\u22c5(a1+a2+\u2026+ai\u22121+x)a1+a2+\u2026+an\u230b \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432. \u0412 \u0441\u0430\u043c\u043e\u043c \u043d\u0430\u0447\u0430\u043b\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043e\u0431\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0442 0 \u043f\u0440\u043e\u0446\u0435\u043d\u0442\u043e\u0432.\n\u041d\u0430\u0439\u0434\u0438\u0442\u0435 \u0432\u0441\u0435 \u0442\u0430\u043a\u0438\u0435 \u0446\u0435\u043b\u044b\u0435 \u0447\u0438\u0441\u043b\u0430 \u043e\u0442 0 \u0434\u043e 100 \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e, \u0447\u0442\u043e \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043e\u0431\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430 \u043e\u0434\u043d\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0442 \u044d\u0442\u043e \u0447\u0438\u0441\u043b\u043e. \u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u044d\u0442\u0438 \u0447\u0438\u0441\u043b\u0430 \u0432 \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u043d\u0438\u044f.\n\u0412 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0437\u0430\u0434\u0430\u043d\u043e \u043e\u0434\u043d\u043e \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e n (1\u2264n\u2264100)\u00a0\u2014 \u0447\u0438\u0441\u043b\u043e \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c\u044b\u0445 \u0444\u0430\u0439\u043b\u043e\u0432.\n\u0412\u043e \u0432\u0442\u043e\u0440\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0435 \u0437\u0430\u0434\u0430\u043d\u044b n \u0446\u0435\u043b\u044b\u0445 \u0447\u0438\u0441\u0435\u043b a1,a2,\u2026,an (1\u2264ai\u22641000)\u00a0\u2014 \u0440\u0430\u0437\u043c\u0435\u0440\u044b \u0444\u0430\u0439\u043b\u043e\u0432 \u0432 \u0431\u0430\u0439\u0442\u0430\u0445 \u0432 \u0442\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435, \u0432 \u043a\u043e\u0442\u043e\u0440\u043e\u043c \u043e\u043d\u0438 \u0431\u0443\u0434\u0443\u0442 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c\u0441\u044f.\n\u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u0432 \u0432\u043e\u0437\u0440\u0430\u0441\u0442\u0430\u044e\u0449\u0435\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u0432\u0441\u0435 \u0447\u0438\u0441\u043b\u0430 \u043e\u0442 0 \u0434\u043e 100 \u0432\u043a\u043b\u044e\u0447\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0442\u0430\u043a\u0438\u0435, \u0447\u0442\u043e \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043d\u0430 \u043e\u0431\u043e\u0438\u0445 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430\u0445 \u043e\u0434\u043d\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u044d\u0442\u043e \u0447\u0438\u0441\u043b\u043e.\n\u0412 \u043f\u0435\u0440\u0432\u043e\u043c \u0442\u0435\u0441\u0442\u0435 \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0432\u0441\u0435\u0433\u043e \u043e\u0434\u0438\u043d \u0444\u0430\u0439\u043b, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043e\u0431\u0430 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u0430 \u0432\u0441\u0435\u0433\u0434\u0430 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0442 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f.\n\u0412\u043e \u0432\u0442\u043e\u0440\u043e\u043c \u0442\u0435\u0441\u0442\u0435 \u043f\u0435\u0440\u0432\u044b\u0439 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440 \u0441\u0440\u0430\u0437\u0443 \u0436\u0435 \u0443\u0439\u0434\u0451\u0442 \u0432\u043f\u0435\u0440\u0451\u0434, \u043f\u043e\u0442\u043e\u043c \u0441\u0431\u0440\u043e\u0441\u0438\u0442\u0441\u044f \u0432 \u043d\u043e\u043b\u044c \u0438 \u043d\u0430\u0447\u043d\u0451\u0442 \u0434\u043e\u0433\u043e\u043d\u044f\u0442\u044c \u0432\u0442\u043e\u0440\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440 \u0437\u0430\u043d\u043e\u0432\u043e. \u0412 \u043a\u043e\u043d\u0446\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441-\u0431\u0430\u0440\u044b \u043d\u0435\u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u0440\u0435\u043c\u044f \u0431\u0443\u0434\u0443\u0442 \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u043e\u0434\u043d\u043e \u0438 \u0442\u043e \u0436\u0435 \u0447\u0438\u0441\u043b\u043e.",
        "time_limit": "\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438 \u043d\u0430 \u0442\u0435\u0441\u04422 \u0441\u0435\u043a\u0443\u043d\u0434\u044b",
        "memory_limit": "\u043e\u0433\u0440\u0430\u043d\u0438\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u043f\u0430\u043c\u044f\u0442\u0438 \u043d\u0430 \u0442\u0435\u0441\u0442512 \u043c\u0435\u0433\u0430\u0431\u0430\u0439\u0442",
        "tags": [
            "*special problem",
            "brute force",
            "implementation",
            "math",
            "*1000"
        ],
        "solution": "Solution not available"
    },
    "1766B": {
        "title": "B. Notepad#",
        "description": "You want to type the string s, consisting of n lowercase Latin letters, using your favorite text editor Notepad#.\nNotepad# supports two kinds of operations: \nCan you type string s in strictly less than n operations?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the string s.\nThe second line contains a string s, consisting of n lowercase Latin letters.\nThe sum of n doesn't exceed 2\u22c5105 over all testcases.\nFor each testcase, print \"YES\" if you can type string s in strictly less than n operations. Otherwise, print \"NO\".\nIn the first testcase, you can start with typing \"codef\" (5 operations), then copy \"o\" (1 operation) from an already typed part, then finish with typing \"rces\" (4 operations). That will be 10 operations, which is not strictly less than n. There exist other ways to type \"codeforces\". However, no matter what you do, you can't do less than n operations.\nIn the second testcase, you can type \"labac\" (5 operations), then copy \"aba\" (1 operation), finishing the string in 6 operations.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1765M": {
        "title": "M. Minimum LCM",
        "description": "You are given an integer n.\nYour task is to find two positive (greater than 0) integers a and b such that a+b=n and the least common multiple (LCM) of a and b is the minimum among all possible values of a and b. If there are multiple answers, you can print any of them.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264109).\nFor each test case, print two positive integers a and b\u00a0\u2014 the answer to the problem. If there are multiple answers, you can print any of them.\nIn the second example, there are 8 possible pairs of a and b:\nIn the third example, there are 5 possible pairs of a and b:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1765E": {
        "title": "E. Exchange",
        "description": "Monocarp is playing a MMORPG. There are two commonly used types of currency in this MMORPG \u2014 gold coins and silver coins. Monocarp wants to buy a new weapon for his character, and that weapon costs n silver coins. Unfortunately, right now, Monocarp has no coins at all.\nMonocarp can earn gold coins by completing quests in the game. Each quest yields exactly one gold coin. Monocarp can also exchange coins via the in-game trading system. Monocarp has spent days analyzing the in-game economy; he came to the following conclusion: it is possible to sell one gold coin for a silver coins (i.\u2009e. Monocarp can lose one gold coin to gain a silver coins), or buy one gold coin for b silver coins (i.\u2009e. Monocarp can lose b silver coins to gain one gold coin).\nNow Monocarp wants to calculate the minimum number of quests that he has to complete in order to have at least n silver coins after some abuse of the in-game economy. Note that Monocarp can perform exchanges of both types (selling and buying gold coins for silver coins) any number of times.\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of one line containing three integers n, a and b (1\u2264n\u2264107; 1\u2264a,b\u226450).\nFor each test case, print one integer \u2014 the minimum possible number of quests Monocarp has to complete.\nIn the first test case of the example, Monocarp should complete 4 quests, and then sell 4 gold coins for 100 silver coins.\nIn the second test case, Monocarp should complete 400000 quests, and then sell 400000 gold coins for 10 million silver coins.\nIn the third test case, Monocarp should complete 1 quest, sell the gold coin for 50 silver coins, buy a gold coin for 48 silver coins, and then sell it again for 50 coins. So, he will have 52 silver coins.\nIn the fourth test case, Monocarp should complete 1 quest and then sell the gold coin he has obtained for 50 silver coins.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1763B": {
        "title": "B. Incinerate",
        "description": "To destroy humanity, The Monster Association sent n monsters to Earth's surface. The i-th monster has health hi and power pi.\nWith his last resort attack, True Spiral Incineration Cannon, Genos can deal k damage to all monsters alive. In other words, Genos can reduce the health of all monsters by k (if k>0) with a single attack. \nHowever, after every attack Genos makes, the monsters advance. With their combined efforts, they reduce Genos' attack damage by the power of the \u2020weakest monster \u2021alive. In other words, the minimum pi among all currently living monsters is subtracted from the value of k after each attack.\n\u2020The Weakest monster is the one with the least power.\n\u2021A monster is alive if its health is strictly greater than 0.\nWill Genos be successful in killing all the monsters?\nThe first line of the input contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains two integers, n and k (1\u2264n,k\u2264105) \u2014 the number of monsters and Genos' initial attack damage. Then two lines follow, each containing n integers describing the arrays h and p (1\u2264hi,pi\u2264109).\nIt's guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print the answer \u2014 \"YES\" (without quotes) if Genos could kill all monsters and \"NO\" otherwise.\nIn the first example, after Genos' first attack, h and k will update to: ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "data structures",
            "implementation",
            "math",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1762B": {
        "title": "B. Make Array Good",
        "description": "An array b of m positive integers is good if for all pairs i and j (1\u2264i,j\u2264m), max(bi,bj) is divisible by min(bi,bj).\nYou are given an array a of n positive integers. You can perform the following operation:\nYou have to construct a sequence of at most n operations that will make a good. It can be proven that under the constraints of the problem, such a sequence of operations always exists.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the length of the array a.\nThe second line of each test case contains n space-separated integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 representing the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test, output a single integer p (0\u2264p\u2264n) \u2014 denoting the number of operations in your solution. \nIn each of the following p lines, output two space-separated integers \u2014 i and x.\nYou do not need to minimize the number of operations. It can be proven that a solution always exists.\nIn the first test case, array a becomes [5,5,5,5] after the operations. It is easy to see that [5,5,5,5] is good.\nIn the second test case, array a is already good.\nIn the third test case, after performing the operations, array a becomes [10,5,350,5,10], which is good.\nIn the fourth test case, after performing the operations, array a becomes [60,10,20], which is good.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "number theory",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1761B": {
        "title": "B. Elimination of a Ring",
        "description": "Define a cyclic sequence of size nn as an array s of length n, in which sn is adjacent to s1.\nMuxii has a ring represented by a cyclic sequence a of size n.\nHowever, the ring itself hates equal adjacent elements. So if two adjacent elements in the sequence are equal at any time, one of them will be erased immediately. The sequence doesn't contain equal adjacent elements initially.\nMuxii can perform the following operation until the sequence becomes empty:\nFor example, if ring is [1,2,4,2,3,2], and Muxii erases element 4, then ring would erase one of the elements equal to 2, and the ring will become [1,2,3,2].\nMuxii wants to find the maximum number of operations he could perform.\nNote that in a ring of size 1, its only element isn't considered adjacent to itself (so it's not immediately erased).\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100)\u00a0\u2014 the size of the cyclic sequence.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 the sequence itself.\nIt's guaranteed that ai\u2260ai+1 for 1\u2264i<n.\nIt's guaranteed that an\u2260a1 when n>1.\nFor each test case, output a single integer\u00a0\u2014 the maximum number of operations Muxii can perform.\nIn the first test case, you can erase the second element first, then erase the remaining elements one by one in any order. In total, you can perform the operation 4 times. Note that if you erase the first element first, then the sequence will be turned into [2,3,2] and then immediately become [2,3].\nIn the second test case, you can erase the first element first, then the sequence becomes [2,1]. Then you can erase all remaining elements one by one in any order.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1760E": {
        "title": "E. Binary Inversions",
        "description": "You are given a binary array\u2020 of length n. You are allowed to perform one operation on it at most once. In an operation, you can choose any element and flip it: turn a 0 into a 1 or vice-versa.\nWhat is the maximum number of inversions\u2021 the array can have after performing at most one operation?\n\u2020 A binary array is an array that contains only zeroes and ones.\n\u2021 The number of inversions in an array is the number of pairs of indices i,j such that i<j and ai>aj.\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe following line contains n space-separated positive integers a1, a2,..., an (0\u2264ai\u22641)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u00a0\u2014 the maximum number of inversions the array can have after performing at most one operation.\nFor the first test case, the inversions are initially formed by the pairs of indices (1,2), (1,4), (3,4), being a total of 3, which already is the maximum possible.\nFor the second test case, the inversions are initially formed by the pairs of indices (2,3), (2,4), (2,6), (5,6), being a total of four. But, by flipping the first element, the array becomes 1,1,0,0,1,0, which has the inversions formed by the pairs of indices (1,3), (1,4), (1,6), (2,3), (2,4), (2,6), (5,6) which total to 7 inversions which is the maximum possible.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1760D": {
        "title": "D. Challenging Valleys",
        "description": "You are given an array a[0\u2026n\u22121] of n integers. This array is called a \"valley\" if there exists exactly one subarray a[l\u2026r] such that:\nHere are three examples:\nThe first image shows the array [3,2,2,1,2,2,3], it is a valley because only subarray with indices l=r=3 satisfies the condition.\nThe second image shows the array [1,1,1,2,3,3,4,5,6,6,6], it is a valley because only subarray with indices l=0,r=2 satisfies the codition.\nThe third image shows the array [1,2,3,4,3,2,1], it is not a valley because two subarrays l=r=0 and l=r=6 that satisfy the condition.\nYou are asked whether the given array is a valley or not.\nNote that we consider the array to be indexed from 0.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe second line of each test case contains n integers ai (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases is smaller than 2\u22c5105.\nFor each test case, output \"YES\" (without quotes) if the array is a valley, and \"NO\" (without quotes) otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nThe first three test cases are explained in the statement.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1759C": {
        "title": "C. Thermostat",
        "description": "Vlad came home and found out that someone had reconfigured the old thermostat to the temperature of aa.\nThe thermostat can only be set to a temperature from l to r inclusive, the temperature cannot change by less than x. Formally, in one operation you can reconfigure the thermostat from temperature a to temperature b if |a\u2212b|\u2265x and l\u2264b\u2264r.\nYou are given l, r, x, a and b. Find the minimum number of operations required to get temperature b from temperature a, or say that it is impossible.\nThe first line of input data contains the single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases in the test.\nThe descriptions of the test cases follow.\nThe first line of each case contains three integers l, r and x (\u2212109\u2264l\u2264r\u2264109, 1\u2264x\u2264109) \u2014 range of temperature and minimum temperature change.\nThe second line of each case contains two integers a and b (l\u2264a,b\u2264r) \u2014 the initial and final temperatures.\nOutput t numbers, each of which is the answer to the corresponding test case. If it is impossible to achieve the temperature b, output -1, otherwise output the minimum number of operations.\nIn the first example, the thermostat is already set up correctly.\nIn the second example, you can achieve the desired temperature as follows: 4\u219210\u21925.\nIn the third example, you can achieve the desired temperature as follows: 3\u21928\u21922\u21927.\nIn the fourth test, it is impossible to make any operation.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "shortest paths",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1747C": {
        "title": "C. Swap Game",
        "description": "Alice and Bob are playing a game on an array a of n positive integers. Alice and Bob make alternating moves with Alice going first.\nIn his/her turn, the player makes the following move:\nDetermine the winner of the game if both players play optimally.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642\u22c5104) \u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u00a0\u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2\u2026an (1\u2264ai\u2264109) \u00a0\u2014 the elements of the array a.\nIt is guaranteed that sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, if Alice will win the game, output \"Alice\". Otherwise, output \"Bob\".\nYou can output each letter in any case. For example, \"alIcE\", \"Alice\", \"alice\" will all be considered identical.\nIn the first testcase, in her turn, Alice can only choose i=2, making the array equal [1,0]. Then Bob, in his turn, will also choose i=2 and make the array equal [0,0]. As a1=0, Alice loses.\nIn the second testcase, once again, players can only choose i=2. Then the array will change as follows: [2,1]\u2192[1,1]\u2192[1,0]\u2192[0,0], and Bob loses.\nIn the third testcase, we can show that Alice has a winning strategy.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1744D": {
        "title": "D. Divisibility by 2^n",
        "description": "You are given an array of positive integers a1,a2,\u2026,an.\nMake the product of all the numbers in the array (that is, a1\u22c5a2\u22c5\u2026\u22c5an) divisible by 2n.\nYou can perform the following operation as many times as you like:\nYou cannot apply the operation repeatedly to a single index. In other words, all selected values of i must be different.\nFind the smallest number of operations you need to perform to make the product of all the elements in the array divisible by 2n. Note that such a set of operations does not always exist.\nThe first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number test cases.\nThen the descriptions of the input data sets follow.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105) \u2014 the length of array a.\nThe second line of each test case contains exactly n integers: a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n values over all test cases in a test does not exceed 2\u22c5105.\nFor each test case, print the least number of operations to make the product of all numbers in the array divisible by 2n. If the answer does not exist, print -1.\nIn the first test case, the product of all elements is initially 2, so no operations needed.\nIn the second test case, the product of elements initially equals 6. We can apply the operation for i=2, and then a2 becomes 2\u22c52=4, and the product of numbers becomes 3\u22c54=12, and this product of numbers is divided by 2n=22=4. \nIn the fourth test case, even if we apply all possible operations, we still cannot make the product of numbers divisible by 2n \u00a0\u2014 it will be (13\u22c51)\u22c5(17\u22c52)\u22c5(1\u22c53)\u22c5(1\u22c54)=5304, which does not divide by 2n=24=16.\nIn the fifth test case, we can apply operations for i=2 and i=4. ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1744C": {
        "title": "C. Traffic Light",
        "description": "You find yourself on an unusual crossroad with a weird traffic light. That traffic light has three possible colors: red (r), yellow (y), green (g). It is known that the traffic light repeats its colors every nn seconds and at the i-th second the color si is on.\nThat way, the order of the colors is described by a string. For example, if s=\"rggry\", then the traffic light works as the following: red-green-green-red-yellow-red-green-green-red-yellow- ... and so on.\nMore formally, you are given a string s1,s2,\u2026,sn of length n. At the first second the color s1 is on, at the second \u2014 s2, ..., at the n-th second the color sn is on, at the n+1-st second the color s1 is on and so on.\nYou need to cross the road and that can only be done when the green color is on. \nYou know which color is on the traffic light at the moment, but you don't know the current moment of time. You need to find the minimum amount of time in which you are guaranteed to cross the road.\nYou can assume that you cross the road immediately. \nFor example, with s=\"rggry\" and the current color r there are two options: either the green color will be on after 1 second, or after 3. That way, the answer is equal to 3 \u2014 that is the number of seconds that we are guaranteed to cross the road, if the current color is r.\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThen the description of the test cases follows.\nThe first line of each test case contains an integer n and a symbol c (1\u2264n\u22642\u22c5105, c is one of allowed traffic light colors r, y or g)\u2014 the length of the string s and the current color of the traffic light. \nThe second line of each test case contains a string s of the length n, consisting of the letters r, y and g.\nIt is guaranteed that the symbol g is in the string s and the symbol c is in the string s. \nIt is guaranteed, that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case output the minimal number of second in which you are guaranteed to cross the road.\nThe first test case is explained in the statement.\nIn the second test case the green color is on so you can cross the road immediately. \nIn the third test case, if the red color was on at the second second, then we would wait for the green color for one second, and if the red light was on at the first second, then we would wait for the green light for two seconds.\nIn the fourth test case the longest we would wait for the green color is if we wait for it starting from the fifth second.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1743C": {
        "title": "C. Save the Magazines",
        "description": "Monocarp has been collecting rare magazines for quite a while, and now he has decided to sell them. He distributed the magazines between n boxes, arranged in a row. The i-th box contains ai magazines. Some of the boxes are covered with lids, others are not. \nSuddenly it started to rain, and now Monocarp has to save as many magazines from the rain as possible. To do this, he can move the lids between boxes as follows: if the i-th box was covered with a lid initially, he can either move the lid from the i-th box to the box (i\u22121) (if it exists), or keep the lid on the i-th box. You may assume that Monocarp can move the lids instantly at the same moment, and no lid can be moved more than once. If a box will be covered with a lid after Monocarp moves the lids, the magazines in it will be safe from the rain; otherwise they will soak.\nYou have to calculate the maximum number of magazines Monocarp can save from the rain.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of the testcases.\nThe first line of each testcase contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of boxes.\nThe second line contains a string of n characters 0 and/or 1. If the i-th character is 1, the i-th box is initially covered with a lid. If the i-th character is 0, the i-th box is initially not covered.\nThe third line contains a sequence of integers a1,a2,\u2026,an (1\u2264ai\u2264104), where ai is the number of magazines in the i-th box.\nThe sum of n over all testcases doesn't exceed 2\u22c5105.\nFor each testcase, print one integer\u00a0\u2014 the maximum number of magazines Monocarp can save from the rain.\nIn the first testcase of the example, Monocarp can move the lid from the second box to the first box, so the boxes 1, 3 and 4 are covered, and 10+8+9=27 magazines are saved.\nIn the second testcase, Monocarp can move the lid from the second box to the first box, then from the third box to the second box, then from the fifth box to the fourth box, and then from the sixth box to the fifth box. The boxes 1, 2, 4 and 5 will be covered, so 20+10+30+20=80 magazines can be saved.\nThere are no lids in the third testcase, so it's impossible to save even a single magazine.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1742E": {
        "title": "E. Scuza",
        "description": "Timur has a stairway with n steps. The i-th step is ai meters higher than its predecessor. The first step is a1 meters higher than the ground, and the ground starts at 0 meters. \nTimur has q questions, each denoted by an integer k1,\u2026,kq. For each question ki, you have to print the maximum possible height Timur can achieve by climbing the steps if his legs are of length ki. Timur can only climb the j-th step if his legs are of length at least aj. In other words, ki\u2265aj for each step j climbed.\nNote that you should answer each question independently.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n,q (1\u2264n,q\u22642\u22c5105)\u00a0\u2014 the number of steps and the number of questions, respectively.\nThe second line of each test case contains n integers (1\u2264ai\u2264109)\u00a0\u2014 the height of the steps.\nThe third line of each test case contains q integers (0\u2264ki\u2264109)\u00a0\u2014 the numbers for each question.\nIt is guaranteed that the sum of n does not exceed 2\u22c5105, and the sum of q does not exceed 2\u22c5105.\nFor each test case, output a single line containing q integers, the answer for each question.\nPlease note, that the answer for some questions won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).\nConsider the first test case, pictured in the statement. ",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1742D": {
        "title": "D. Coprime",
        "description": "Given an array of n positive integers a1,a2,\u2026,an (1\u2264ai\u22641000). Find the maximum value of i+j such that ai and aj are coprime,\u2020 or \u22121 if no such i, j exist.\nFor example consider the array [1,3,5,2,4,7,7]. The maximum value of i+j that can be obtained is 5+7, since a5=4 and a7=7 are coprime.\n\u2020 Two integers p and q are coprime if the only positive integer that is a divisor of both of them is 1 (that is, their greatest common divisor is 1).\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u226410)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe following line contains n space-separated positive integers a1, a2,..., an (1\u2264ai\u22641000)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output a single integer \u00a0\u2014 the maximum value of i+j such that i and j satisfy the condition that ai and aj are coprime, or output \u22121 in case no i, j satisfy the condition.\nFor the first test case, we can choose i=j=3, with sum of indices equal to 6, since 1 and 1 are coprime.\nFor the second test case, we can choose i=7 and j=5, with sum of indices equal to 7+5=12, since 7 and 4 are coprime.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1741C": {
        "title": "C. Minimize the Thickness",
        "description": "You are given a sequence a=[a1,a2,\u2026,an] consisting of n positive integers.\nLet's call a group of consecutive elements a segment. Each segment is characterized by two indices: the index of its left end and the index of its right end. Denote by a[l,r] a segment of the sequence a with the left end in l and the right end in r, i.e. a[l,r]=[al,al+1,\u2026,ar].\nFor example, if a=[31,4,15,92,6,5], then a[2,5]=[4,15,92,6], a[5,5]=[6], a[1,6]=[31,4,15,92,6,5] are segments.\nWe split the given sequence a into segments so that: \nFor example, if a = [55,45,30,30,40,100], then such a sequence can be split into three segments: a[1,2]=[55,45], a[3,5]=[30,30,40], a[6,6]=[100]. Each element belongs to exactly segment, the sum of the elements of each segment is 100.\nLet's define thickness of split as the length of the longest segment. For example, the thickness of the split from the example above is 3.\nFind the minimum thickness among all possible splits of the given sequence of a into segments in the required way.\nThe first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nEach test case is described by two lines.\nThe first line of each test case contains a single integer n (1\u2264n\u22642000) \u2014 the length of the sequence a.\nThe second line of each test case contains exactly n integers: a1,a2,\u2026,an (1\u2264ai\u2264106) \u2014 elements of the sequence a.\nIt is guaranteed that the sum of n for all test cases does not exceed 2000.\nFor each test case, output one integer \u2014 the minimum possible thickness of a split of the sequence a into segments.\nNote that there always exist a split, you can always consider whole sequence as one segment.\nThe split in the first test case is explained in the statement, it can be shown that it is optimal.\nIn the second test case, it is possible to split into segments only by leaving a single segment. Then the thickness of this split is equal to the length of the entire sequence, that is, 4.\nIn the third test case, the optimal split will be [10,55],[35,30],[65]. The thickness of the split equals to 2.\nIn the fourth test case possible splits are:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1739B": {
        "title": "B. Array Recovery",
        "description": "For an array of non-negative integers a of size n, we construct another array d as follows: d1=a1, di=|ai\u2212ai\u22121| for 2\u2264i\u2264n.\nYour task is to restore the array a from a given array d, or to report that there are multiple possible arrays. \nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains one integer n (1\u2264n\u2264100)\u00a0\u2014 the size of the arrays a and d.\nThe second line contains n integers d1,d2,\u2026,dn (0\u2264di\u2264100)\u00a0\u2014 the elements of the array d.\nIt can be shown that there always exists at least one suitable array a under these constraints.\nFor each test case, print the elements of the array a, if there is only one possible array a. Otherwise, print \u22121.\nIn the second example, there are two suitable arrays: [2,8,5] and [2,8,11].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1738B": {
        "title": "B. Prefix Sum Addicts",
        "description": "Suppose a1,a2,\u2026,ana1,a2,\u2026,an is a sorted integer sequence of length n such that a1\u2264a2\u2264\u22ef\u2264an. \nFor every 1\u2264i\u2264n, the prefix sum si of the first i terms a1,a2,\u2026,ai is defined by si=i\u2211k=1ak=a1+a2+\u22ef+ai.\nNow you are given the last k terms of the prefix sums, which are sn\u2212k+1,\u2026,sn\u22121,sn. Your task is to determine whether this is possible. \nFormally, given k integers sn\u2212k+1,\u2026,sn\u22121,sn, the task is to check whether there is a sequence a1,a2,\u2026,an such that \nEach test contains multiple test cases. The first line contains an integer t (1\u2264t\u2264105) \u2014 the number of test cases. The following lines contain the description of each test case.\nThe first line of each test case contains two integers n (1\u2264n\u2264105) and k (1\u2264k\u2264n), indicating the length of the sequence a and the number of terms of prefix sums, respectively.\nThe second line of each test case contains k integers sn\u2212k+1,\u2026,sn\u22121,sn (\u2212109\u2264si\u2264109 for every n\u2212k+1\u2264i\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output \"YES\" (without quotes) if it is possible and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive response).\nIn the first test case, we have the only sequence a=[1,1,1,1,1].\nIn the second test case, we can choose, for example, a=[\u22123,\u22122,\u22121,0,1,2,3].\nIn the third test case, the prefix sums define the only sequence a=[2,1,1], but it is not sorted. \nIn the fourth test case, it can be shown that there is no sequence with the given prefix sums.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1736B": {
        "title": "B. Playing with GCD",
        "description": "You are given an integer array a of length n. \nDoes there exist an array b consisting of n+1 positive integers such that ai=gcd(bi,bi+1) for all i (1\u2264i\u2264n)? \nNote that gcd(x,y) denotes the greatest common divisor (GCD) of integers x and y.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264105). Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264105) \u2014 the length of the array a.\nThe second line of each test case contains n space-separated integers a1,a2,\u2026,an representing the array a (1\u2264ai\u2264104).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output \"YES\" if such b exists, otherwise output \"NO\". You can print each letter in any case (upper or lower).\nIn the first test case, we can take b=[343,343].\nIn the second test case, one possibility for b is b=[12,8,6].\nIn the third test case, it can be proved that there does not exist any array b that fulfills all the conditions.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1734C": {
        "title": "C. Removing Smallest Multiples",
        "description": "You are given a set S, which contains the first n positive integers: 1,2,\u2026,n.\nYou can perform the following operation on S any number of times (possibly zero): \nYou are given a set T, which is a subset of S. Find the minimum possible total cost of operations such that S would be transformed into T. We can show that such a transformation is always possible.\nThe first line of the input contains a single integer t (1\u2264t\u226410000)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line contains a single positive integer n (1\u2264n\u2264106).\nThe second line of each test case contains a binary string of length n, describing the set T. The i-th character of the string is '1' if and only if i is an element of T, and '0' otherwise.\nIt is guaranteed that the sum of n over all test cases does not exceed 106. \nFor each test case, output one non-negative integer\u00a0\u2014 the minimum possible total cost of operations such that S would be transformed into T.\nIn the first test case, we shall not perform any operations as S is already equal to T, which is the set {1,2,3,4,5,6}.\nIn the second test case, initially, S={1,2,3,4,5,6,7}, and T={1,2,4,7}. We shall perform the following operations: \nThe total cost is 3+3+5=11. It can be shown that this is the smallest cost possible.\nIn the third test case, initially, S={1,2,3,4} and T={} (empty set). We shall perform 4 operations of k=1 to delete 1, 2, 3, and 4.\nIn the fourth test case, initially, S={1,2,3,4} and T={3}. We shall perform two operations with k=1 to delete 1 and 2, then perform one operation with k=2 to delete 4.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1732A": {
        "title": "A. Bestie",
        "description": "You are given an array a consisting of n integers a1,a2,\u2026,an. Friends asked you to make the greatest common divisor (GCD) of all numbers in the array equal to 1. In one operation, you can do the following:\nYou need to find the minimum total cost of operations we need to perform so that the GCD of the all array numbers becomes equal to 1.\nEach test consists of multiple test cases. The first line contains an integer t (1\u2264t\u22645000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u226420) \u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 the elements of the array.\nFor each test case, output a single integer \u2014 the minimum total cost of operations that will need to be performed so that the GCD of all numbers in the array becomes equal to 1.\nWe can show that it's always possible to do so.\nIn the first test case, the GCD of the entire array is already equal to 1, so there is no need to perform operations.\nIn the second test case, select i=1. After this operation, a1=gcd(2,1)=1. The cost of this operation is 1.\nIn the third test case, you can select i=1, after that the array a will be equal to [1,4]. The GCD of this array is 1, and the total cost is 2.\nIn the fourth test case, you can select i=2, after that the array a will be equal to [3,2,9]. The GCD of this array is 1, and the total cost is 2.\nIn the sixth test case, you can select i=4 and i=5, after that the array a will be equal to [120,60,80,4,5]. The GCD of this array is 1, and the total cost is 3.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "combinatorics",
            "constructive algorithms",
            "implementation",
            "math",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1731B": {
        "title": "B. Kill Demodogs",
        "description": "Demodogs from the Upside-down have attacked Hawkins again. El wants to reach Mike and also kill as many Demodogs in the way as possible.\nHawkins can be represented as an n\u00d7n grid. The number of Demodogs in a cell at the i-th row and the j-th column is i\u22c5j. El is at position (1,1) of the grid, and she has to reach (n,n) where she can find Mike. \nThe only directions she can move are the right (from (i,j) to (i,j+1)) and the down (from (i,j) to (i+1,j)). She can't go out of the grid, as there are doors to the Upside-down at the boundaries. \nCalculate the maximum possible number of Demodogs ans she can kill on the way, considering that she kills all Demodogs in cells she visits (including starting and finishing cells).\nPrint 2022\u22c5ans modulo 109+7. Modulo 109+7 because the result can be too large and multiplied by 2022 because we are never gonna see it again!\n(Note, you firstly multiply by 2022 and only after that take the remainder.)\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe first line of each test case contains one integer n (2\u2264n\u2264109)\u00a0\u2014 the size of the grid.\nFor each test case, print a single integer\u00a0\u2014 the maximum number of Demodogs that can be killed multiplied by 2022, modulo 109+7.\nIn the first test case, for any path chosen by her the number of Demodogs to be killed would be 7, so the answer would be 2022\u22c57=14154.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1730C": {
        "title": "C. Minimum Notation",
        "description": "You have a string s consisting of digits from 0 to 9 inclusive. You can perform the following operation any (possibly zero) number of times: \nWhat is the lexicographically smallest string you can get by performing these operations?\nA string a is lexicographically smaller than a string b of the same length if and only if the following holds: \nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then the test cases follow.\nEach test case consists of a single line that contains one string s (1\u2264|s|\u22642\u22c5105) \u2014 the string consisting of digits. Please note that s is just a string consisting of digits, so leading zeros are allowed.\nIt is guaranteed that the sum of lengths of s over all test cases does not exceed 2\u22c5105.\nPrint a single string \u2014 the minimum string that is possible to obtain.\nIn the first test case: \nNothing needs to be done in the second and third test cases.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1729D": {
        "title": "D. Friends and the Restaurant",
        "description": "A group of n friends decide to go to a restaurant. Each of the friends plans to order meals for xi burles and has a total of yi burles (1\u2264i\u2264n). \nThe friends decide to split their visit to the restaurant into several days. Each day, some group of at least two friends goes to the restaurant. Each of the friends visits the restaurant no more than once (that is, these groups do not intersect). These groups must satisfy the condition that the total budget of each group must be not less than the amount of burles that the friends in the group are going to spend at the restaurant. In other words, the sum of all xi values in the group must not exceed the sum of yi values in the group.\nWhat is the maximum number of days friends can visit the restaurant?\nFor example, let there be n=6 friends for whom x = [8,3,9,2,4,5] and y = [5,3,1,4,5,10]. Then: \nIt can be shown that they will not be able to form more groups so that each group has at least two friends and each group can pay the bill.\nSo, the maximum number of groups the friends can split into is 2. Friends will visit the restaurant for a maximum of two days. Note that the 3-rd friend will not visit the restaurant at all.\nOutput the maximum number of days the friends can visit the restaurant for given n, x and y.\nThe first line of the input contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases in the test.\nThe descriptions of the test cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u2014 the number of friends.\nThe second line of each test case contains exactly n integers x1,x2,\u2026,xn (1\u2264xi\u2264109). The value of xi corresponds to the number of burles that the friend numbered i plans to spend at the restaurant.\nThe third line of each test case contains exactly n integers y1,y2,\u2026,yn (1\u2264yi\u2264109). The value yi corresponds to the number of burles that the friend numbered i has.\nIt is guaranteed that the sum of n values over all test cases does not exceed 105.\nFor each test case, print the maximum number of days to visit the restaurant. If friends cannot form even one group to visit the restaurant, print 0.\nThe first test case in explained in the problem statement.\nIn the second test case, friends cannot form at least one group of two or more people.\nIn the third test case, one way to visit the restaurant in one day is to go in a group of all three friends (1+3+10\u22652+3+7). Note that they do not have the option of splitting into two groups.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "two pointers",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1729C": {
        "title": "C. Jumping on Tiles",
        "description": "Polycarp was given a row of tiles. Each tile contains one lowercase letter of the Latin alphabet. The entire sequence of tiles forms the string s.\nIn other words, you are given a string s consisting of lowercase Latin letters.\nInitially, Polycarp is on the first tile of the row and wants to get to the last tile by jumping on the tiles. Jumping from i-th tile to j-th tile has a cost equal to |index(si)\u2212index(sj)|, where index(c) is the index of the letter c in the alphabet (for example, index('a')=1, index('b')=2, ..., index('z')=26) .\nPolycarp wants to get to the n-th tile for the minimum total cost, but at the same time make maximum number of jumps.\nIn other words, among all possible ways to get to the last tile for the minimum total cost, he will choose the one with the maximum number of jumps.\nPolycarp can visit each tile at most once.\nPolycarp asks you to help\u00a0\u2014 print the sequence of indices of string s on which he should jump.\nThe first line of the input contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases in the test.\nEach test case is given by the string s (2\u2264|s|\u22642\u22c5105), where |s|\u00a0\u2014 is the length of string s. The string s consists of lowercase Latin letters.\nIt is guaranteed that the sum of string lengths s over all test cases does not exceed 2\u22c5105.\nThe answer to each test case consists of two lines.\nIn the first line print two integers cost, m, where cost is the minimum total cost of the path, and m is the maximum number of visited tiles Polycarp can make to get to n-th tiles for the minimum total cost cost (i.e. the number of jumps is m\u22121).\nIn the next line print m different numbers j1,j2,\u2026,jm (1\u2264ji\u2264|s|)\u00a0\u2014 the sequence of indices of the tiles Polycarp will jump on. The first number in the sequence must be 1 (that is, j1=1) and the last number must be the value of |s| (that is, jm=|s|).\nIf there are multiple answers, print any of them.\nIn the first test case, the required path corresponds to the picture:\nIn this case, the minimum possible total cost of the path is achieved. Since index('l')=12, index('o')=15, index('g')=7, index('i')=9, index('c')=3, then the total cost of the path is |12\u22129|+|9\u22127|+|7\u22123|=3+2+4=9.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1726B": {
        "title": "B. Mainak and Interesting Sequence",
        "description": "Mainak has two positive integers n and m.\nMainak finds a sequence a1,a2,\u2026,an of n positive integers interesting, if for all integers i (1\u2264i\u2264n), the bitwise XOR of all elements in a which are strictly less than ai is 0. Formally if pi is the bitwise XOR of all elements in a which are strictly less than ai, then a is an interesting sequence if p1=p2=\u2026=pn=0.\nFor example, sequences [1,3,2,3,1,2,3], [4,4,4,4], [25] are interesting, whereas [1,2,3,4] (p2=1\u22600), [4,1,1,2,4] (p1=1\u22951\u22952=2\u22600), [29,30,30] (p2=29\u22600) aren't interesting.\nHere a\u2295b denotes bitwise XOR of integers a and b.\nFind any interesting sequence a1,a2,\u2026,an (or report that there exists no such sequence) such that the sum of the elements in the sequence a is equal to m, i.e. a1+a2\u2026+an=m.\nAs a reminder, the bitwise XOR of an empty sequence is considered to be 0.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first line and the only line of each test case contains two integers n and m (1\u2264n\u2264105, 1\u2264m\u2264109) \u2014 the length of the sequence and the sum of the elements.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, if there exists some interesting sequence, output \"Yes\" on the first line, otherwise output \"No\". You may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).\nIf the answer is \"Yes\", output n positive integers a1,a2,\u2026,an (ai\u22651), forming an interesting sequence such that a1+a2\u2026+an=m. If there are multiple solutions, output any.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1725B": {
        "title": "B. Basketball Together",
        "description": "A basketball competition is held where the number of players in a team does not have a maximum or minimum limit (not necessarily 5 players in one team for each match). There are N candidate players in the competition that will be trained by Pak Chanek, the best basketball coach on earth. The i-th candidate player has a power of Pi.\nPak Chanek will form zero or more teams from the N candidate players on the condition that each candidate player may only join in at most one team. Each of Pak Chanek's teams will be sent to compete once with an enemy team that has a power of D. In each match, the team sent is said to defeat the enemy team if the sum of powers from the formed players is strictly greater than D.\nOne of Pak Chanek's skills is that when a team that has been formed plays in a match, he can change the power of each player in the team to be equal to the biggest player power from the team.\nDetermine the maximum number of wins that can be achieved by Pak Chanek.\nThe first line contains two integers N and D (1\u2264N\u2264105, 1\u2264D\u2264109) \u2014 the number of candidate players and the power of the enemy team.\nThe second line contains N integers P1,P2,\u2026,PN (1\u2264Pi\u2264109) \u2014 the powers of all candidate players.\nA line containing an integer representing the maximum number of wins that can be achieved by Pak Chanek.\nThe 1-st team formed is a team containing players 4 and 6. The power of each player in the team becomes 100. So the total power of the team is 100+100=200>180.\nThe 2-nd team formed is a team containing players 1, 2, and 5. The power of each player in the team becomes 90. So the total power of the team is 90+90+90=270>180.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1722D": {
        "title": "D. Line",
        "description": "There are n people in a horizontal line, each looking either to the left or the right. Each person counts the number of people in the direction they are looking. The value of the line is the sum of each person's count.\nFor example, in the arrangement LRRLL, where L stands for a person looking left and R stands for a person looking right, the counts for each person are [0,3,2,3,4], and the value is 0+3+2+3+4=12.\nYou are given the initial arrangement of people in the line. For each k from 1 to n, determine the maximum value of the line if you can change the direction of at most k people.\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the line.\nThe following line contains a string consisting of n characters, each of which is either L or R, representing a person facing left or right, respectively\u00a0\u2014 the description of the line.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nPlease note that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).\nFor each test case, output n space-separated non-negative integers\u00a0\u2014 the maximum value of the line if you can change the direction of at most k people for each k from 1 to n, inclusive.\nIn the first test case: \nIn the second test case, it is optimal to only change the direction of the first person for all k from 1 to 5 (that is, make the line RRRLL).",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1721B": {
        "title": "B. Deadly Laser",
        "description": "The robot is placed in the top left corner of a grid, consisting of n rows and m columns, in a cell (1,1).\nIn one step, it can move into a cell, adjacent by a side to the current one: \nThe robot can't move outside the grid.\nThe cell (sx,sy) contains a deadly laser. If the robot comes into some cell that has distance less than or equal to d to the laser, it gets evaporated. The distance between two cells (x1,y1) and (x2,y2) is |x1\u2212x2|+|y1\u2212y2|.\nPrint the smallest number of steps that the robot can take to reach the cell (n,m) without getting evaporated or moving outside the grid. If it's not possible to reach the cell (n,m), print -1.\nThe laser is neither in the starting cell, nor in the ending cell. The starting cell always has distance greater than d to the laser.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe only line of each testcase contains five integers n,m,sx,sy,d (2\u2264n,m\u22641000; 1\u2264sx\u2264n; 1\u2264sy\u2264m; 0\u2264d\u2264n+m)\u00a0\u2014 the size of the grid, the cell that contains the laser and the evaporating distance of the laser.\nThe laser is neither in the starting cell, nor in the ending cell ((sx,sy)\u2260(1,1) and (sx,sy)\u2260(n,m)). The starting cell (1,1) always has distance greater than d to the laser (|sx\u22121|+|sy\u22121|>d).\nFor each testcase, print a single integer. If it's possible to reach the cell (n,m) from (1,1) without getting evaporated or moving outside the grid, then print the smallest amount of steps it can take the robot to reach it. Otherwise, print -1.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1720C": {
        "title": "C. Corners",
        "description": "You are given a matrix consisting of n rows and m columns. Each cell of this matrix contains 0 or 1.\nLet's call a square of size 2\u00d72 without one corner cell an L-shape figure. In one operation you can take one L-shape figure, with at least one cell containing 1 and replace all numbers in it with zeroes.\nFind the maximum number of operations that you can do with the given matrix.\nThe first line contains one integer t (1\u2264t\u2264500) \u2014 the number of test cases. Then follow the descriptions of each test case.\nThe first line of each test case contains two integers n and m (2\u2264n,m\u2264500) \u2014 the size of the matrix.\nEach of the following n lines contains a binary string of length m \u2014 the description of the matrix.\nIt is guaranteed that the sum of n and the sum of m over all test cases does not exceed 1000.\nFor each test case output the maximum number of operations you can do with the given matrix.\nIn the first testcase one of the optimal sequences of operations is the following (bold font shows l-shape figure on which operation was performed): \nIn the third testcase from the sample we can not perform any operation because the matrix doesn't contain any ones.\nIn the fourth testcase it does not matter which L-shape figure we pick in our first operation. We will always be left with single one. So we will perform 2 operations.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1717B": {
        "title": "B. Madoka and Underground Competitions",
        "description": "Madoka decided to participate in an underground sports programming competition. And there was exactly one task in it:\nA square table of size n\u00d7n, where n is a multiple of k, is called good if only the characters '.' and 'X' are written in it, as well as in any subtable of size 1\u00d7k or k\u00d71, there is at least one character 'X'. In other words, among any k consecutive vertical or horizontal cells, there must be at least one containing the character 'X'.\nOutput any good table that has the minimum possible number of characters 'X', and also the symbol 'X' is written in the cell (r,c). Rows are numbered from 1 to n from top to bottom, columns are numbered from 1 to n from left to right.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first and the only line of each test case contains four integers n, k, r, c (1\u2264n\u2264500,1\u2264k\u2264n,1\u2264r,c\u2264n)\u00a0\u2014 the size of the table, the integer k and the coordinates of the cell, which must contain the character 'X'. It is guaranteed that n is a multiple of k.\nIt is guaranteed that the sum of n over all test cases does not exceed 500.\nFor each test case, output n lines, each consisting of n characters '.' and 'X',\u00a0\u2014 the desired table. If there are several answers, then you can output anyone.\nLet's analyze the first test case.\nThe following tables can be printed as the correct answer:\nNote that the following table is invalid because cell (3,2) does not contain the character 'X': \nIn the second test case, the only correct table is: ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1715B": {
        "title": "B. Beautiful Array",
        "description": "Stanley defines the beauty of an array aa of length n, which contains non-negative integers, as follows: n\u2211i=1\u230aaik\u230b, which means that we divide each element by k, round it down, and sum up the resulting values.\nStanley told Sam the integer k and asked him to find an array a of n non-negative integers, such that the beauty is equal to b and the sum of elements is equal to s. Help Sam\u00a0\u2014 find any of the arrays satisfying the conditions above.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains integers n, k, b, s (1\u2264n\u2264105, 1\u2264k\u2264109, 0\u2264b\u2264109, 0\u2264s\u22641018).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print \u22121 if such array a does not exist. Otherwise print n non-negative integers a1,a2,\u2026,an (0\u2264ai\u22641018)\u00a0\u2014 the answer.\nIn the first, the second, the fifth and the sixth test cases of the example it is possible to show that such array does not exist.\nIn the third testcase of the example a=[0,0,19]. The sum of elements in it is equal to 19, the beauty of it is equal to (\u230a06\u230b+\u230a06\u230b+\u230a196\u230b)=(0+0+3)=3.\nIn the fourth testcase of the example a=[0,3,3,3,29]. The sum of elements in it is equal to 38, the beauty of it is equal to (0+0+0+0+7)=7.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1713C": {
        "title": "C. Build Permutation",
        "description": "A 0-indexed array a of size n is called good if for all valid indices i (0\u2264i\u2264n\u22121), ai+i is a perfect square\u2020.\nGiven an integer n. Find a permutation\u2021 p of [0,1,2,\u2026,n\u22121] that is good or determine that no such permutation exists.\n\u2020 An integer x is said to be a perfect square if there exists an integer y such that x=y2.\n\u2021 An array b is a permutation of an array a if b consists of the elements of a in arbitrary order. For example, [4,2,3,4] is a permutation of [3,2,4,4] while [1,2,2] is not a permutation of [1,2,3].\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe only line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the length of the permutation p.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, output n distinct integers p0,p1,\u2026,pn\u22121 (0\u2264pi\u2264n\u22121) \u2014 the permutation p \u2014 if the answer exists, and \u22121 otherwise.\nIn the first test case, we have n=3. The array p=[1,0,2] is good since 1+0=12, 0+1=12, and 2+2=22\nIn the second test case, we have n=4. The array p=[0,3,2,1] is good since 0+0=02, 3+1=22, 2+2=22, and 1+3=22.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dp",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1713B": {
        "title": "B. Optimal Reduction",
        "description": "Consider an array a of n positive integers.\nYou may perform the following operation: \nLet's call f(a) the minimum number of operations needed to change array a into an array of n zeros.\nDetermine if for all permutations\u2020 b of a, f(a)\u2264f(b) is true. \n\u2020 An array b is a permutation of an array a if b consists of the elements of a in arbitrary order. For example, [4,2,3,4] is a permutation of [3,2,4,4] while [1,2,2] is not a permutation of [1,2,3].\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the length of the array a.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 description of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print \"YES\" (without quotes) if for all permutations b of a, f(a)\u2264f(b) is true, and \"NO\" (without quotes) otherwise.\nYou can output \"YES\" and \"NO\" in any case (for example, strings \"yEs\", \"yes\" and \"Yes\" will be recognized as a positive response).\nIn the first test case, we can change all elements to 0 in 5 operations. It can be shown that no permutation of [2,3,5,4] requires less than 5 operations to change all elements to 0.\nIn the third test case, we need 5 operations to change all elements to 0, while [2,3,3,1] only needs 3 operations.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1712C": {
        "title": "C. Sort Zero",
        "description": "You are given an array of n positive integers a1,a2,\u2026,an. \nIn one operation you do the following: \nFind the minimum number of operations required to sort the array in non-decreasing order.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105).\nThe second line of each test case contains n positive integers a1,a2,\u2026,an (1\u2264ai\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print one integer\u00a0\u2014 the minimum number of operations required to sort the array in non-decreasing order.\nIn the first test case, you can choose x=3 for the operation, the resulting array is [0,0,2].\nIn the second test case, you can choose x=1 for the first operation and x=3 for the second operation, the resulting array is [0,0,0,0].",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1708B": {
        "title": "B. Difference of GCDs",
        "description": "You are given three integers n, l, and r. You need to construct an array a1,a2,\u2026,an (l\u2264ai\u2264r) such that gcd(i,ai) are all distinct or report there's no solution.\nHere gcd(x,y) denotes the greatest common divisor (GCD) of integers x and y.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line contains three integers n, l, r (1\u2264n\u2264105, 1\u2264l\u2264r\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, if there is no solution, print \"NO\" (without quotes). You can print letters in any case (upper or lower).\nOtherwise, print \"YES\" (without quotes). In the next line, print n integers a1,a2,\u2026,an\u00a0\u2014 the array you construct.\nIf there are multiple solutions, you may output any.\nIn the first test case, gcd(1,a1),gcd(2,a2),\u2026,gcd(5,a5) are equal to 1, 2, 3, 4, 5, respectively.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1706B": {
        "title": "B. Making Towers",
        "description": "You have a sequence of n colored blocks. The color of the i-th block is ci, an integer between 1 and n.\nYou will place the blocks down in sequence on an infinite coordinate grid in the following way. \nA tower is formed by s blocks such that they are placed at positions (x,y),(x,y+1),\u2026,(x,y+s\u22121) for some position (x,y) and integer s. The size of the tower is s, the number of blocks in it. A tower of color r is a tower such that all blocks in it have the color r.\nFor each color r from 1 to n, solve the following problem independently: \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. \nThe first line of each test case contains a single integer n (1\u2264n\u2264105).\nThe second line of each test case contains n integers c1,c2,\u2026,cn (1\u2264ci\u2264n).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers. The r-th of them should be the maximum size of an tower of color r you can form by following the given rules. If you cannot form any tower of color r, the r-th integer should be 0.\nIn the first test case, one of the possible ways to form a tower of color 1 and size 3 is: \nThe blocks at positions (0,0), (0,1), and (0,2) all have color 1, forming an tower of size 3.\nIn the second test case, note that the following placement is not valid, since you are not allowed to place block 6 under block 5:\nIt can be shown that it is impossible to form a tower of color 4 and size 3.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1704C": {
        "title": "C. Virus",
        "description": "There are n houses numbered from 1 to n on a circle. For each 1\u2264i\u2264n\u22121, house i and house i+1 are neighbours; additionally, house n and house 1 are also neighbours.\nInitially, m of these n houses are infected by a deadly virus. Each morning, Cirno can choose a house which is uninfected and protect the house from being infected permanently.\nEvery day, the following things happen in order:\nCirno wants to stop the virus from spreading. Find the minimum number of houses that will be infected in the end, if she optimally choose the houses to protect.\nNote that every day Cirno always chooses a house to protect before the virus spreads. Also, a protected house will not be infected forever.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of test cases follows.\nThe first line of each test case consists of two positive integers n,m (5\u2264n\u2264109, 1\u2264m\u2264min(n,105)) \u2014 the number of houses on the circle, and the number of houses that are initially infected. \nThe second line of each test case consists of m distinct positive integers a1,a2,\u22ef,am (1\u2264ai\u2264n) \u2014 the indices of the houses infected initially.\nIt is guaranteed that the sum of m over all test cases does not exceed 105.\nFor each test case, output an integer on a separate line, which is the minimum number of infected houses in the end.\nIn the first test case:\nAt the start of the first day, house 3, 6, 8 are infected. Choose house 2 to protect.\nAt the start of the second day, house 3, 4, 5, 6, 7, 8, 9 are infected. Choose house 10 to protect.\nAt the start of the third day, no more houses are infected.\nIn the second test case:\nAt the start of the first day, house 2, 5 are infected. Choose house 1 to protect.\nAt the start of the second day, house 2, 3, 4, 5, 6 are infected. No more available houses can be protected.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1704B": {
        "title": "B. Luke is a Foodie",
        "description": "Luke likes to eat. There are n piles of food aligned in a straight line in front of him. The i-th pile contains ai units of food. \nLuke will walk from the 1-st pile towards the n-th pile, and he wants to eat every pile of food without walking back. When Luke reaches the i-th pile, he can eat that pile if and only if |v\u2212ai|\u2264x, where x is a fixed integer, and v is Luke's food affinity.\nBefore Luke starts to walk, he can set v to any integer. Also, for each i (1\u2264i\u2264n), Luke can change his food affinity to any integer before he eats the i-th pile.\nFind the minimum number of changes needed to eat every pile of food.\nNote that the initial choice for v is not considered as a change.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nFor each test case, the first line contains two integers, n,x (1\u2264n\u22642\u22c5105, 1\u2264x\u2264109) \u2014 the number of piles, and the maximum difference between the size of a pile and Luke's food affinity, such that Luke can eat the pile.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output an integer on a separate line, which is the minimum number of changes needed.\nIn the first test case, Luke can set v to 5 before he starts to walk. And he can walk straight to eat every piles of food without changing v.\nIn the second test case, Luke can set v to 3 before he starts to walk. And he could change v to 10 before he eats the second pile. After that, he can walk straight to eat remaining food without changing v.\nIn the fourth test case, Luke can set v to 3 before he starts to walk. And he could change v to 8 before he eats the sixth pile. After that, he can walk straight to eat remaining food without changing v.\nIn the fifth test case, Luke can set v to 4 before he starts to walk. And he could change v to 6 before he eats the fourth pile. Then he could change v to 12 before he eats the seventh pile. After that, he can walk straight to eat remaining food without changing v.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1703E": {
        "title": "E. Mirror Grid",
        "description": "You are given a square grid with n rows and n columns. Each cell contains either 0 or 1. \nIn an operation, you can select a cell of the grid and flip it (from 0\u21921 or 1\u21920). Find the minimum number of operations you need to obtain a square that remains the same when rotated 0\u2218, 90\u2218, 180\u2218 and 270\u2218.\nThe picture below shows an example of all rotations of a grid.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264100)\u00a0\u2014 the size of the grid.\nThen n lines follow, each with n characters ai,j (0\u2264ai,j\u22641)\u00a0\u2014 the number written in each cell.\nFor each test case output a single integer \u00a0\u2014 the minimum number of operations needed to make the square look the same rotated 0\u2218, 90\u2218, 180\u2218 and 270\u2218.\nIn the first test case, we can perform one operations to make the grid 010111010. Now, all rotations of the square are the same.\nIn the second test case, all rotations of the square are already the same, so we don't need any flips.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1703D": {
        "title": "D. Double Strings",
        "description": "You are given n strings s1,s2,\u2026,sn of length at most 8. \nFor each string si, determine if there exist two strings sj and sk such that si=sj+sk. That is, si is the concatenation of sj and sk. Note that j can be equal to k.\nRecall that the concatenation of strings s and t is s+t=s1s2\u2026spt1t2\u2026tq, where p and q are the lengths of strings s and t respectively. For example, concatenation of \"code\" and \"forces\" is \"codeforces\".\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of strings.\nThen n lines follow, the i-th of which contains non-empty string si of length at most 8, consisting of lowercase English letters. Among the given n strings, there may be equal (duplicates).\nThe sum of n over all test cases doesn't exceed 105.\nFor each test case, output a binary string of length n. The i-th bit should be 1 if there exist two strings sj and sk where si=sj+sk, and 0 otherwise. Note that j can be equal to k.\nIn the first test case, we have the following: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1702D": {
        "title": "D. Not a Cheap String",
        "description": "Let s be a string of lowercase Latin letters. Its price is the sum of the indices of letters (an integer between 1 and 26) that are included in it. For example, the price of the string abca is 1+2+3+1=7.\nThe string w and the integer p are given. Remove the minimal number of letters from w so that its price becomes less than or equal to p and print the resulting string. Note that the resulting string may be empty. You can delete arbitrary letters, they do not have to go in a row. If the price of a given string w is less than or equal to p, then nothing needs to be deleted and w must be output.\nNote that when you delete a letter from w, the order of the remaining letters is preserved. For example, if you delete the letter e from the string test, you get tst.\nThe first line of input contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases in the test. The following are descriptions of t test cases.\nEach case consists of two lines.\nThe first of them is the string w, it is non-empty and consists of lowercase Latin letters. Its length does not exceed 2\u22c5105.\nThe second line contains an integer p (1\u2264p\u22645200000).\nIt is guaranteed that the sum of string lengths w over all test cases does not exceed 2\u22c5105.\nOutput exactly t rows, the i-th of them should contain the answer to the i-th set of input data. Print the longest string that is obtained from w by deleting letters such that its price is less or equal to p. If there are several answers, then output any of them.\nNote that the empty string \u00a0\u2014 is one of the possible answers. In this case, just output an empty string.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1702C": {
        "title": "C. Train and Queries",
        "description": "Along the railroad there are stations indexed from 1 to 109. An express train always travels along a route consisting of n stations with indices u1,u2,\u2026,un, where (1\u2264ui\u2264109). The train travels along the route from left to right. It starts at station u1, then stops at station u2, then at u3, and so on. Station un\u00a0\u2014 the terminus.\nIt is possible that the train will visit the same station more than once. That is, there may be duplicates among the values u1,u2,\u2026,un.\nYou are given k queries, each containing two different integers aj and bj (1\u2264aj,bj\u2264109). For each query, determine whether it is possible to travel by train from the station with index aj to the station with index bj.\nFor example, let the train route consist of 6 of stations with indices [3,7,1,5,1,4] and give 3 of the following queries: \nIt is possible to travel from station 3 to station 5 by taking a section of the route consisting of stations [3,7,1,5]. Answer: YES. \nYou cannot travel from station 1 to station 7 because the train cannot travel in the opposite direction. Answer: NO. \nIt is not possible to travel from station 3 to station 10 because station 10 is not part of the train's route. Answer: NO. \nThe first line of the input contains an integer t (1\u2264t\u2264104)\u00a0\u2014the number of test cases in the test.\nThe descriptions of the test cases follow.\nThe first line of each test case is empty.\nThe second line of each test case contains two integers: n and k (1\u2264n\u22642\u22c5105,1\u2264k\u22642\u22c5105)\u00a0\u2014the number of stations the train route consists of and the number of queries.\nThe third line of each test case contains exactly n integers u1,u2,\u2026,un (1\u2264ui\u2264109). The values u1,u2,\u2026,un are not necessarily different.\nThe following k lines contain two different integers aj and bj (1\u2264aj,bj\u2264109) describing the query with index j.\nIt is guaranteed that the sum of n values over all test cases in the test does not exceed 2\u22c5105. Similarly, it is guaranteed that the sum of k values over all test cases in the test also does not exceed 2\u22c5105\nFor each test case, output on a separate line:\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\nThe first test case is explained in the problem statement.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1700B": {
        "title": "B. Palindromic Numbers",
        "description": "During a daily walk Alina noticed a long number written on the ground. Now Alina wants to find some positive number of same length without leading zeroes, such that the sum of these two numbers is a palindrome. \nRecall that a number is called a palindrome, if it reads the same right to left and left to right. For example, numbers 121,66,98989 are palindromes, and 103,239,1241 are not palindromes.\nAlina understands that a valid number always exist. Help her find one!\nThe first line of input data contains an integer t (1\u2264t\u2264100) \u2014 the number of test cases. Next, descriptions of t test cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u2264100000) \u2014 the length of the number that is written on the ground.\nThe second line of contains the positive n-digit integer without leading zeroes \u2014 the number itself.\nIt is guaranteed that the sum of the values n over all test cases does not exceed 100000.\nFor each of t test cases print an answer \u2014 a positive n-digit integer without leading zeros, such that the sum of the input integer and this number is a palindrome.\nWe can show that at least one number satisfying the constraints exists. If there are multiple solutions, you can output any of them.\nIn the first test case 99+32=131 is a palindrome. Note that another answer is 12, because 99+12=111 is also a palindrome.\nIn the second test case 1023+8646=9669.\nIn the third test case 385+604=989.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1695B": {
        "title": "B. Circle Game",
        "description": "Mike and Joe are playing a game with some stones. Specifically, they have n piles of stones of sizes a1,a2,\u2026,an. These piles are arranged in a circle.\nThe game goes as follows. Players take turns removing some positive number of stones from a pile in clockwise order starting from pile 1. Formally, if a player removed stones from pile i on a turn, the other player removes stones from pile ((imodn)+1) on the next turn.\nIf a player cannot remove any stones on their turn (because the pile is empty), they lose. Mike goes first.\nIf Mike and Joe play optimally, who will win?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u226450) \u00a0\u2014 the number of piles.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u00a0\u2014 the size of the piles.\nFor each test case print the winner of the game, either \"Mike\" or \"Joe\" on its own line (without quotes).\nIn the first test case, Mike just takes all 37 stones on his first turn.\nIn the second test case, Joe can just copy Mike's moves every time. Since Mike went first, he will hit 0 on the first pile one move before Joe does so on the second pile.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "games",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1694B": {
        "title": "B. Paranoid String",
        "description": "Let's call a binary string T of length m indexed from 1 to m paranoid if we can obtain a string of length 1 by performing the following two kinds of operations m\u22121 times in any order :\nFor example, if T= 001, we can select the substring [T2T3] and perform the first operation. So we obtain T= 01.\nYou are given a binary string S of length n indexed from 1 to n. Find the number of pairs of integers (l,r) 1\u2264l\u2264r\u2264n such that S[l\u2026r] (the substring of S from l to r) is a paranoid string. \nThe first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the size of S.\nThe second line of each test case contains a binary string S of n characters S1S2\u2026Sn. (Si= 0 or Si= 1 for each 1\u2264i\u2264n)\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output the number of pairs of integers (l,r) 1\u2264l\u2264r\u2264n such that S[l\u2026r] (the substring of S from l to r) is a paranoid string. \nIn the first sample, S already has length 1 and doesn't need any operations.\nIn the second sample, all substrings of S are paranoid. For the entire string, it's enough to perform the first operation.\nIn the third sample, all substrings of S are paranoid except [S2S3], because we can't perform any operations on it, and [S1S2S3] (the entire string).",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1692E": {
        "title": "E. Binary Deque",
        "description": "Slavic has an array of length n consisting only of zeroes and ones. In one operation, he removes either the first or the last element of the array. \nWhat is the minimum number of operations Slavic has to perform such that the total sum of the array is equal to s after performing all the operations? In case the sum s can't be obtained after any amount of operations, you should output -1.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers n and s (1\u2264n,s\u22642\u22c5105)\u00a0\u2014 the length of the array and the needed sum of elements.\nThe second line of each test case contains n integers ai (0\u2264ai\u22641)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, output a single integer\u00a0\u2014 the minimum amount of operations required to have the total sum of the array equal to s, or -1 if obtaining an array with sum s isn't possible.\nIn the first test case, the sum of the whole array is 1 from the beginning, so we don't have to make any operations.\nIn the second test case, the sum of the array is 2 and we want it to be equal to 1, so we should remove the first element. The array turns into [1,0], which has a sum equal to 1.\nIn the third test case, the sum of the array is 5 and we need it to be 3. We can obtain such a sum by removing the first two elements and the last element, doing a total of three operations. The array turns into [0,1,1,1,0,0], which has a sum equal to 3.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "implementation",
            "two pointers",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1692D": {
        "title": "D. The Clock",
        "description": "Victor has a 24-hour clock that shows the time in the format \"HH:MM\" (00 \u2264 HH \u2264 23, 00 \u2264 MM \u2264 59). He looks at the clock every x minutes, and the clock is currently showing time s. \nHow many different palindromes will Victor see in total after looking at the clock every x minutes, the first time being at time s?\nFor example, if the clock starts out as 03:12 and Victor looks at the clock every 360 minutes (i.e. every 6 hours), then he will see the times 03:12, 09:12, 15:12, 21:12, 03:12, and the times will continue to repeat. Here the time 21:12 is the only palindrome he will ever see, so the answer is 1.\nA palindrome is a string that reads the same backward as forward. For example, the times 12:21, 05:50, 11:11 are palindromes but 13:13, 22:10, 02:22 are not.\nThe first line of the input contains an integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of each test case follows.\nThe only line of each test case contains a string s of length 5 with the format \"HH:MM\" where \"HH\" is from \"00\" to \"23\" and \"MM\" is from \"00\" to \"59\" (both \"HH\" and \"MM\" have exactly two digits) and an integer x (1\u2264x\u22641440)\u00a0\u2014 the number of minutes Victor takes to look again at the clock.\nFor each test case, output a single integer\u00a0\u2014 the number of different palindromes Victor will see if he looks at the clock every x minutes starting from time s.\nThe first test case is explained in the statement.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1691B": {
        "title": "B. Shoe Shuffling",
        "description": "A class of students got bored wearing the same pair of shoes every day, so they decided to shuffle their shoes among themselves. In this problem, a pair of shoes is inseparable and is considered as a single object.\nThere are n students in the class, and you are given an array s in non-decreasing order, where si is the shoe size of the i-th student. A shuffling of shoes is valid only if no student gets their own shoes and if every student gets shoes of size greater than or equal to their size. \nYou have to output a permutation p of {1,2,\u2026,n} denoting a valid shuffling of shoes, where the i-th student gets the shoes of the pi-th student (pi\u2260i). And output \u22121 if a valid shuffling does not exist.\nA permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of students.\nThe second line of each test case contains n integers s1,s2,\u2026,sn (1\u2264si\u2264109, and for all 1\u2264i<n, si\u2264si+1) \u2014 the shoe sizes of the students.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print the answer in a single line using the following format.\nIf a valid shuffling does not exist, print the number \u22121 as the answer.\nIf a valid shuffling exists, print n space-separated integers \u2014 a permutation p of 1,2,\u2026,n denoting a valid shuffling of shoes where the i-th student gets the shoes of the pi-th student. If there are multiple answers, then print any of them.\nIn the first test case, any permutation p of 1,\u2026,n where pi\u2260i would represent a valid shuffling since all students have equal shoe sizes, and thus anyone can wear anyone's shoes.\nIn the second test case, it can be shown that no valid shuffling is possible.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1690D": {
        "title": "D. Black and White Stripe",
        "description": "You have a stripe of checkered paper of length nn. Each cell is either white or black.\nWhat is the minimum number of cells that must be recolored from white to black in order to have a segment of k consecutive black cells on the stripe?\nIf the input data is such that a segment of k consecutive black cells already exists, then print 0. \nThe first line contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nNext, descriptions of t test cases follow.\nThe first line of the input contains two integers n and k (1\u2264k\u2264n\u22642\u22c5105). The second line consists of the letters 'W' (white) and 'B' (black). The line length is n.\nIt is guaranteed that the sum of values n does not exceed 2\u22c5105.\nFor each of t test cases print an integer\u00a0\u2014 the minimum number of cells that need to be repainted from white to black in order to have a segment of k consecutive black cells.\nIn the first test case, s=\"BBWBW\" and k=3. It is enough to recolor s3 and get s=\"BBBBW\". This string contains a segment of length k=3 consisting of the letters 'B'.\nIn the second test case of the example s=\"BBWBW\" and k=5. It is enough to recolor s3 and s5 and get s=\"BBBBB\". This string contains a segment of length k=5 consisting of the letters 'B'.\nIn the third test case of the example s=\"BBWBW\" and k=1. The string s already contains a segment of length k=1 consisting of the letters 'B'.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "two pointers",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1685A": {
        "title": "A. Circular Local MiniMax",
        "description": "You are given n integers a1,a2,\u2026,an. Is it possible to arrange them on a circle so that each number is strictly greater than both its neighbors or strictly smaller than both its neighbors?\nIn other words, check if there exists a rearrangement b1,b2,\u2026,bn of the integers a1,a2,\u2026,an such that for each i from 1 to n at least one of the following conditions holds:\nTo make sense of the previous formulas for i=1 and i=n, one shall define b0=bn and bn+1=b1.\nThe first line of the input contains a single integer t (1\u2264t\u22643\u22c5104) \u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (3\u2264n\u2264105) \u00a0\u2014 the number of integers.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109).\nThe sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, if it is not possible to arrange the numbers on the circle satisfying the conditions from the statement, output NO. You can output each letter in any case.\nOtherwise, output YES. In the second line, output n integers b1,b2,\u2026,bn, which are a rearrangement of a1,a2,\u2026,an and satisfy the conditions from the statement. If there are multiple valid ways to arrange the numbers, you can output any of them.\nIt can be shown that there are no valid arrangements for the first and the third test cases.\nIn the second test case, the arrangement [1,8,4,9] works. In this arrangement, 1 and 4 are both smaller than their neighbors, and 8,9 are larger.\nIn the fourth test case, the arrangement [1,11,1,111,1,1111] works. In this arrangement, the three elements equal to 1 are smaller than their neighbors, while all other elements are larger than their neighbors.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1682B": {
        "title": "B. AND Sorting",
        "description": "You are given a permutation p of integers from 0 to n\u22121 (each of them occurs exactly once). Initially, the permutation is not sorted (that is, pi>pi+1 for at least one 1\u2264i\u2264n\u22121). \nThe permutation is called X-sortable for some non-negative integer X if it is possible to sort the permutation by performing the operation below some finite number of times: \nHere & denotes the bitwise AND operation.\nFind the maximum value of X such that p is X-sortable. It can be shown that there always exists some value of X such that p is X-sortable.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases. Description of test cases follows.\nThe first line of each test case contains a single integer n (2\u2264n\u22642\u22c5105) \u00a0\u2014 the length of the permutation.\nThe second line of each test case contains n integers p1,p2,...,pn (0\u2264pi\u2264n\u22121, all pi are distinct) \u00a0\u2014 the elements of p. It is guaranteed that p is not sorted.\nIt is guaranteed that the sum of n over all cases does not exceed 2\u22c5105.\nFor each test case output a single integer \u2014 the maximum value of X such that p is X-sortable.\nIn the first test case, the only X for which the permutation is X-sortable are X=0 and X=2, maximum of which is 2.\nSorting using X=0: \nSorting using X=2: \nIn the second test case, we must swap p1 and p2 which is possible only with X=0.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1681C": {
        "title": "C. Double Sort",
        "description": "You are given two arrays a and b, both consisting of n integers.\nIn one move, you can choose two indices i and j (1\u2264i,j\u2264n; i\u2260j) and swap ai with aj and bi with bj. You have to perform the swap in both arrays.\nYou are allowed to perform at most 104 moves (possibly, zero). Can you make both arrays sorted in a non-decreasing order at the end? If you can, print any sequence of moves that makes both arrays sorted.\nThe first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (2\u2264n\u2264100)\u00a0\u2014 the number of elements in both arrays.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 the first array.\nThe third line contains n integers b1,b2,\u2026,bn (1\u2264bi\u2264n)\u00a0\u2014 the second array.\nFor each testcase, print the answer. If it's impossible to make both arrays sorted in a non-decreasing order in at most 104 moves, print -1. Otherwise, first, print the number of moves k (0\u2264k\u2264104). Then print i and j for each move (1\u2264i,j\u2264n; i\u2260j).\nIf there are multiple answers, then print any of them. You don't have to minimize the number of moves.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1679B": {
        "title": "B. Stone Age Problem",
        "description": "Once upon a time Mike and Mike decided to come up with an outstanding problem for some stage of ROI (rare olympiad in informatics). One of them came up with a problem prototype but another stole the idea and proposed that problem for another stage of the same olympiad. Since then the first Mike has been waiting for an opportunity to propose the original idea for some other contest... Mike waited until this moment!\nYou are given an array aa of n integers. You are also given q queries of two types:\nAfter performing each query you have to calculate the sum of all elements in the array.\nThe first line contains two integers n and q (1\u2264n,q\u22642\u22c5105)\u00a0\u2014 the number of elements in the array and the number of queries, respectively.\nThe second line contains n integers a1,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 elements of the array a.\nEach of the following q lines contains a description of the corresponding query. Description begins with integer t (t\u2208{1,2}) which denotes a type of the query:\nPrint q integers, each on a separate line. In the i-th line print the sum of all elements in the array after performing the first i queries.\nConsider array from the example and the result of performing each query:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1676E": {
        "title": "E. Eating Queries",
        "description": "Timur has nn candies. The i-th candy has a quantity of sugar equal to ai. So, by eating the i-th candy, Timur consumes a quantity of sugar equal to ai.\nTimur will ask you q queries regarding his candies. For the j-th query you have to answer what is the minimum number of candies he needs to eat in order to reach a quantity of sugar greater than or equal to xj or print -1 if it's not possible to obtain such a quantity. In other words, you should print the minimum possible k such that after eating k candies, Timur consumes a quantity of sugar of at least xj or say that no possible k exists.\nNote that he can't eat the same candy twice and queries are independent of each other (Timur can use the same candy in different queries).\nThe first line of input contains a single integer t (1\u2264t\u22641000) \u00a0\u2014 the number of test cases. The description of test cases follows.\nThe first line contains 2 integers n and q (1\u2264n,q\u22641.5\u22c5105)\u00a0\u2014 the number of candies Timur has and the number of queries you have to print an answer for respectively.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264104)\u00a0\u2014 the quantity of sugar in each of the candies respectively.\nThen q lines follow. \nEach of the next q lines contains a single integer xj (1\u2264xj\u22642\u22c5109)\u00a0\u2013 the quantity Timur wants to reach for the given query.\nIt is guaranteed that the sum of n and the sum of q over all test cases do not exceed 1.5\u22c5105.\nFor each test case output q lines. For the j-th line output the number of candies Timur needs to eat in order to reach a quantity of sugar greater than or equal to xj or print -1 if it's not possible to obtain such a quantity.\nFor the first test case:\nFor the first query, Timur can eat any candy, and he will reach the desired quantity.\nFor the second query, Timur can reach a quantity of at least 10 by eating the 7-th and the 8-th candies, thus consuming a quantity of sugar equal to 14.\nFor the third query, there is no possible answer.\nFor the fourth query, Timur can reach a quantity of at least 14 by eating the 7-th and the 8-th candies, thus consuming a quantity of sugar equal to 14.\nFor the second test case:\nFor the only query of the second test case, we can choose the third candy from which Timur receives exactly 3 sugar. It's also possible to obtain the same answer by choosing the fourth candy.",
        "time_limit": "time limit per test3.5 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1676D": {
        "title": "D. X-Sum",
        "description": "Timur's grandfather gifted him a chessboard to practice his chess skills. This chessboard is a grid a with n rows and m columns with each cell having a non-negative integer written on it. \nTimur's challenge is to place a bishop on the board such that the sum of all cells attacked by the bishop is maximal. The bishop attacks in all directions diagonally, and there is no limit to the distance which the bishop can attack. Note that the cell on which the bishop is placed is also considered attacked. Help him find the maximal sum he can get.\nThe first line of the input contains a single integer t (1\u2264t\u22641000) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains the integers n and m (1\u2264n\u2264200, 1\u2264m\u2264200).\nThe following n lines contain m integers each, the j-th element of the i-th line aij is the number written in the j-th cell of the i-th row (0\u2264aij\u2264106)\nIt is guaranteed that the sum of n\u22c5m over all test cases does not exceed 4\u22c5104.\nFor each test case output a single integer, the maximum sum over all possible placements of the bishop.\nFor the first test case here the best sum is achieved by the bishop being in this position: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1675C": {
        "title": "C. Detective Task",
        "description": "Polycarp bought a new expensive painting and decided to show it to his n friends. He hung it in his room. n of his friends entered and exited there one by one. At one moment there was no more than one person in the room. In other words, the first friend entered and left first, then the second, and so on.\nIt is known that at the beginning (before visiting friends) a picture hung in the room. At the end (after the n-th friend) it turned out that it disappeared. At what exact moment it disappeared\u00a0\u2014 there is no information.\nPolycarp asked his friends one by one. He asked each one if there was a picture when he entered the room. Each friend answered one of three:\nEveryone except the thief either doesn't remember or told the truth. The thief can say anything (any of the three options).\nPolycarp cannot understand who the thief is. He asks you to find out the number of those who can be considered a thief according to the answers.\nThe first number t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases in the test.\nThe following is a description of test cases.\nThe first line of each test case contains one string s (length does not exceed 2\u22c5105)\u00a0\u2014 a description of the friends' answers, where si indicates the answer of the i-th friend. Each character in the string is either 0 or 1 or ?.\nThe given regularity is described in the actual situation. In particular, on the basis of answers, at least one friend can be suspected of stealing a painting.\nIt is guaranteed that the sum of string lengths over the entire input data set does not exceed 2\u22c5105.\nOutput one positive (strictly more zero) number\u00a0\u2013 the number of people who could steal the picture based on the data shown.\nIn the first case, the answer is 1 since we had exactly 1 friend.\nThe second case is similar to the first.\nIn the third case, the suspects are the third and fourth friends (we count from one). It can be shown that no one else could be the thief.\nIn the fourth case, we know absolutely nothing, so we suspect everyone.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1674D": {
        "title": "D. A-B-C Sort",
        "description": "You are given three arrays a, b and c. Initially, array a consists of n elements, arrays b and c are empty.\nYou are performing the following algorithm that consists of two steps: \nCan you make array c sorted in non-decreasing order?\nThe first line contains a single integer t (1\u2264t\u22642\u22c5104)\u00a0\u2014 the number of test cases. Next t cases follow.\nThe first line of each test case contains the single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106)\u00a0\u2014 the array a itself.\nIt's guaranteed that the sum of n doesn't exceed 2\u22c5105.\nFor each test, print YES (case-insensitive), if you can make array c sorted in non-decreasing order. Otherwise, print NO (case-insensitive).\nIn the first test case, we can do the following for a=[3,1,5,3]:\nStep 1: \n\nStep 2: \n",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1674C": {
        "title": "C. Infinite Replacement",
        "description": "You are given a string s, consisting only of Latin letters 'a', and a string t, consisting of lowercase Latin letters.\nIn one move, you can replace any letter 'a' in the string s with a string t. Note that after the replacement string s might contain letters other than 'a'.\nYou can perform an arbitrary number of moves (including zero). How many different strings can you obtain? Print the number, or report that it is infinitely large.\nTwo strings are considered different if they have different length, or they differ at some index.\nThe first line contains a single integer q (1\u2264q\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a non-empty string s, consisting only of Latin letters 'a'. The length of s doesn't exceed 50.\nThe second line contains a non-empty string t, consisting of lowercase Latin letters. The length of t doesn't exceed 50.\nFor each testcase, print the number of different strings s that can be obtained after an arbitrary amount of moves (including zero). If the number is infinitely large, print -1. Otherwise, print the number.\nIn the first example, you can replace any letter 'a' with the string \"a\", but that won't change the string. So no matter how many moves you make, you can't obtain a string other than the initial one.\nIn the second example, you can replace the second letter 'a' with \"abc\". String s becomes equal to \"aabc\". Then the second letter 'a' again. String s becomes equal to \"aabcbc\". And so on, generating infinitely many different strings.\nIn the third example, you can either leave string s as is, performing zero moves, or replace the only 'a' with \"b\". String s becomes equal to \"b\", so you can't perform more moves on it.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "implementation",
            "strings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1673B": {
        "title": "B. A Perfectly Balanced String?",
        "description": "Let's call a string s perfectly balanced if for all possible triplets (t,u,v) such that t is a non-empty substring of s and u and v are characters present in s, the difference between the frequencies of u and v in t is not more than 1.\nFor example, the strings \"aba\" and \"abc\" are perfectly balanced but \"abb\" is not because for the triplet (\"bb\",'a','b'), the condition is not satisfied.\nYou are given a string s consisting of lowercase English letters only. Your task is to determine whether s is perfectly balanced or not.\nA string b is called a substring of another string a if b can be obtained by deleting some characters (possibly 0) from the start and some characters (possibly 0) from the end of a.\nThe first line of input contains a single integer t (1\u2264t\u22642\u22c5104) denoting the number of testcases.\nEach of the next t lines contain a single string s (1\u2264|s|\u22642\u22c5105), consisting of lowercase English letters.\nIt is guaranteed that the sum of |s| over all testcases does not exceed 2\u22c5105.\nFor each test case, print \"YES\" if s is a perfectly balanced string, and \"NO\" otherwise.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).\nLet ft(c) represent the frequency of character c in string t.\nFor the first testcase we have \n\nFor the second testcase we have \n\nFor the third testcase we have \n\nIt can be seen that for any substring t of s and any two characters u,v\u2208{a,b,c}, the difference between ft(u) and ft(v) is not more than 1. Hence the string s is perfectly balanced.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1672C": {
        "title": "C. Unequal Array",
        "description": "You are given an array a of length n. We define the equality of the array as the number of indices 1\u2264i\u2264n\u22121 such that ai=ai+1. We are allowed to do the following operation:\nFind the minimum number of operations needed such that the equality of the array is less than or equal to 1.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (2\u2264n\u22642\u22c5105) \u2014 the length of array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109) \u2014 elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105\nFor each test case, print the minimum number of operations needed.\nIn the first test case, we can select i=2 and x=2 to form [1,2,2,1,1]. Then, we can select i=3 and x=3 to form [1,2,3,3,1].\nIn the second test case, we can select i=3 and x=100 to form [2,1,100,100,2].",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1671C": {
        "title": "C. Dolce Vita",
        "description": "Turbulent times are coming, so you decided to buy sugar in advance. There are n shops around that sell sugar: the i-th shop sells one pack of sugar for ai coins, but only one pack to one customer each day. So in order to buy several packs, you need to visit several shops.\nAnother problem is that prices are increasing each day: during the first day the cost is ai, during the second day cost is ai+1, during the third day\u00a0\u2014 ai+2 and so on for each shop i.\nOn the contrary, your everyday budget is only x coins. In other words, each day you go and buy as many packs as possible with total cost not exceeding x. Note that if you don't spend some amount of coins during a day, you can't use these coins during the next days.\nEventually, the cost for each pack will exceed x, and you won't be able to buy even a single pack. So, how many packs will you be able to buy till that moment in total?\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases. Next t cases follow.\nThe first line of each test case contains two integers n and x (1\u2264n\u22642\u22c5105; 1\u2264x\u2264109)\u00a0\u2014 the number of shops and your everyday budget.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the initial cost of one pack in each shop.\nIt's guaranteed that the total sum of n doesn't exceed 2\u22c5105.\nFor each test case, print one integer\u00a0\u2014 the total number of packs you will be able to buy until prices exceed your everyday budget.\nIn the first test case, \nIn the second test case, prices are too high even at the first day, so you can't buy anything.\nIn the third test case, you can buy only one pack at day one.\nIn the fourth test case, you can buy 2 packs first 500 days. At day 501 prices are [501,501], so you can buy only 1 pack the next 500 days. At day 1001 prices are [1001,1001] so can't buy anymore. In total, you bought 500\u22c52+500\u22c51=1500 packs.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1671B": {
        "title": "B. Consecutive Points Segment",
        "description": "You are given n points with integer coordinates on a coordinate axis OX. The coordinate of the i-th point is xi. All points' coordinates are distinct and given in strictly increasing order.\nFor each point i, you can do the following operation no more than once: take this point and move it by 1 to the left or to the right (i..e., you can change its coordinate xi to xi\u22121 or to xi+1). In other words, for each point, you choose (separately) its new coordinate. For the i-th point, it can be either xi\u22121, xi or xi+1.\nYour task is to determine if you can move some points as described above in such a way that the new set of points forms a consecutive segment of integers, i.\u2009e. for some integer l the coordinates of points should be equal to l,l+1,\u2026,l+n\u22121.\nNote that the resulting points should have distinct coordinates.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. Then t test cases follow.\nThe first line of the test case contains one integer n (1\u2264n\u22642\u22c5105) \u2014 the number of points in the set x.\nThe second line of the test case contains n integers x1<x2<\u2026<xn (1\u2264xi\u2264106), where xi is the coordinate of the i-th point.\nIt is guaranteed that the points are given in strictly increasing order (this also means that all coordinates are distinct). It is also guaranteed that the sum of n does not exceed 2\u22c5105 (\u2211n\u22642\u22c5105).\nFor each test case, print the answer \u2014 if the set of points from the test case can be moved to form a consecutive segment of integers, print YES, otherwise print NO.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1670B": {
        "title": "B. Dorms War",
        "description": "Hosssam decided to sneak into Hemose's room while he is sleeping and change his laptop's password. He already knows the password, which is a string s of length n. He also knows that there are k special letters of the alphabet: c1,c2,\u2026,ck.\nHosssam made a program that can do the following.\nFor example, suppose the string s is \"abcdef\" and the special characters are 'b' and 'd'. If he runs the program once, the positions 1 and 3 will be deleted as they come before special characters, so the password becomes \"bdef\". If he runs the program again, it deletes position 1, and the password becomes \"def\". If he is wise, he won't run it a third time.\nHosssam wants to know how many times he can run the program on Hemose's laptop without waking him up from the sound of the error message. Can you help him?\nThe first line contains a single integer t (1\u2264t\u2264105) \u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105) \u2014 the initial length of the password.\nThe next line contains a string s consisting of n lowercase English letters \u2014 the initial password.\nThe next line contains an integer k (1\u2264k\u226426), followed by k distinct lowercase letters c1,c2,\u2026,ck \u2014 the special letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print the maximum number of times Hosssam can run the program without displaying the error message, on a new line.\nIn the first test case, the program can run 5 times as follows: iloveslim\u2192ilovslim\u2192iloslim\u2192ilslim\u2192islim\u2192slim\nIn the second test case, the program can run 2 times as follows: joobeel\u2192oel\u2192el\nIn the third test case, the program can run 3 times as follows: basiozi\u2192bioi\u2192ii\u2192i.\nIn the fourth test case, the program can run 5 times as follows: khater\u2192khatr\u2192khar\u2192khr\u2192kr\u2192r\nIn the fifth test case, the program can run only once as follows: abobeih\u2192h\nIn the sixth test case, the program cannot run as none of the characters in the password is a special character.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1669G": {
        "title": "G. Fall Down",
        "description": "There is a grid with n rows and m columns, and three types of cells: \nAll stones fall down until they meet the floor (the bottom row), an obstacle, or other stone which is already immovable. (In other words, all the stones just fall down as long as they can fall.)\nSimulate the process. What does the resulting grid look like?\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u226450)\u00a0\u2014 the number of rows and the number of columns in the grid, respectively.\nThen n lines follow, each containing m characters. Each of these characters is either '.', '*', or 'o'\u00a0\u2014 an empty cell, a stone, or an obstacle, respectively.\nFor each test case, output a grid with n rows and m columns, showing the result of the process.\nYou don't need to output a new line after each test, it is in the samples just for clarity.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dfs and similar",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1669F": {
        "title": "F. Eating Candies",
        "description": "There are n candies put from left to right on a table. The candies are numbered from left to right. The i-th candy has weight wi. Alice and Bob eat candies. \nAlice can eat any number of candies from the left (she can't skip candies, she eats them in a row). \nBob can eat any number of candies from the right (he can't skip candies, he eats them in a row). \nOf course, if Alice ate a candy, Bob can't eat it (and vice versa).\nThey want to be fair. Their goal is to eat the same total weight of candies. What is the most number of candies they can eat in total?\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of candies on the table.\nThe second line of each test case contains n integers w1,w2,\u2026,wn (1\u2264wi\u2264104)\u00a0\u2014 the weights of candies from left to right.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print a single integer\u00a0\u2014 the maximum number of candies Alice and Bob can eat in total while satisfying the condition.\nFor the first test case, Alice will eat one candy from the left and Bob will eat one candy from the right. There is no better way for them to eat the same total amount of weight. The answer is 2 because they eat two candies in total.\nFor the second test case, Alice will eat the first three candies from the left (with total weight 7) and Bob will eat the first three candies from the right (with total weight 7). They cannot eat more candies since all the candies have been eaten, so the answer is 6 (because they eat six candies in total).\nFor the third test case, there is no way Alice and Bob will eat the same non-zero weight so the answer is 0.\nFor the fourth test case, Alice will eat candies with weights [7,3,20] and Bob will eat candies with weights [10,8,11,1], they each eat 30 weight. There is no better partition so the answer is 7.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "data structures",
            "greedy",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1669E": {
        "title": "E. 2-Letter Strings",
        "description": "Given n strings, each of length 2, consisting of lowercase Latin alphabet letters from 'a' to 'k', output the number of pairs of indices (i,j) such that i<j and the i-th string and the j-th string differ in exactly one position.\nIn other words, count the number of pairs (i,j) (i<j) such that the i-th string and the j-th string have exactly one position p (1\u2264p\u22642) such that sip\u2260sjp.\nThe answer may not fit into 32-bit integer type, so you should use 64-bit integers like long long in C++ to avoid integer overflow.\nThe first line of the input contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. The description of test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the number of strings.\nThen follows n lines, the i-th of which containing a single string si of length 2, consisting of lowercase Latin letters from 'a' to 'k'.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print a single integer \u2014 the number of pairs (i,j) (i<j) such that the i-th string and the j-th string have exactly one position p (1\u2264p\u22642) such that sip\u2260sjp. \nPlease note, that the answer for some test cases won't fit into 32-bit integer type, so you should use at least 64-bit integer type in your programming language (like long long for C++).\nFor the first test case the pairs that differ in exactly one position are: (\"ab\", \"cb\"), (\"ab\", \"db\"), (\"ab\", \"aa\"), (\"cb\", \"db\") and (\"cb\", \"cc\").\nFor the second test case the pairs that differ in exactly one position are: (\"aa\", \"ac\"), (\"aa\", \"ca\"), (\"cc\", \"ac\"), (\"cc\", \"ca\"), (\"ac\", \"aa\") and (\"ca\", \"aa\").\nFor the third test case, the are no pairs satisfying the conditions.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "math",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1669D": {
        "title": "D. Colorful Stamp",
        "description": "A row of n cells is given, all initially white. Using a stamp, you can stamp any two neighboring cells such that one becomes red and the other becomes blue. A stamp can be rotated, i.e. it can be used in both ways: as BR and as RB.\nDuring use, the stamp must completely fit on the given n cells (it cannot be partially outside the cells). The stamp can be applied multiple times to the same cell. Each usage of the stamp recolors both cells that are under the stamp.\nFor example, one possible sequence of stamps to make the picture BRBBW could be WWWWW\u2192WWRB_W\u2192BR_RBW\u2192BRB_BW. Here W, R, and B represent a white, red, or blue cell, respectively, and the cells that the stamp is used on are marked with an underline.\nGiven a final picture, is it possible to make it using the stamp zero or more times?\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the picture.\nThe second line of each test case contains a string s\u00a0\u2014 the picture you need to make. It is guaranteed that the length of s is n and that s only consists of the characters W, R, and B, representing a white, red, or blue cell, respectively.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nOutput t lines, each of which contains the answer to the corresponding test case. As an answer, output \"YES\" if it possible to make the picture using the stamp zero or more times, and \"NO\" otherwise.\nYou can output the answer in any case (for example, the strings \"yEs\", \"yes\", \"Yes\" and \"YES\" will be recognized as a positive answer).\nThe first test case is explained in the statement.\nFor the second, third, and fourth test cases, it is not possible to stamp a single cell, so the answer is \"NO\".\nFor the fifth test case, you can use the stamp as follows: WWW\u2192WRB_\u2192BR_B.\nFor the sixth test case, you can use the stamp as follows: WWW\u2192WRB_\u2192RB_B.\nFor the seventh test case, you don't need to use the stamp at all.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1659A": {
        "title": "A. Red Versus Blue",
        "description": "Team Red and Team Blue competed in a competitive FPS. Their match was streamed around the world. They played a series of n matches.\nIn the end, it turned out Team Red won r times and Team Blue won b times. Team Blue was less skilled than Team Red, so b was strictly less than r.\nYou missed the stream since you overslept, but you think that the match must have been neck and neck since so many people watched it. So you imagine a string of length n where the i-th character denotes who won the i-th match \u00a0\u2014 it is R if Team Red won or B if Team Blue won. You imagine the string was such that the maximum number of times a team won in a row was as small as possible. For example, in the series of matches RBBRRRB, Team Red won 3 times in a row, which is the maximum.\nYou must find a string satisfying the above conditions. If there are multiple answers, print any.\nThe first line contains a single integer t (1\u2264t\u22641000) \u00a0\u2014 the number of test cases.\nEach test case has a single line containing three integers n, r, and b (3\u2264n\u2264100; 1\u2264b<r\u2264n, r+b=n).\nFor each test case, output a single line containing a string satisfying the given conditions. If there are multiple answers, print any.\nThe first test case of the first example gives the optimal answer for the example in the statement. The maximum number of times a team wins in a row in RBRBRBR is 1. We cannot minimize it any further.\nThe answer for the second test case of the second example is RRBRBRBRBR. The maximum number of times a team wins in a row is 2, given by RR at the beginning. We cannot minimize the answer any further.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1657C": {
        "title": "C. Bracket Sequence Deletion",
        "description": "You are given a bracket sequence consisting of nn characters '(' and/or )'. You perform several operations with it.\nDuring one operation, you choose the shortest prefix of this string (some amount of first characters of the string) that is good and remove it from the string.\nThe prefix is considered good if one of the following two conditions is satisfied:\nA bracket sequence is called regular if it is possible to obtain a correct arithmetic expression by inserting characters '+' and '1' into this sequence. For example, sequences (())(), () and (()(())) are regular, while )(, (() and (()))( are not.\nThe bracket sequence is called palindrome if it reads the same back and forth. For example, the bracket sequences )), (( and )(() are palindromes, while bracket sequences (), )( and ))( are not palindromes.\nYou stop performing the operations when it's not possible to find a good prefix. Your task is to find the number of operations you will perform on the given string and the number of remaining characters in the string.\nYou have to answer t independent test cases.\nThe first line of the input contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases. The next 2t lines describe test cases.\nThe first line of the test case contains one integer n (1\u2264n\u22645\u22c5105) \u2014 the length of the bracket sequence.\nThe second line of the test case contains n characters '(' and/or ')' \u2014 the bracket sequence itself.\nIt is guaranteed that the sum of n over all test cases do not exceed 5\u22c5105 (\u2211n\u22645\u22c5105).\nFor each test case, print two integers c and r \u2014 the number of operations you will perform on the given bracket sequence and the number of characters that remain in the string after performing all operations.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1656C": {
        "title": "C. Make Equal With Mod",
        "description": "You are given an array of n non-negative integers a1,a2,\u2026,an. You can make the following operation: choose an integer x\u22652 and replace each number of the array by the remainder when dividing that number by x, that is, for all 1\u2264i\u2264n set ai to aimodx.\nDetermine if it is possible to make all the elements of the array equal by applying the operation zero or more times.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264105) \u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109) where ai is the i-th element of the array.\nThe sum of n for all test cases is at most 2\u22c5105.\nFor each test case, print a line with YES if you can make all elements of the list equal by applying the operation. Otherwise, print NO.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as a positive answer).\nIn the first test case, one can apply the operation with x=3 to obtain the array [2,2,0,2], and then apply the operation with x=2 to obtain [0,0,0,0].\nIn the second test case, all numbers are already equal.\nIn the fourth test case, applying the operation with x=4 results in the array [1,1,1,1].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1656B": {
        "title": "B. Subtract Operation",
        "description": "You are given a list of n integers. You can perform the following operation: you choose an element x from the list, erase x from the list, and subtract the value of x from all the remaining elements. Thus, in one operation, the length of the list is decreased by exactly 1.\nGiven an integer k (k>0), find if there is some sequence of n\u22121 operations such that, after applying the operations, the only remaining element of the list is equal to k.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains two integers n and k (2\u2264n\u22642\u22c5105, 1\u2264k\u2264109), the number of integers in the list, and the target value, respectively.\nThe second line of each test case contains the n integers of the list a1,a2,\u2026,an (\u2212109\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases is not greater that 2\u22c5105.\nFor each test case, print YES if you can achieve k with a sequence of n\u22121 operations. Otherwise, print NO.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as a positive answer).\nIn the first example we have the list {4,2,2,7}, and we have the target k=5. One way to achieve it is the following: first we choose the third element, obtaining the list {2,0,5}. Next we choose the first element, obtaining the list {\u22122,3}. Finally, we choose the first element, obtaining the list {5}. ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1650C": {
        "title": "C. Weight of the System of Nested Segments",
        "description": "On the number line there are m points, i-th of which has integer coordinate xi and integer weight wi. The coordinates of all points are different, and the points are numbered from 1 to m.\nA sequence of n segments [l1,r1],[l2,r2],\u2026,[ln,rn] is called system of nested segments if for each pair i,j (1\u2264i<j\u2264n) the condition li<lj<rj<ri is satisfied. In other words, the second segment is strictly inside the first one, the third segment is strictly inside the second one, and so on.\nFor a given number n, find a system of nested segments such that:\nFor example, let m=8. The given points are marked in the picture, their weights are marked in red, their coordinates are marked in blue. Make a system of three nested segments:\nThe first line of input data contains an integer t (1\u2264t\u2264104)\u00a0\u2014the number of input test cases.\nAn empty line is written before each test case.\nThe first line of each test case contains two positive integers n (1\u2264n\u2264105) and m (2\u22c5n\u2264m\u22642\u22c5105). \nThe next m lines contain pairs of integers xi (\u2212109\u2264xi\u2264109) and wi (\u2212104\u2264wi\u2264104) \u2014 coordinate and weight of point number i (1\u2264i\u2264m) respectively. All xi are different.\nIt is guaranteed that the sum of m values over all test cases does not exceed 2\u22c5105.\nFor each test case, output n+1 lines: in the first of them, output the weight of the composed system, and in the next n lines output exactly two numbers \u00a0\u2014 the indices of the points which are the endpoints of the i-th segment (1\u2264i\u2264n). The order in which you output the endpoints of a segment is not important \u2014 you can output the index of the left endpoint first and then the number of the right endpoint, or the other way around.\nIf there are several ways to make a system of nested segments with minimal weight, output any of them.\nThe first test case coincides with the example from the condition. It can be shown that the weight of the composed system is minimal.\nThe second test case has only 6 points, so you need to use each of them to compose 3 segments.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "hashing",
            "implementation",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1647B": {
        "title": "B. Madoka and the Elegant Gift",
        "description": "Madoka's father just reached 1 million subscribers on Mathub! So the website decided to send him a personalized award\u00a0\u2014 The Mathhub's Bit Button! \nThe Bit Button is a rectangular table with n rows and m columns with 0 or 1 in each cell. After exploring the table Madoka found out that:\nFor example, in the first illustration the red subrectangle is nice, but in the second one it's not, because it's contained in the purple subrectangle.\nHelp Madoka to determine whether the table is elegant.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264200)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains two positive integers n,m (1\u2264n,m\u2264100).\nThe next n lines contain strings of length m consisting of zeros and ones\u00a0\u2014 the description of the table.\nIt is guaranteed that the sum of the values of n and the sum of the values of m for all test cases do not exceed 777.\nFor each test case print \"YES\" if its table is elegant or print \"NO\" otherwise.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).\nIn the second test case the table is not elegant, because the red and the purple subrectangles are nice and intersect. \nIn the fourth test case the table is not elegant, because the red and the purple subrectangles are nice and intersect. ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "graphs",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1641A": {
        "title": "A. Great Sequence",
        "description": "A sequence of positive integers is called great for a positive integer x, if we can split it into pairs in such a way that in each pair the first number multiplied by x is equal to the second number. More formally, a sequence a of size n is great for a positive integer x, if n is even and there exists a permutation p of size n, such that for each i (1\u2264i\u2264n2) ap2i\u22121\u22c5x=ap2i. \nSam has a sequence a and a positive integer x. Help him to make the sequence great: find the minimum possible number of positive integers that should be added to the sequence a to make it great for the number x.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u226420000) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains two integers n, x (1\u2264n\u22642\u22c5105, 2\u2264x\u2264106).\nThe next line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case print a single integer\u00a0\u2014 the minimum number of integers that can be added to the end of a to make it a great sequence for the number x.\nIn the first test case, Sam got lucky and the sequence is already great for the number 4 because you can divide it into such pairs: (1,4), (4,16). Thus we can add 0 numbers.\nIn the second test case, you can add numbers 1 and 14 to the sequence, then you can divide all 8 integers into such pairs: (1,2), (1,2), (2,4), (7,14). It is impossible to add less than 2 integers to fix the sequence.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1638B": {
        "title": "B. Odd Swap Sort",
        "description": "You are given an array a1,a2,\u2026,an. You can perform operations on the array. In each operation you can choose an integer i (1\u2264i<n), and swap elements ai and ai+1 of the array, if ai+ai+1 is odd.\nDetermine whether it can be sorted in non-decreasing order using this operation any number of times.\nEach test contains multiple test cases. The first line contains a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the elements of the array.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print \"Yes\" or \"No\" depending on whether you can or can not sort the given array.\nYou may print each letter in any case (for example, \"YES\", \"Yes\", \"yes\", \"yEs\" will all be recognized as positive answer).\nIn the first test case, we can simply swap 31 and 14 (31+14=45 which is odd) and obtain the non-decreasing array [1,6,14,31].\nIn the second test case, the only way we could sort the array is by swapping 4 and 2, but this is impossible, since their sum 4+2=6 is even.\nIn the third test case, there is no way to make the array non-decreasing.\nIn the fourth test case, the array is already non-decreasing.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "math",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1637C": {
        "title": "C. Andrew and Stones",
        "description": "Andrew has n piles with stones. The i-th pile contains ai stones. He wants to make his table clean so he decided to put every stone either to the 1-st or the n-th pile.\nAndrew can perform the following operation any number of times: choose 3 indices 1\u2264i<j<k\u2264n, such that the j-th pile contains at least 2 stones, then he takes 2 stones from the pile j and puts one stone into pile i and one stone into pile k. \nTell Andrew what is the minimum number of operations needed to move all the stones to piles 1 and n, or determine if it's impossible.\nThe input contains several test cases. The first line contains one integer t (1\u2264t\u226410000)\u00a0\u2014 the number of test cases.\nThe first line for each test case contains one integer n (3\u2264n\u2264105)\u00a0\u2014 the length of the array.\nThe second line contains a sequence of integers a1,a2,\u2026,an (1\u2264ai\u2264109)\u00a0\u2014 the array elements.\nIt is guaranteed that the sum of the values n over all test cases does not exceed 105.\nFor each test case print the minimum number of operations needed to move stones to piles 1 and n, or print \u22121 if it's impossible.\nIn the first test case, it is optimal to do the following: \nIn the second test case, it's impossible to put all stones into piles with numbers 1 and 3: \nIn the third test case, it's optimal to do the following: \nIn the fourth test case, it's impossible to do any operation, and the array doesn't satisfy the statement, so the answer is \u22121.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1637B": {
        "title": "B. MEX and Array",
        "description": "Let there be an array b1,b2,\u2026,bk. Let there be a partition of this array into segments [l1;r1],[l2;r2],\u2026,[lc;rc], where l1=1, rc=k, and for any 2\u2264i\u2264c holds that ri\u22121+1=li. In other words, each element of the array belongs to exactly one segment.\nLet's define the cost of a partition as c+c\u2211i=1mex({bli,bli+1,\u2026,bri}), where mex of a set of numbers S is the smallest non-negative integer that does not occur in the set S. In other words, the cost of a partition is the number of segments plus the sum of MEX over all segments. Let's define the value of an array b1,b2,\u2026,bk as the maximum possible cost over all partitions of this array.\nYou are given an array a of size n. Find the sum of values of all its subsegments.\nAn array x is a subsegment of an array y if x can be obtained from y by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nThe input contains several test cases. The first line contains one integer t (1\u2264t\u226430)\u00a0\u2014 the number of test cases.\nThe first line for each test case contains one integer n (1\u2264n\u2264100)\u00a0\u2014 the length of the array.\nThe second line contains a sequence of integers a1,a2,\u2026,an (0\u2264ai\u2264109)\u00a0\u2014 the array elements.\nIt is guaranteed that the sum of the values n over all test cases does not exceed 100.\nFor each test case print a single integer\u00a0\u2014 the answer to the problem.\nIn the second test case: \nThe sum of values over all subsegments equals to 4+3+1+3+2+1=14.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1635C": {
        "title": "C. Differential Sorting",
        "description": "You are given an array a of n elements. \nYour can perform the following operation no more than n times: Select three indices x,y,z (1\u2264x<y<z\u2264n) and replace ax with ay\u2212az. After the operation, |ax| need to be less than 1018.\nYour goal is to make the resulting array non-decreasing. If there are multiple solutions, you can output any. If it is impossible to achieve, you should report it as well.\nEach test contains multiple test cases. The first line will contain a single integer t (1\u2264t\u226410000) \u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains a single integer n (3\u2264n\u22642\u22c5105) \u2014 the size of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109), the elements of a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, print \u22121 in a single line if there is no solution. Otherwise in the first line you should print a single integer m (0\u2264m\u2264n) \u2014 number of operations you performed.\nThen the i-th of the following m lines should contain three integers x,y,z (1\u2264x<y<z\u2264n)\u2014 description of the i-th operation.\nIf there are multiple solutions, you can output any. Note that you don't have to minimize the number of operations in this task.\nIn the first example, the array becomes \n[\u22126,\u22124,2,\u22121,2] after the first operation,\n[\u22126,\u22124,\u22123,\u22121,2] after the second operation.\nIn the second example, it is impossible to make the array sorted after any sequence of operations.\nIn the third example, the array is already sorted, so we don't need to perform any operations.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1634C": {
        "title": "C. OKEA",
        "description": "You work for a well-known department store that uses leading technologies and employs mechanistic work\u00a0\u2014 that is, robots!\nThe department you work in sells n\u22c5k items. The first item costs 1 dollar, the second item costs 2 dollars, and so on: i-th item costs i dollars. The items are situated on shelves. The items form a rectangular grid: there are n shelves in total, and each shelf contains exactly k items. We will denote by ai,j the price of j-th item (counting from the left) on the i-th shelf, 1\u2264i\u2264n,1\u2264j\u2264k.\nOccasionally robots get curious and ponder on the following question: what is the mean price (arithmetic average) of items ai,l,ai,l+1,\u2026,ai,r for some shelf i and indices l\u2264r? Unfortunately, the old robots can only work with whole numbers. If the mean price turns out not to be an integer, they break down.\nYou care about robots' welfare. You want to arrange the items in such a way that the robots cannot theoretically break. Formally, you want to choose such a two-dimensional array a that:\nFind out if such an arrangement is possible, and if it is, give any example of such arrangement.\nThe first line contains a single integer t (1\u2264t\u2264500)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains two integers n and k (1\u2264n,k\u2264500)\u00a0\u2014 the number of shelves and length of each shelf, respectively.\nIt is guaranteed that the sum n over all test cases does not exceed 500 and the sum k over all test cases does not exceed 500.\nPrint the answer for each test case.\nIf such an arrangement exists, print \"YES\" on a single line. After that, print any example on n lines of k numbers each, one line per shelf. Each number from 1 to n\u22c5k must occur exactly once in the output.\nIf no good arrangement exists, print a single word \"NO\" on its own line.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1633C": {
        "title": "C. Kill the Monster",
        "description": "Monocarp is playing a computer game. In this game, his character fights different monsters.\nA fight between a character and a monster goes as follows. Suppose the character initially has health hC and attack dC; the monster initially has health hM and attack dM. The fight consists of several steps:\nThe fight ends when someone's health becomes non-positive (i.\u2009e. 0 or less). If the monster's health becomes non-positive, the character wins, otherwise the monster wins.\nMonocarp's character currently has health equal to hC and attack equal to dC. He wants to slay a monster with health equal to hM and attack equal to dM. Before the fight, Monocarp can spend up to k coins to upgrade his character's weapon and/or armor; each upgrade costs exactly one coin, each weapon upgrade increases the character's attack by w, and each armor upgrade increases the character's health by a.\nCan Monocarp's character slay the monster if Monocarp spends coins on upgrades optimally?\nThe first line contains one integer t (1\u2264t\u22645\u22c5104) \u2014 the number of test cases. Each test case consists of three lines:\nThe first line contains two integers hC and dC (1\u2264hC\u22641015; 1\u2264dC\u2264109) \u2014 the character's health and attack;\nThe second line contains two integers hM and dM (1\u2264hM\u22641015; 1\u2264dM\u2264109) \u2014 the monster's health and attack;\nThe third line contains three integers k, w and a (0\u2264k\u22642\u22c5105; 0\u2264w\u2264104; 0\u2264a\u22641010) \u2014 the maximum number of coins that Monocarp can spend, the amount added to the character's attack with each weapon upgrade, and the amount added to the character's health with each armor upgrade, respectively.\nThe sum of k over all test cases does not exceed 2\u22c5105.\nFor each test case, print YES if it is possible to slay the monster by optimally choosing the upgrades. Otherwise, print NO.\nIn the first example, Monocarp can spend one coin to upgrade weapon (damage will be equal to 5), then health during battle will change as follows: (hC,hM)=(25,9)\u2192(25,4)\u2192(5,4)\u2192(5,\u22121). The battle ended with Monocarp's victory.\nIn the second example, Monocarp has no way to defeat the monster.\nIn the third example, Monocarp has no coins, so he can't buy upgrades. However, the initial characteristics are enough for Monocarp to win.\nIn the fourth example, Monocarp has 4 coins. To defeat the monster, he has to spend 2 coins to upgrade weapon and 2 coins to upgrade armor.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1632B": {
        "title": "B. Roof Construction",
        "description": "It has finally been decided to build a roof over the football field in School 179. Its construction will require placing n consecutive vertical pillars. Furthermore, the headmaster wants the heights of all the pillars to form a permutation p of integers from 0 to n\u22121, where pi is the height of the i-th pillar from the left (1\u2264i\u2264n).\nAs the chief, you know that the cost of construction of consecutive pillars is equal to the maximum value of the bitwise XOR of heights of all pairs of adjacent pillars. In other words, the cost of construction is equal to max1\u2264i\u2264n\u22121pi\u2295pi+1, where \u2295 denotes the bitwise XOR operation.\nFind any sequence of pillar heights p of length n with the smallest construction cost.\nIn this problem, a permutation is an array consisting of n distinct integers from 0 to n\u22121 in arbitrary order. For example, [2,3,1,0,4] is a permutation, but [1,0,1] is not a permutation (1 appears twice in the array) and [1,0,3] is also not a permutation (n=3, but 3 is in the array).\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe only line for each test case contains a single integer n (2\u2264n\u22642\u22c5105) \u2014 the number of pillars for the construction of the roof.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case print n integers p1, p2, \u2026, pn \u2014 the sequence of pillar heights with the smallest construction cost.\nIf there are multiple answers, print any of them.\nFor n=2 there are 2 sequences of pillar heights: \nFor n=3 there are 6 sequences of pillar heights: ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1631B": {
        "title": "B. Fun with Even Subarrays",
        "description": "You are given an array a of n elements. You can apply the following operation to it any number of times:\nFor example, if a=[2,1,3,4,5,3], then choose l=1 and k=2, applying this operation the array will become a=[3,4,3,4,5,3].\nFind the minimum number of operations (possibly zero) needed to make all the elements of the array equal.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u22642\u22c5104) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642\u22c5105) \u2014 the length of the array.\nThe second line of each test case consists of n integers a1,a2,\u2026,an (1\u2264ai\u2264n) \u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nPrint t lines, each line containing the answer to the corresponding test case \u2014 the minimum number of operations needed to make equal all the elements of the array with the given operation.\nIn the first test, all elements are equal, therefore no operations are needed.\nIn the second test, you can apply one operation with k=1 and l=1, set a1:=a2, and the array becomes [1,1] with 1 operation.\nIn the third test, you can apply one operation with k=1 and l=4, set a4:=a5, and the array becomes [4,4,4,4,4].\nIn the fourth test, you can apply one operation with k=1 and l=3, set a3:=a4, and the array becomes [4,2,3,3], then you can apply another operation with k=2 and l=1, set a1:=a3, a2:=a4, and the array becomes [3,3,3,3].\nIn the fifth test, there is only one element, therefore no operations are needed.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "dp",
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1626B": {
        "title": "B. Minor Reduction",
        "description": "You are given a decimal representation of an integer x without leading zeros.\nYou have to perform the following reduction on it exactly once: take two neighboring digits in x and replace them with their sum without leading zeros (if the sum is 0, it's represented as a single 0).\nFor example, if x=10057, the possible reductions are: \nWhat's the largest number that can be obtained?\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nEach testcase consists of a single integer x (10\u2264x<10200000). x doesn't contain leading zeros.\nThe total length of the decimal representations of x over all testcases doesn't exceed 2\u22c5105.\nFor each testcase, print a single integer\u00a0\u2014 the largest number that can be obtained after the reduction is applied exactly once. The number should not contain leading zeros.\nThe first testcase of the example is already explained in the statement.\nIn the second testcase, there is only one possible reduction: the first and the second digits.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1625B": {
        "title": "B. Elementary Particles",
        "description": "Martians are actively engaged in interplanetary trade. Olymp City, the Martian city known for its spaceport, has become a place where goods from all the corners of our Galaxy come. To deliver even more freight from faraway planets, Martians need fast spaceships.\nA group of scientists conducts experiments to build a fast engine for the new spaceship. In the current experiment, there are n elementary particles, the i-th of them has type ai.\nDenote a subsegment of the particle sequence (a1,a2,\u2026,an) as a sequence (al,al+1,\u2026,ar) for some left bound l and right bound r (1\u2264l\u2264r\u2264n). For instance, the sequence (1\u00a04\u00a02\u00a08\u00a05\u00a07) for l=2 and r=4 has the sequence (4\u00a02\u00a08) as a subsegment. Two subsegments are considered different if at least one bound of those subsegments differs.\nNote that the subsegments can be equal as sequences but still considered different. For example, consider the sequence (1\u00a01\u00a01\u00a01\u00a01) and two of its subsegments: one with l=1 and r=3 and another with l=2 and r=4. Both subsegments are equal to (1\u00a01\u00a01), but still considered different, as their left and right bounds differ.\nThe scientists want to conduct a reaction to get two different subsegments of the same length. Denote this length k. The resulting pair of subsegments must be harmonious, i.\u00a0e. for some i (1\u2264i\u2264k) it must be true that the types of particles on the i-th position are the same for these two subsegments. For example, the pair (1\u00a07\u00a03) and (4\u00a07\u00a08) is harmonious, as both subsegments have 7 on the second position. The pair (1\u00a02\u00a03) and (3\u00a01\u00a02) is not harmonious.\nThe longer are harmonious subsegments, the more chances for the scientists to design a fast engine. So, they asked you to calculate the maximal possible length of harmonious pair made of different subsegments.\nThe first line contains an integer t (1\u2264t\u2264100) \u2014 the number of test cases. The following are descriptions of the test cases.\nThe first line contains an integer n (2\u2264n\u2264150000) \u2014 the amount of elementary particles in the sequence.\nThe second line contains n integers ai (1\u2264ai\u2264150000) \u2014 types of elementary particles.\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test, print a single integer, maximal possible length of harmonious pair made of different subsegments. If such pair does not exist, print \u22121 instead.\nThe first test case is shown on the picture below:\nAs you can see from it, you may choose the subsegments (2\u00a01\u00a03\u00a04) and (3\u00a01\u00a05\u00a02), which are a harmonious pair. Their length is equal to 4, so the answer is 4.\nIn the second test case, you need to take two subsegments: one with l=1 and r=5, and one with l=2 and r=6. It's not hard to observe that these segments are a harmonious pair and considered different even though they are both equal to (1\u00a01\u00a01\u00a01\u00a01).\nIn the third test case, you cannot make a harmonious pair, so the answer is \u22121.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1624C": {
        "title": "C. Division by Two and Permutation",
        "description": "You are given an array a consisting of n positive integers. You can perform operations on it.\nIn one operation you can replace any element of the array ai with \u230aai2\u230b, that is, by an integer part of dividing ai by 2 (rounding down).\nSee if you can apply the operation some number of times (possible 0) to make the array a become a permutation of numbers from 1 to n\u00a0\u2014that is, so that it contains all numbers from 1 to n, each exactly once.\nFor example, if a=[1,8,25,2], n=4, then the answer is yes. You could do the following:\nThe first line of input data contains an integer t (1\u2264t\u2264104)\u00a0\u2014the number of test cases.\nEach test case contains exactly two lines. The first one contains an integer n (1\u2264n\u226450), the second one contains integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nFor each test case, output on a separate line:\nYou can output YES and NO in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).\nThe first test case is explained in the text of the problem statement.\nIn the second test case, it is not possible to get a permutation.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "flows",
            "graph matchings",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1623B": {
        "title": "B. Game on Ranges",
        "description": "Alice and Bob play the following game. Alice has a set S of disjoint ranges of integers, initially containing only one range [1,n]. In one turn, Alice picks a range [l,r] from the set S and asks Bob to pick a number in the range. Bob chooses a number d (l\u2264d\u2264r). Then Alice removes [l,r] from S and puts into the set S the range [l,d\u22121] (if l\u2264d\u22121) and the range [d+1,r] (if d+1\u2264r). The game ends when the set S is empty. We can show that the number of turns in each game is exactly n.\nAfter playing the game, Alice remembers all the ranges [l,r] she picked from the set S, but Bob does not remember any of the numbers that he picked. But Bob is smart, and he knows he can find out his numbers d from Alice's ranges, and so he asks you for help with your programming skill.\nGiven the list of ranges that Alice has picked ([l,r]), for each range, help Bob find the number d that Bob has picked.\nWe can show that there is always a unique way for Bob to choose his number for a list of valid ranges picked by Alice.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22641000).\nEach of the next n lines contains two integers l and r (1\u2264l\u2264r\u2264n), denoting the range [l,r] that Alice picked at some point.\nNote that the ranges are given in no particular order.\nIt is guaranteed that the sum of n over all test cases does not exceed 1000, and the ranges for each test case are from a valid game.\nFor each test case print n lines. Each line should contain three integers l, r, and d, denoting that for Alice's range [l,r] Bob picked the number d.\nYou can print the lines in any order. We can show that the answer is unique.\nIt is not required to print a new line after each test case. The new lines in the output of the example are for readability only. \nIn the first test case, there is only 1 range [1,1]. There was only one range [1,1] for Alice to pick, and there was only one number 1 for Bob to pick.\nIn the second test case, n=3. Initially, the set contains only one range [1,3]. \nIn the fourth test case, the game was played with n=5. Initially, the set contains only one range [1,5]. The game's turn is described in the following table. ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dfs and similar",
            "implementation",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1622B": {
        "title": "B. Berland Music",
        "description": "Berland Music is a music streaming service built specifically to support Berland local artist. Its developers are currently working on a song recommendation module.\nSo imagine Monocarp got recommended n songs, numbered from 1 to n. The i-th song had its predicted rating equal to pi, where 1\u2264pi\u2264n and every integer from 1 to n appears exactly once. In other words, p is a permutation.\nAfter listening to each of them, Monocarp pressed either a like or a dislike button. Let his vote sequence be represented with a string s, such that si=0 means that he disliked the i-th song, and si=1 means that he liked it.\nNow the service has to re-evaluate the song ratings in such a way that:\nAmong all valid permutations q find the one that has the smallest value of n\u2211i=1|pi\u2212qi|, where |x| is an absolute value of x.\nPrint the permutation q1,q2,\u2026,qn. If there are multiple answers, you can print any of them.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the number of songs.\nThe second line of each testcase contains n integers p1,p2,\u2026,pn (1\u2264pi\u2264n)\u00a0\u2014 the permutation of the predicted ratings.\nThe third line contains a single string s, consisting of n characters. Each character is either a 0 or a 1. 0 means that Monocarp disliked the song, and 1 means that he liked it.\nThe sum of n over all testcases doesn't exceed 2\u22c5105.\nFor each testcase, print a permutation q\u00a0\u2014 the re-evaluated ratings of the songs. If there are multiple answers such that n\u2211i=1|pi\u2212qi| is minimum possible, you can print any of them.\nIn the first testcase, there exists only one permutation q such that each liked song is rating higher than each disliked song: song 1 gets rating 2 and song 2 gets rating 1. n\u2211i=1|pi\u2212qi|=|1\u22122|+|2\u22121|=2.\nIn the second testcase, Monocarp liked all songs, so all permutations could work. The permutation with the minimum sum of absolute differences is the permutation equal to p. Its cost is 0.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "math",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1620B": {
        "title": "B. Triangles on a Rectangle",
        "description": "A rectangle with its opposite corners in (0,0) and (w,h) and sides parallel to the axes is drawn on a plane.\nYou are given a list of lattice points such that each point lies on a side of a rectangle but not in its corner. Also, there are at least two points on every side of a rectangle.\nYour task is to choose three points in such a way that: \nPrint the doubled area of this triangle. It can be shown that the doubled area of any triangle formed by lattice points is always an integer.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains two integers w and h (3\u2264w,h\u2264106)\u00a0\u2014 the coordinates of the corner of a rectangle.\nThe next two lines contain the description of the points on two horizontal sides. First, an integer k (2\u2264k\u22642\u22c5105)\u00a0\u2014 the number of points. Then, k integers x1<x2<\u22ef<xk (0<xi<w)\u00a0\u2014 the x coordinates of the points in the ascending order. The y coordinate for the first line is 0 and for the second line is h.\nThe next two lines contain the description of the points on two vertical sides. First, an integer k (2\u2264k\u22642\u22c5105)\u00a0\u2014 the number of points. Then, k integers y1<y2<\u22ef<yk (0<yi<h)\u00a0\u2014 the y coordinates of the points in the ascending order. The x coordinate for the first line is 0 and for the second line is w.\nThe total number of points on all sides in all testcases doesn't exceed 2\u22c5105.\nFor each testcase print a single integer\u00a0\u2014 the doubled maximum area of a triangle formed by such three points that exactly two of them belong to the same side.\nThe points in the first testcase of the example: \nThe largest triangle is formed by points (0,1), (0,6) and (5,4)\u00a0\u2014 its area is 252. Thus, the doubled area is 25. Two points that are on the same side are: (0,1) and (0,6).",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "geometry",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1619C": {
        "title": "C. Wrong Addition",
        "description": "Tanya is learning how to add numbers, but so far she is not doing it correctly. She is adding two numbers a and b using the following algorithm:\nFor example, the numbers a=17236 and b=3465 Tanya adds up as follows:\n+17236034651106911\nAs a result, she gets 1106911.\nYou are given two positive integers a and s. Find the number b such that by adding a and b as described above, Tanya will get s. Or determine that no suitable b exists.\nThe first line of input data contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nEach test case consists of a single line containing two positive integers a and s (1\u2264a<s\u22641018) separated by a space.\nFor each test case print the answer on a separate line.\nIf the solution exists, print a single positive integer b. The answer must be written without leading zeros. If multiple answers exist, print any of them.\nIf no suitable number b exists, output -1.\nThe first test case is explained in the main part of the statement.\nIn the third test case, we cannot choose b that satisfies the problem statement.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1618C": {
        "title": "C. Paint the Array",
        "description": "You are given an array aa consisting of n positive integers. You have to choose a positive integer d and paint all elements into two colors. All elements which are divisible by d will be painted red, and all other elements will be painted blue.\nThe coloring is called beautiful if there are no pairs of adjacent elements with the same color in the array. Your task is to find any value of d which yields a beautiful coloring, or report that it is impossible.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains one integer n (2\u2264n\u2264100) \u2014 the number of elements of the array.\nThe second line of each testcase contains n integers a1,a2,\u2026,an (1\u2264ai\u22641018).\nFor each testcase print a single integer. If there is no such value of d that yields a beautiful coloring, print 0. Otherwise, print any suitable value of d (1\u2264d\u22641018).",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1616B": {
        "title": "B. Mirror in the String",
        "description": "You have a string s1s2\u2026sn and you stand on the left of the string looking right. You want to choose an index k (1\u2264k\u2264n) and place a mirror after the k-th letter, so that what you see is s1s2\u2026sksksk\u22121\u2026s1. What is the lexicographically smallest string you can see?\nA string a is lexicographically smaller than a string b if and only if one of the following holds: \nThe first line of input contains one integer t (1\u2264t\u226410000): the number of test cases.\nThe next t lines contain the description of the test cases, two lines per a test case.\nIn the first line you are given one integer n (1\u2264n\u2264105): the length of the string.\nThe second line contains the string s consisting of n lowercase English characters.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print the lexicographically smallest string you can see.\nIn the first test case choose k=1 to obtain \"cc\".\nIn the second test case choose k=3 to obtain \"cbaabc\".\nIn the third test case choose k=1 to obtain \"aa\".\nIn the fourth test case choose k=1 to obtain \"bb\".",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1614B": {
        "title": "B. Divan and a New Project",
        "description": "The company \"Divan's Sofas\" is planning to build n+1 different buildings on a coordinate line so that: \nLet xi be the coordinate of the i-th building. To get from the building i to the building j, Divan spends |xi\u2212xj| minutes, where |y| is the absolute value of y.\nAll buildings that Divan is going to build can be numbered from 0 to n. The businessman will live in the building 0, the new headquarters of \"Divan's Sofas\". In the first ten years after construction Divan will visit the i-th building ai times, each time spending 2\u22c5|x0\u2212xi| minutes for walking.\nDivan asks you to choose the coordinates for all n+1 buildings so that over the next ten years the businessman will spend as little time for walking as possible.\nEach test contains several test cases. The first line contains one integer number t (1\u2264t\u2264103) \u2014 the number of test cases.\nThe first line of each case contains an integer n (1\u2264n\u22642\u22c5105) \u2014 the number of buildings that \"Divan's Sofas\" is going to build, apart from the headquarters.\nThe second line contains the sequence a1,a2,\u2026,an (0\u2264ai\u2264106), where ai is the number of visits to the i-th building.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, on the first line print the number T \u2014 the minimum time Divan will spend walking. \nOn the second line print the sequence x0,x1,\u2026,xn of n+1 integers, where xi (\u2212106\u2264xi\u2264106) is the selected coordinate of the i-th building. It can be shown that an optimal answer exists with coordinates not exceeding 106.\nIf there are multiple answers, print any of them.\nLet's look at the first example.\nDivan will visit the first building a1=1 times, the second a2=2 times and the third a3=3 times. Then one of the optimal solution will be as follows: \nIn total, Divan will spend 4+4+6=14 minutes. It can be shown that it is impossible to arrange buildings so that the businessman spends less time.\nAmong others, x=[1,3,2,0], x=[\u22125,\u22123,\u22126,\u22124] are also correct answers for the first example.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1613C": {
        "title": "C. Poisoned Dagger",
        "description": "Monocarp is playing yet another computer game. In this game, his character has to kill a dragon. The battle with the dragon lasts 100500 seconds, during which Monocarp attacks the dragon with a poisoned dagger. The i-th attack is performed at the beginning of the ai-th second from the battle start. The dagger itself does not deal damage, but it applies a poison effect on the dragon, which deals 1 damage during each of the next k seconds (starting with the same second when the dragon was stabbed by the dagger). However, if the dragon has already been poisoned, then the dagger updates the poison effect (i.e. cancels the current poison effect and applies a new one).\nFor example, suppose k=4, and Monocarp stabs the dragon during the seconds 2, 4 and 10. Then the poison effect is applied at the start of the 2-nd second and deals 1 damage during the 2-nd and 3-rd seconds; then, at the beginning of the 4-th second, the poison effect is reapplied, so it deals exactly 1 damage during the seconds 4, 5, 6 and 7; then, during the 10-th second, the poison effect is applied again, and it deals 1 damage during the seconds 10, 11, 12 and 13. In total, the dragon receives 10 damage.\nMonocarp knows that the dragon has h hit points, and if he deals at least h damage to the dragon during the battle \u2014 he slays the dragon. Monocarp has not decided on the strength of the poison he will use during the battle, so he wants to find the minimum possible value of k (the number of seconds the poison effect lasts) that is enough to deal at least h damage to the dragon.\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe first line of the test case contains two integers n and h (1\u2264n\u2264100;1\u2264h\u22641018)\u00a0\u2014 the number of Monocarp's attacks and the amount of damage that needs to be dealt.\nThe second line contains n integers a1, a2, ..., an (1\u2264ai\u2264109;ai<ai+1), where ai is the second when the i-th attack is performed.\nFor each test case, print a single integer\u00a0\u2014 the minimum value of the parameter k, such that Monocarp will cause at least h damage to the dragon.\nIn the first example, for k=3, damage is dealt in seconds [1,2,3,5,6,7].\nIn the second example, for k=4, damage is dealt in seconds [2,3,4,5,6,7,10,11,12,13].\nIn the third example, for k=1, damage is dealt in seconds [1,2,4,5,7].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1613B": {
        "title": "B. Absent Remainder",
        "description": "You are given a sequence a1,a2,\u2026,an consisting of n pairwise distinct positive integers.\nFind \u230an2\u230b different pairs of integers x and y such that: \nNote that some x or y can belong to multiple pairs.\n\u230ax\u230b denotes the floor function\u00a0\u2014 the largest integer less than or equal to x. x\u00a0mod\u00a0y denotes the remainder from dividing x by y.\nIf there are multiple solutions, print any of them. It can be shown that at least one solution always exists.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains a single integer n (2\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the sequence.\nThe second line of each testcase contains n integers a1,a2,\u2026,an (1\u2264ai\u2264106).\nAll numbers in the sequence are pairwise distinct. The sum of n over all testcases doesn't exceed 2\u22c5105.\nThe answer for each testcase should contain \u230an2\u230b different pairs of integers x and y such that x\u2260y, x and y appear in a and x\u00a0mod\u00a0y doesn't appear in a. Print the pairs one after another.\nYou can print the pairs in any order. However, the order of numbers in the pair should be exactly such that the first number is x and the second number is y. All pairs should be pairwise distinct.\nIf there are multiple solutions, print any of them.\nIn the first testcase there are only two pairs: (1,4) and (4,1). \u230a22\u230b=1, so we have to find one pair. 1\u00a0mod\u00a04=1, and 1 appears in a, so that pair is invalid. Thus, the only possible answer is a pair (4,1).\nIn the second testcase, we chose pairs 8\u00a0mod\u00a02=0 and 8\u00a0mod\u00a04=0. 0 doesn't appear in a, so that answer is valid. There are multiple possible answers for that testcase.\nIn the third testcase, the chosen pairs are 9\u00a0mod\u00a05=4 and 7\u00a0mod\u00a05=2. Neither 4, nor 2, appears in a, so that answer is valid.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1611C": {
        "title": "C. Polycarp Recovers the Permutation",
        "description": "Polycarp wrote on a whiteboard an array p of length n, which is a permutation of numbers from 1 to n. In other words, in p each number from 1 to n occurs exactly once.\nHe also prepared a resulting array a, which is initially empty (that is, it has a length of 0).\nAfter that, he did exactly n steps. Each step looked like this:\nNote that on the last step, p has a length of 1 and its minimum element is both leftmost and rightmost. In this case, Polycarp can choose what role the minimum element plays. In other words, this element can be added to a both on the left and on the right (at the discretion of Polycarp).\nLet's look at an example. Let n=4, p=[3,1,4,2]. Initially a=[]. Then:\nThus, a possible value of a after n steps could be a=[1,3,2,4].\nYou are given the final value of the resulting array a. Find any possible initial value for p that can result the given a, or determine that there is no solution.\nThe first line of the input contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases in the test.\nEach test case consists of two lines. The first of them contains an integer n (1\u2264n\u22642\u22c5105) \u2014 the length of the array a. The second line contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n) \u2014 the elements of the array a. All elements of the a array are distinct numbers.\nIt is guaranteed that the sum of the values n over all test cases in the test does not exceed 2\u22c5105.\nPrint t lines, each of the lines must contain the answer to the corresponding set of input data: numbers p1,p2,\u2026,pn \u00a0\u2014 any of the possible initial values of the array p, which will lead to the given array a. All elements of p are distinct integers from 1 to n. Thus, if there are several solutions, print any. If there is no solution, then print -1 on the line.\nThe first test case in the example is clarified in the main section of the problem statement. There may be other correct answers for this test set.\nIn the second test case, n=1. Thus, there is only one permutation that can be the answer: p=[1]. Indeed, this is the answer to this test case.\nIn the third test case of the example, no matter what permutation you take as p, after applying the n steps, the result will differ from a=[1,3,5,4,2].",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1610B": {
        "title": "B. Kalindrome Array",
        "description": "An array [b1,b2,\u2026,bm] is a palindrome, if bi=bm+1\u2212i for each i from 1 to m. Empty array is also a palindrome.\nAn array is called kalindrome, if the following condition holds:\nIt's possible to select some integer x and delete some of the elements of the array equal to x, so that the remaining array (after gluing together the remaining parts) is a palindrome. \nNote that you don't have to delete all elements equal to x, and you don't have to delete at least one element equal to x.\nFor example : \nYou are given an array [a1,a2,\u2026,an]. Determine if a is kalindrome or not.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the length of the array.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 elements of the array.\nIt's guaranteed that the sum of n over all test cases won't exceed 2\u22c5105.\nFor each test case, print YES if a is kalindrome and NO otherwise. You can print each letter in any case.\nIn the first test case, array [1] is already a palindrome, so it's a kalindrome as well.\nIn the second test case, we can choose x=2, delete the second element, and obtain array [1], which is a palindrome.\nIn the third test case, it's impossible to obtain a palindrome.\nIn the fourth test case, you can choose x=4 and delete the fifth element, obtaining [1,4,4,1]. You also can choose x=1, delete the first and the fourth elements, and obtain [4,4,4].",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1609B": {
        "title": "B. William the Vigilant",
        "description": "Before becoming a successful trader William got a university degree. During his education an interesting situation happened, after which William started to listen to homework assignments much more attentively. What follows is the correct formal description of the homework assignment:\nYou are given a string ss of length n only consisting of characters \"a\", \"b\" and \"c\". There are q queries of format (pos,c), meaning replacing the element of string s at position pos with character c. After each query you must output the minimal number of characters in the string, which have to be replaced, so that the string doesn't contain string \"abc\" as a substring. A valid replacement of a character is replacing it with \"a\", \"b\" or \"c\".\nA string x is a substring of a string y if x can be obtained from y by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nThe first line contains two integers n and q (1\u2264n,q\u2264105), the length of the string and the number of queries, respectively.\nThe second line contains the string s, consisting of characters \"a\", \"b\" and \"c\".\nEach of the next q lines contains an integer i and character c (1\u2264i\u2264n), index and the value of the new item in the string, respectively. It is guaranteed that character's c value is \"a\", \"b\" or \"c\".\nFor each query output the minimal number of characters that would have to be replaced so that the string doesn't contain \"abc\" as a substring.\nLet's consider the state of the string after each query: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1608B": {
        "title": "B. Build the Permutation",
        "description": "You are given three integers n,a,b. Determine if there exists a permutation p1,p2,\u2026,pn of integers from 1 to n, such that:\nThere are exactly a integers i with 2\u2264i\u2264n\u22121 such that pi\u22121<pi>pi+1 (in other words, there are exactly a local maximums).\nThere are exactly b integers i with 2\u2264i\u2264n\u22121 such that pi\u22121>pi<pi+1 (in other words, there are exactly b local minimums).\nIf such permutations exist, find any such permutation.\nThe first line of the input contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of test cases follows.\nThe only line of each test case contains three integers n, a and b (2\u2264n\u2264105, 0\u2264a,b\u2264n).\nThe sum of n over all test cases doesn't exceed 105.\nFor each test case, if there is no permutation with the requested properties, output \u22121.\nOtherwise, print the permutation that you are found. If there are several such permutations, you may print any of them.\nIn the first test case, one example of such permutations is [1,3,2,4]. In it p1<p2>p3, and 2 is the only such index, and p2>p3<p4, and 3 the only such index.\nOne can show that there is no such permutation for the third test case.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1607C": {
        "title": "C. Minimum Extraction",
        "description": "Yelisey has an array a of n integers.\nIf a has length strictly greater than 1, then Yelisei can apply an operation called minimum extraction to it: \nThus, after each operation, the length of the array is reduced by 1.\nFor example, if a=[1,6,\u22124,\u22122,\u22124], then the minimum element in it is a3=\u22124, which means that after this operation the array will be equal to a=[1\u2212(\u22124),6\u2212(\u22124),\u22122\u2212(\u22124),\u22124\u2212(\u22124)]=[5,10,2,0].\nSince Yelisey likes big numbers, he wants the numbers in the array a to be as big as possible.\nFormally speaking, he wants to make the minimum of the numbers in array a to be maximal possible (i.e. he want to maximize a minimum). To do this, Yelisey can apply the minimum extraction operation to the array as many times as he wants (possibly, zero). Note that the operation cannot be applied to an array of length 1.\nHelp him find what maximal value can the minimal element of the array have after applying several (possibly, zero) minimum extraction operations to the array.\nThe first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe next 2t lines contain descriptions of the test cases.\nIn the description of each test case, the first line contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 the original length of the array a. The second line of the description lists n space-separated integers ai (\u2212109\u2264ai\u2264109)\u00a0\u2014 elements of the array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nPrint t lines, each of them containing the answer to the corresponding test case. The answer to the test case is a single integer\u00a0\u2014 the maximal possible minimum in a, which can be obtained by several applications of the described operation to it.\nIn the first example test case, the original length of the array n=1. Therefore minimum extraction cannot be applied to it. Thus, the array remains unchanged and the answer is a1=10.\nIn the second set of input data, the array will always consist only of zeros.\nIn the third set, the array will be changing as follows: [\u22121,2,0]\u2192[3,1]\u2192[2]. The minimum elements are highlighted with blue. The maximal one is 2.\nIn the fourth set, the array will be modified as [2,10,1,7]\u2192[1,9,6]\u2192[8,5]\u2192[3]. Similarly, the maximum of the minimum elements is 5.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1606B": {
        "title": "B. Update Files",
        "description": "Berland State University has received a new update for the operating system. Initially it is installed only on the 1-st computer.\nUpdate files should be copied to all n computers. The computers are not connected to the internet, so the only way to transfer update files from one computer to another is to copy them using a patch cable (a cable connecting two computers directly). Only one patch cable can be connected to a computer at a time. Thus, from any computer where the update files are installed, they can be copied to some other computer in exactly one hour.\nYour task is to find the minimum number of hours required to copy the update files to all n computers if there are only k patch cables in Berland State University.\nThe first line contains a single integer t (1\u2264t\u2264105)\u00a0\u2014 the number of test cases.\nEach test case consists of a single line that contains two integers n and k (1\u2264k\u2264n\u22641018) \u2014 the number of computers and the number of patch cables.\nFor each test case print one integer\u00a0\u2014 the minimum number of hours required to copy the update files to all n computers.\nLet's consider the test cases of the example:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1605B": {
        "title": "B. Reverse Sort",
        "description": "Ashish has a binary string s of length n that he wants to sort in non-decreasing order.\nHe can perform the following operation: \nFind the minimum number of operations required to sort the string in non-decreasing order. It can be proven that it is always possible to sort the given binary string in at most n operations.\nThe first line contains a single integer t (1\u2264t\u22641000) \u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22641000) \u00a0\u2014 the length of the binary string s.\nThe second line of each test case contains a binary string s of length n containing only 0s and 1s.\nIt is guaranteed that the sum of n over all test cases does not exceed 1000.\nFor each test case output the following:\nIn the first test case, the binary string is already sorted in non-decreasing order.\nIn the second test case, we can perform the following operation: \n1_ 0 1_ 0_ 0_ \u2192 0_ 0 0_ 1_ 1_ \nIn the third test case, we can perform the following operation:\n0 0 1_ 0 0_ 0_ \u2192 0 0 0_ 0 0_ 1_",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1604B": {
        "title": "B. XOR Specia-LIS-t",
        "description": "YouKn0wWho has an integer sequence a1,a2,\u2026ana1,a2,\u2026an. Now he will split the sequence aa into one or more consecutive subarrays so that each element of a belongs to exactly one subarray. Let k be the number of resulting subarrays, and h1,h2,\u2026,hk be the lengths of the longest increasing subsequences of corresponding subarrays.\nFor example, if we split [2,5,3,1,4,3,2,2,5,1] into [2,5,3,1,4], [3,2,2,5], [1], then h=[3,2,1].\nYouKn0wWho wonders if it is possible to split the sequence a in such a way that the bitwise XOR of h1,h2,\u2026,hk is equal to 0. You have to tell whether it is possible.\nThe longest increasing subsequence (LIS) of a sequence b1,b2,\u2026,bm is the longest sequence of valid indices i1,i2,\u2026,ik such that i1<i2<\u2026<ik and bi1<bi2<\u2026<bik. For example, the LIS of [2,5,3,3,5] is [2,3,5], which has length 3.\nAn array c is a subarray of an array b if c can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nThe first line contains a single integer t (1\u2264t\u226410000) \u00a0\u2014 the number of test cases.\nThe first line of each test case contains a single integer n (2\u2264n\u2264105).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases doesn't exceed 3\u22c5105.\nFor each test case, print \"YES\" (without quotes) if it is possible to split into subarrays in the desired way, print \"NO\" (without quotes) otherwise. You can print each letter in any register (upper or lower).\nIn the first test case, YouKn0wWho can split the sequence in the following way: [1,3,4], [2,2], [1,5]. This way, the LIS lengths are h=[3,1,2], and the bitwise XOR of the LIS lengths is 3\u22951\u22952=0.\nIn the second test case, it can be shown that it is impossible to split the sequence into subarrays that will satisfy the condition.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1602B": {
        "title": "B. Divine Array",
        "description": "Black is gifted with a Divine array a consisting of n (1\u2264n\u22642000) integers. Each position in a has an initial value. After shouting a curse over the array, it becomes angry and starts an unstoppable transformation.\nThe transformation consists of infinite steps. Array a changes at the i-th step in the following way: for every position j, aj becomes equal to the number of occurrences of aj in a before starting this step.\nHere is an example to help you understand the process better: \nIn the initial array, we had two 2-s, three 1-s, only one 4 and only one 3, so after the first step, each element became equal to the number of its occurrences in the initial array: all twos changed to 2, all ones changed to 3, four changed to 1 and three changed to 1.\nThe transformation steps continue forever.\nYou have to process q queries: in each query, Black is curious to know the value of ax after the k-th step of transformation.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22642000)\u00a0\u2014 the size of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 the initial values of array a.\nThe third line of each test case contains a single integer q (1\u2264q\u2264100000)\u00a0\u2014 the number of queries.\nNext q lines contain the information about queries\u00a0\u2014 one query per line. The i-th line contains two integers xi and ki (1\u2264xi\u2264n; 0\u2264ki\u2264109), meaning that Black is asking for the value of axi after the ki-th step of transformation. ki=0 means that Black is interested in values of the initial array.\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2000 and the sum of q over all test cases doesn't exceed 100000.\nFor each test case, print q answers. The i-th of them should be the value of axi after the ki-th step of transformation. It can be shown that the answer to each query is unique.\nThe first test case was described ih the statement. It can be seen that: \nFor the second test case, \n\nIt can be seen that: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1598C": {
        "title": "C. Delete Two Elements",
        "description": "Monocarp has got an array a consisting of n integers. Let's denote k as the mathematic mean of these elements (note that it's possible that k is not an integer). \nThe mathematic mean of an array of n elements is the sum of elements divided by the number of these elements (i.\u2009e. sum divided by n).\nMonocarp wants to delete exactly two elements from a so that the mathematic mean of the remaining (n\u22122) elements is still equal to k.\nYour task is to calculate the number of pairs of positions [i,j] (i<j) such that if the elements on these positions are deleted, the mathematic mean of (n\u22122) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains one integer n (3\u2264n\u22642\u22c5105) \u2014 the number of elements in the array.\nThe second line contains a sequence of integers a1,a2,\u2026,an (0\u2264ai\u2264109), where ai is the i-th element of the array.\nThe sum of n over all testcases doesn't exceed 2\u22c5105.\nPrint one integer \u2014 the number of pairs of positions [i,j] (i<j) such that if the elements on these positions are deleted, the mathematic mean of (n\u22122) remaining elements is equal to k (that is, it is equal to the mathematic mean of n elements of the original array a).\nIn the first example, any pair of elements can be removed since all of them are equal.\nIn the second example, there is no way to delete two elements so the mathematic mean doesn't change.\nIn the third example, it is possible to delete the elements on positions 1 and 3, or the elements on positions 4 and 5.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "dp",
            "implementation",
            "math",
            "two pointers",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1598B": {
        "title": "B. Groups",
        "description": "n students attended the first meeting of the Berland SU programming course (n is even). All students will be divided into two groups. Each group will be attending exactly one lesson each week during one of the five working days (Monday, Tuesday, Wednesday, Thursday and Friday), and the days chosen for the groups must be different. Furthermore, both groups should contain the same number of students.\nEach student has filled a survey in which they told which days of the week are convenient for them to attend a lesson, and which are not. \nYour task is to determine if it is possible to choose two different week days to schedule the lessons for the group (the first group will attend the lesson on the first chosen day, the second group will attend the lesson on the second chosen day), and divide the students into two groups, so the groups have equal sizes, and for each student, the chosen lesson day for their group is convenient.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nThen the descriptions of t testcases follow.\nThe first line of each testcase contains one integer n (2\u2264n\u22641000)\u00a0\u2014 the number of students.\nThe i-th of the next n lines contains 5 integers, each of them is 0 or 1. If the j-th integer is 1, then the i-th student can attend the lessons on the j-th day of the week. If the j-th integer is 0, then the i-th student cannot attend the lessons on the j-th day of the week. \nAdditional constraints on the input: for each student, at least one of the days of the week is convenient, the total number of students over all testcases doesn't exceed 105.\nFor each testcase print an answer. If it's possible to divide the students into two groups of equal sizes and choose different days for the groups so each student can attend the lesson in the chosen day of their group, print \"YES\" (without quotes). Otherwise, print \"NO\" (without quotes). \nIn the first testcase, there is a way to meet all the constraints. For example, the first group can consist of the first and the third students, they will attend the lessons on Thursday (the fourth day); the second group can consist of the second and the fourth students, and they will attend the lessons on Tuesday (the second day).\nIn the second testcase, it is impossible to divide the students into groups so they attend the lessons on different days.",
        "time_limit": "time limit per test4 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1594C": {
        "title": "C. Make Them Equal",
        "description": "Theofanis has a string s1s2\u2026sn and a character c. He wants to make all characters of the string equal to c using the minimum number of operations.\nIn one operation he can choose a number x (1\u2264x\u2264n) and for every position i, where i is not divisible by x, replace si with c. \nFind the minimum number of operations required to make all the characters equal to c and the x-s that he should use in his operations.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains the integer n (3\u2264n\u22643\u22c5105) and a lowercase Latin letter c\u00a0\u2014 the length of the string s and the character the resulting string should consist of.\nThe second line of each test case contains a string s of lowercase Latin letters\u00a0\u2014 the initial string.\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test case, firstly print one integer m\u00a0\u2014 the minimum number of operations required to make all the characters equal to c.\nNext, print m integers x1,x2,\u2026,xm (1\u2264xj\u2264n)\u00a0\u2014 the x-s that should be used in the order they are given.\nIt can be proved that under given constraints, an answer always exists. If there are multiple answers, print any.\nLet's describe what happens in the third test case: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "greedy",
            "math",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1594B": {
        "title": "B. Special Numbers",
        "description": "Theofanis really likes sequences of positive integers, thus his teacher (Yeltsa Kcir) gave him a problem about a sequence that consists of only special numbers.\nLet's call a positive number special if it can be written as a sum of different non-negative powers of n. For example, for n=4 number 17 is special, because it can be written as 40+42=1+16=17, but 9 is not.\nTheofanis asks you to help him find the k-th special number if they are sorted in increasing order. Since this number may be too large, output it modulo 109+7.\nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first and only line of each test case contains two integers n and k (2\u2264n\u2264109; 1\u2264k\u2264109).\nFor each test case, print one integer\u00a0\u2014 the k-th special number in increasing order modulo 109+7.\nFor n=3 the sequence is [1,3,4,9...]",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1593D1": {
        "title": "D1. All are Same",
        "description": "This problem is a simplified version of D2, but it has significant differences, so read the whole statement.\nPolycarp has an array of n (n is even) integers a1,a2,\u2026,an. Polycarp conceived of a positive integer k. After that, Polycarp began performing the following operations on the array: take an index i (1\u2264i\u2264n) and reduce the number ai by k.\nAfter Polycarp performed some (possibly zero) number of such operations, it turned out that all numbers in the array became the same. Find the maximum k at which such a situation is possible, or print \u22121 if such a number can be arbitrarily large.\nThe first line contains one integer t (1\u2264t\u226410) \u2014 the number of test cases. Then t test cases follow.\nEach test case consists of two lines. The first line contains an even integer n (4\u2264n\u226440) (n is even). The second line contains n integers a1,a2,\u2026an (\u2212106\u2264ai\u2264106).\nIt is guaranteed that the sum of all n specified in the given test cases does not exceed 100.\nFor each test case output on a separate line an integer k (k\u22651) \u2014 the maximum possible number that Polycarp used in operations on the array, or \u22121, if such a number can be arbitrarily large.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "math",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1593C": {
        "title": "C. Save More Mice",
        "description": "There are one cat, k mice, and one hole on a coordinate line. The cat is located at the point 0, the hole is located at the point n. All mice are located between the cat and the hole: the i-th mouse is located at the point xi (0<xi<n). At each point, many mice can be located.\nIn one second, the following happens. First, exactly one mouse moves to the right by 1. If the mouse reaches the hole, it hides (i.e. the mouse will not any more move to any point and will not be eaten by the cat). Then (after that the mouse has finished its move) the cat moves to the right by 1. If at the new cat's position, some mice are located, the cat eats them (they will not be able to move after that). The actions are performed until any mouse hasn't been hidden or isn't eaten.\nIn other words, the first move is made by a mouse. If the mouse has reached the hole, it's saved. Then the cat makes a move. The cat eats the mice located at the pointed the cat has reached (if the cat has reached the hole, it eats nobody).\nEach second, you can select a mouse that will make a move. What is the maximum number of mice that can reach the hole without being eaten?\nThe first line contains one integer t (1\u2264t\u2264104) \u2014 the number of test cases. Then t test cases follow.\nEach test case consists of two lines. The first line contains two integers n and k (2\u2264n\u2264109, 1\u2264k\u22644\u22c5105). The second line contains k integers x1,x2,\u2026xk (1\u2264xi<n) \u2014 the initial coordinates of the mice.\nIt is guaranteed that the sum of all k given in the input doesn't exceed 4\u22c5105.\nFor each test case output on a separate line an integer m (m\u22650) \u2014 the maximum number of mice that can reach the hole without being eaten.",
        "time_limit": "time limit per test4 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "binary search",
            "greedy",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1592B": {
        "title": "B. Hemose Shopping",
        "description": "Hemose was shopping with his friends Samez, AhmedZ, AshrafEzz, TheSawan and O_E in Germany. As you know, Hemose and his friends are problem solvers, so they are very clever. Therefore, they will go to all discount markets in Germany.\nHemose has an array of n integers. He wants Samez to sort the array in the non-decreasing order. Since it would be a too easy problem for Samez, Hemose allows Samez to use only the following operation:\nChoose indices i and j such that 1\u2264i,j\u2264n, and |i\u2212j|\u2265x. Then, swap elements ai and aj.\nCan you tell Samez if there's a way to sort the array in the non-decreasing order by using the operation written above some finite number of times (possibly 0)?\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264105). Description of the test cases follows.\nThe first line of each test case contains two integers n and x (1\u2264x\u2264n\u2264105).\nThe second line of each test case contains n integers a1,a2,...,an (1\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases doesn't exceed 2\u22c5105.\nFor each test case, you should output a single string. \nIf Samez can sort the array in non-decreasing order using the operation written above, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\nIn the first test case, you can't do any operations.\nIn the second test case, the array is already sorted.\nIn the third test case, you can do the operations as follows: \n(Here swap(ai,aj) refers to swapping elements at positions i, j).",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "dsu",
            "math",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1584B": {
        "title": "B. Coloring Rectangles",
        "description": "David was given a red checkered rectangle of size n\u00d7m. But he doesn't like it. So David cuts the original or any other rectangle piece obtained during the cutting into two new pieces along the grid lines. He can do this operation as many times as he wants.\nAs a result, he will get a set of rectangles. Rectangles 1\u00d71 are forbidden.\nDavid also knows how to paint the cells blue. He wants each rectangle from the resulting set of pieces to be colored such that any pair of adjacent cells by side (from the same piece) have different colors.\nWhat is the minimum number of cells David will have to paint?\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases. The next lines contain descriptions of test cases.\nThe only line of each test case contains two integers n, m (1\u2264n,m\u22643\u22c5104, n\u22c5m\u22652).\nFor each test case print a single integer \u2014 the minimum number of cells David will have to paint blue.\nThe following pictures show how the initial rectangle can be split and cells colored blue.\nIn the first test case:\nIn the second test case:\nIn the third test case:\nIn the fourth test case:",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1583B": {
        "title": "B. Omkar and Heavenly Tree",
        "description": "Lord Omkar would like to have a tree with n nodes (3\u2264n\u2264105) and has asked his disciples to construct the tree. However, Lord Omkar has created m (1\u2264m<n) restrictions to ensure that the tree will be as heavenly as possible. \nA tree with n nodes is an connected undirected graph with n nodes and n\u22121 edges. Note that for any two nodes, there is exactly one simple path between them, where a simple path is a path between two nodes that does not contain any node more than once.\nHere is an example of a tree: \nA restriction consists of 3 pairwise distinct integers, a, b, and c (1\u2264a,b,c\u2264n). It signifies that node b cannot lie on the simple path between node a and node c. \nCan you help Lord Omkar and become his most trusted disciple? You will need to find heavenly trees for multiple sets of restrictions. It can be shown that a heavenly tree will always exist for any set of restrictions under the given constraints.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe first line of each test case contains two integers, n and m (3\u2264n\u2264105, 1\u2264m<n), representing the size of the tree and the number of restrictions.\nThe i-th of the next m lines contains three integers ai, bi, ci (1\u2264ai,bi,ci\u2264n, a, b, c are distinct), signifying that node bi cannot lie on the simple path between nodes ai and ci. \nIt is guaranteed that the sum of n across all test cases will not exceed 105.\nFor each test case, output n\u22121 lines representing the n\u22121 edges in the tree. On each line, output two integers u and v (1\u2264u,v\u2264n, u\u2260v) signifying that there is an edge between nodes u and v. Given edges have to form a tree that satisfies Omkar's restrictions.\nThe output of the first sample case corresponds to the following tree: \nThe output of the second sample case corresponds to the following tree: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "trees",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1582C": {
        "title": "C. Grandma Capa Knits a Scarf",
        "description": "Grandma Capa has decided to knit a scarf and asked Grandpa Sher to make a pattern for it, a pattern is a string consisting of lowercase English letters. Grandpa Sher wrote a string s of length n.\nGrandma Capa wants to knit a beautiful scarf, and in her opinion, a beautiful scarf can only be knit from a string that is a palindrome. She wants to change the pattern written by Grandpa Sher, but to avoid offending him, she will choose one lowercase English letter and erase some (at her choice, possibly none or all) occurrences of that letter in string s.\nShe also wants to minimize the number of erased symbols from the pattern. Please help her and find the minimum number of symbols she can erase to make string s a palindrome, or tell her that it's impossible. Notice that she can only erase symbols equal to the one letter she chose.\nA string is a palindrome if it is the same from the left to the right and from the right to the left. For example, the strings 'kek', 'abacaba', 'r' and 'papicipap' are palindromes, while the strings 'abb' and 'iq' are not.\nThe first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. The next 2\u22c5t lines contain the description of test cases. The description of each test case consists of two lines.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105) \u2014 the length of the string.\nThe second line of each test case contains the string s consisting of n lowercase English letters.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case print the minimum number of erased symbols required to make the string a palindrome, if it is possible, and \u22121, if it is impossible.\nIn the first test case, you can choose a letter 'a' and erase its first and last occurrences, you will get a string 'bcaacb', which is a palindrome. You can also choose a letter 'b' and erase all its occurrences, you will get a string 'acaaca', which is a palindrome as well.\nIn the second test case, it can be shown that it is impossible to choose a letter and erase some of its occurrences to get a palindrome.\nIn the third test case, you don't have to erase any symbols because the string is already a palindrome.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "greedy",
            "strings",
            "two pointers",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1581B": {
        "title": "B. Diameter of Graph",
        "description": "CQXYM wants to create a connected undirected graph with n nodes and m edges, and the diameter of the graph must be strictly less than k\u22121. Also, CQXYM doesn't want a graph that contains self-loops or multiple edges (i.e. each edge connects two different vertices and between each pair of vertices there is at most one edge).\nThe diameter of a graph is the maximum distance between any two nodes.\nThe distance between two nodes is the minimum number of the edges on the path which endpoints are the two nodes.\nCQXYM wonders whether it is possible to create such a graph.\nThe input consists of multiple test cases. \nThe first line contains an integer t(1\u2264t\u2264105) \u2014 the number of test cases. The description of the test cases follows.\nOnly one line of each test case contains three integers n(1\u2264n\u2264109), m, k (0\u2264m,k\u2264109).\nFor each test case, print YES if it is possible to create the graph, or print NO if it is impossible. You can print each letter in any case (upper or lower).\nIn the first test case, the graph's diameter equal to 0.\nIn the second test case, the graph's diameter can only be 2.\nIn the third test case, the graph's diameter can only be 1.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "graphs",
            "greedy",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1579E1": {
        "title": "E1. Permutation Minimization by Deque",
        "description": "In fact, the problems E1 and E2 do not have much in common. You should probably think of them as two separate problems.\nA permutation p of size n is given. A permutation of size n is an array of size n in which each integer from 1 to n occurs exactly once. For example, [1,4,3,2] and [4,2,1,3] are correct permutations while [1,2,4] and [1,2,2] are not.\nLet us consider an empty deque (double-ended queue). A deque is a data structure that supports adding elements to both the beginning and the end. So, if there are elements [1,5,2] currently in the deque, adding an element 4 to the beginning will produce the sequence [4,1,5,2], and adding same element to the end will produce [1,5,2,4].\nThe elements of the permutation are sequentially added to the initially empty deque, starting with p1 and finishing with pn. Before adding each element to the deque, you may choose whether to add it to the beginning or the end.\nFor example, if we consider a permutation p=[3,1,2,4], one of the possible sequences of actions looks like this: \n\nFind the lexicographically smallest possible sequence of elements in the deque after the entire permutation has been processed. \nA sequence [x1,x2,\u2026,xn] is lexicographically smaller than the sequence [y1,y2,\u2026,yn] if there exists such i\u2264n that x1=y1, x2=y2, \u2026, xi\u22121=yi\u22121 and xi<yi. In other words, if the sequences x and y have some (possibly empty) matching prefix, and the next element of the sequence x is strictly smaller than the corresponding element of the sequence y. For example, the sequence [1,3,2,4] is smaller than the sequence [1,3,4,2] because after the two matching elements [1,3] in the start the first sequence has an element 2 which is smaller than the corresponding element 4 in the second sequence.\nThe first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe next 2t lines contain descriptions of the test cases. \nThe first line of each test case description contains an integer n (1\u2264n\u22642\u22c5105)\u00a0\u2014 permutation size. The second line of the description contains n space-separated integers pi (1\u2264pi\u2264n; all pi are all unique)\u00a0\u2014 elements of the permutation.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nPrint t lines, each line containing the answer to the corresponding test case. The answer to a test case should contain n space-separated integer numbers\u00a0\u2014 the elements of the lexicographically smallest permutation that is possible to find in the deque after executing the described algorithm.\nOne of the ways to get a lexicographically smallest permutation [1,3,2,4] from the permutation [3,1,2,4] (the first sample test case) is described in the problem statement.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1579B": {
        "title": "B. Shifting Sort",
        "description": "The new generation external memory contains an array of integers a[1\u2026n]=[a1,a2,\u2026,an].\nThis type of memory does not support changing the value of an arbitrary element. Instead, it allows you to cut out any segment of the given array, cyclically shift (rotate) it by any offset and insert it back into the same place.\nTechnically, each cyclic shift consists of two consecutive actions: \nFor example, if a=[1,3,2,8,5], then choosing l=2, r=4 and d=2 yields a segment a[2\u20264]=[3,2,8]. This segment is then shifted by the offset d=2 to the left, and you get a segment [8,3,2] which then takes the place of of the original elements of the segment. In the end you get a=[1,8,3,2,5].\nSort the given array a using no more than n cyclic shifts of any of its segments. Note that you don't need to minimize the number of cyclic shifts. Any method that requires n or less cyclic shifts will be accepted.\nThe first line contains an integer t (1\u2264t\u22641000)\u00a0\u2014 the number of test cases.\nThe next 2t lines contain the descriptions of the test cases. \nThe first line of each test case description contains an integer n (2\u2264n\u226450)\u00a0\u2014 the length of the array. The second line consists of space-separated elements of the array ai (\u2212109\u2264ai\u2264109). Elements of array a may repeat and don't have to be unique.\nPrint t answers to all input test cases. \nThe first line of the answer of each test case should contain an integer k (0\u2264k\u2264n)\u00a0\u2014 the number of actions to sort the array. The next k lines should contain descriptions of the actions formatted as \"l\u00a0r\u00a0d\" (without quotes) where l and r (1\u2264l<r\u2264n) are the boundaries of the segment being shifted, while d (1\u2264d\u2264r\u2212l) is the offset value. Please remember that only the cyclic shifts to the left are considered so the chosen segment will be shifted by the offset d to the to the left.\nNote that you are not required to find the minimum number of cyclic shifts needed for sorting. Any sorting method where the number of shifts does not exceed n will be accepted.\nIf the given array a is already sorted, one of the possible answers is k=0 and an empty sequence of cyclic shifts.\nIf there are several possible answers, you may print any of them.\nExplanation of the fourth data set in the example: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "implementation",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1578E": {
        "title": "E. Easy Scheduling",
        "description": "Eonathan Eostar decided to learn the magic of multiprocessor systems. He has a full binary tree of tasks with height hh. In the beginning, there is only one ready task in the tree\u00a0\u2014 the task in the root. At each moment of time, p processes choose at most p ready tasks and perform them. After that, tasks whose parents were performed become ready for the next moment of time. Once the task becomes ready, it stays ready until it is performed. \nYou shall calculate the smallest number of time moments the system needs to perform all the tasks.\nThe first line of the input contains the number of tests t (1\u2264t\u22645\u22c5105). Each of the next t lines contains the description of a test. A test is described by two integers h (1\u2264h\u226450) and p (1\u2264p\u2264104)\u00a0\u2014 the height of the full binary tree and the number of processes. It is guaranteed that all the tests are different.\nFor each test output one integer on a separate line\u00a0\u2014 the smallest number of time moments the system needs to perform all the tasks.\nLet us consider the second test from the sample input. There is a full binary tree of height 3 and there are two processes. At the first moment of time, there is only one ready task, 1, and p1 performs it. At the second moment of time, there are two ready tasks, 2 and 3, and the processes perform them. At the third moment of time, there are four ready tasks, 4, 5, 6, and 7, and p1 performs 6 and p2 performs 5. At the fourth moment of time, there are two ready tasks, 4 and 7, and the processes perform them. Thus, the system spends 4 moments of time to perform all the tasks.\n",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test1024 megabytes",
        "tags": [
            "implementation",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1575A": {
        "title": "A. Another Sorting Problem",
        "description": "Andi and Budi were given an assignment to tidy up their bookshelf of n books. Each book is represented by the book title \u2014 a string si numbered from 1 to n, each with length m. Andi really wants to sort the book lexicographically ascending, while Budi wants to sort it lexicographically descending.\nSettling their fight, they decided to combine their idea and sort it asc-desc-endingly, where the odd-indexed characters will be compared ascendingly, and the even-indexed characters will be compared descendingly.\nA string a occurs before a string b in asc-desc-ending order if and only if in the first position where a and b differ, the following holds:\nThe first line contains two integers n and m (1\u2264n\u22c5m\u2264106).\nThe i-th of the next n lines contains a string si consisting of m uppercase Latin letters \u2014 the book title. The strings are pairwise distinct.\nOutput n integers \u2014 the indices of the strings after they are sorted asc-desc-endingly.\nThe following illustrates the first example.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "data structures",
            "sortings",
            "strings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1574B": {
        "title": "B. Combinatorics Homework",
        "description": "You are given four integer values a, b, c and m.\nCheck if there exists a string that contains: \nThe first line contains a single integer t (1\u2264t\u2264104)\u00a0\u2014 the number of testcases.\nEach of the next t lines contains the description of the testcase\u00a0\u2014 four integers a, b, c and m (1\u2264a,b,c\u2264108; 0\u2264m\u2264108).\nFor each testcase print \"YES\" if there exists a string that satisfies all the requirements. Print \"NO\" if there are no such strings.\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer).\nIn the first testcase strings \"ABCAB\" or \"BCABA\" satisfy the requirements. There exist other possible strings.\nIn the second testcase there's no way to put adjacent equal letters if there's no letter that appears at least twice.\nIn the third testcase string \"CABBCC\" satisfies the requirements. There exist other possible strings.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "greedy",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1569B": {
        "title": "B. Chess Tournament",
        "description": "A chess tournament will be held soon, where n chess players will take part. Every participant will play one game against every other participant. Each game ends in either a win for one player and a loss for another player, or a draw for both players.\nEach of the players has their own expectations about the tournament, they can be one of two types:\nYou have to determine if there exists an outcome for all the matches such that all the players meet their expectations. If there are several possible outcomes, print any of them. If there are none, report that it's impossible.\nThe first line contains a single integer t (1\u2264t\u2264200)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains one integer n (2\u2264n\u226450)\u00a0\u2014 the number of chess players.\nThe second line contains the string s (|s|=n; si\u2208{1,2}). If si=1, then the i-th player has expectations of the first type, otherwise of the second type.\nFor each test case, print the answer in the following format:\nIn the first line, print NO if it is impossible to meet the expectations of all players.\nOtherwise, print YES, and the matrix of size n\u00d7n in the next n lines.\nThe matrix element in the i-th row and j-th column should be equal to:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1567B": {
        "title": "B. MEXor Mixup",
        "description": "Alice gave Bob two integers a and b (a>0 and b\u22650). Being a curious boy, Bob wrote down an array of non-negative integers with MEX value of all elements equal to a and XOR value of all elements equal to b.\nWhat is the shortest possible length of the array Bob wrote?\nRecall that the MEX (Minimum EXcluded) of an array is the minimum non-negative integer that does not belong to the array and the XOR of an array is the bitwise XOR of all the elements of the array.\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u22645\u22c5104)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe only line of each test case contains two integers a and b (1\u2264a\u22643\u22c5105; 0\u2264b\u22643\u22c5105)\u00a0\u2014 the MEX and XOR of the array, respectively.\nFor each test case, output one (positive) integer\u00a0\u2014 the length of the shortest array with MEX a and XOR b. We can show that such an array always exists.\nIn the first test case, one of the shortest arrays with MEX 1 and XOR 1 is [0,2020,2021].\nIn the second test case, one of the shortest arrays with MEX 2 and XOR 1 is [0,1].\nIt can be shown that these arrays are the shortest arrays possible.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1566D1": {
        "title": "D1. Seating Arrangements (easy version)",
        "description": "It is the easy version of the problem. The only difference is that in this version n=1n=1.\nIn the cinema seats can be represented as the table with n rows and m columns. The rows are numbered with integers from 1 to n. The seats in each row are numbered with consecutive integers from left to right: in the k-th row from m(k\u22121)+1 to mk for all rows 1\u2264k\u2264n.\nThere are nm people who want to go to the cinema to watch a new film. They are numbered with integers from 1 to nm. You should give exactly one seat to each person.\nIt is known, that in this cinema as lower seat index you have as better you can see everything happening on the screen. i-th person has the level of sight ai. Let's define si as the seat index, that will be given to i-th person. You want to give better places for people with lower sight levels, so for any two people i, j such that ai<aj it should be satisfied that si<sj.\nAfter you will give seats to all people they will start coming to their seats. In the order from 1 to nm, each person will enter the hall and sit in their seat. To get to their place, the person will go to their seat's row and start moving from the first seat in this row to theirs from left to right. While moving some places will be free, some will be occupied with people already seated. The inconvenience of the person is equal to the number of occupied seats he or she will go through.\nLet's consider an example: m=5, the person has the seat 4 in the first row, the seats 1, 3, 5 in the first row are already occupied, the seats 2 and 4 are free. The inconvenience of this person will be 2, because he will go through occupied seats 1 and 3.\nFind the minimal total inconvenience (the sum of inconveniences of all people), that is possible to have by giving places for all people (all conditions should be satisfied).\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264100)\u00a0\u2014 the number of test cases. Description of the test cases follows.\nThe first line of each test case contains two integers n and m (n=1, 1\u2264m\u2264300)\u00a0\u2014 the number of rows and places in each row respectively.\nThe second line of each test case contains n\u22c5m integers a1,a2,\u2026,an\u22c5m (1\u2264ai\u2264109), where ai is the sight level of i-th person.\nIt's guaranteed that the sum of n\u22c5m over all test cases does not exceed 105.\nFor each test case print a single integer\u00a0\u2014 the minimal total inconvenience that can be achieved.\nIn the first test case, there is a single way to arrange people, because all sight levels are distinct. The first person will sit on the first seat, the second person will sit on the second place, the third person will sit on the third place. So inconvenience of the first person will be 0, inconvenience of the second person will be 1 and inconvenience of the third person will be 2. The total inconvenience is 0+1+2=3.\nIn the second test case, people should sit as follows: s1=2, s2=1, s3=5, s4=4, s5=3. The total inconvenience will be 6.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1566C": {
        "title": "C. MAX-MEX Cut",
        "description": "A binary string is a string that consists of characters 0 and 1. A bi-table is a table that has exactly two rows of equal length, each being a binary string.\nLet MEX of a bi-table be the smallest digit among 0, 1, or 2 that does not occur in the bi-table. For example, MEX for [00111010] is 2, because 0 and 1 occur in the bi-table at least once. MEX for [111111] is 0, because 0 and 2 do not occur in the bi-table, and 0<2.\nYou are given a bi-table with n columns. You should cut it into any number of bi-tables (each consisting of consecutive columns) so that each column is in exactly one bi-table. It is possible to cut the bi-table into a single bi-table \u2014 the whole bi-table.\nWhat is the maximal sum of MEX of all resulting bi-tables can be?\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases. Description of the test cases follows.\nThe first line of the description of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of columns in the bi-table.\nEach of the next two lines contains a binary string of length n\u00a0\u2014 the rows of the bi-table.\nIt's guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print a single integer\u00a0\u2014 the maximal sum of MEX of all bi-tables that it is possible to get by cutting the given bi-table optimally.\nIn the first test case you can cut the bi-table as follows:\nThe sum of MEX is 8.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "constructive algorithms",
            "dp",
            "greedy",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1562B": {
        "title": "B. Scenes From a Memory",
        "description": "During the hypnosis session, Nicholas suddenly remembered a positive integer n, which doesn't contain zeros in decimal notation. \nSoon, when he returned home, he got curious: what is the maximum number of digits that can be removed from the number so that the number becomes not prime, that is, either composite or equal to one?\nFor some numbers doing so is impossible: for example, for number 53 it's impossible to delete some of its digits to obtain a not prime integer. However, for all n in the test cases of this problem, it's guaranteed that it's possible to delete some of their digits to obtain a not prime number.\nNote that you cannot remove all the digits from the number.\nA prime number is a number that has no divisors except one and itself. A composite is a number that has more than two divisors. 1 is neither a prime nor a composite number.\nEach test contains multiple test cases.\nThe first line contains one positive integer t (1\u2264t\u2264103), denoting the number of test cases. Description of the test cases follows.\nThe first line of each test case contains one positive integer k (1\u2264k\u226450)\u00a0\u2014 the number of digits in the number.\nThe second line of each test case contains a positive integer n, which doesn't contain zeros in decimal notation (10k\u22121\u2264n<10k). It is guaranteed that it is always possible to remove less than k digits to make the number not prime.\nIt is guaranteed that the sum of k over all test cases does not exceed 104.\nFor every test case, print two numbers in two lines. In the first line print the number of digits, that you have left in the number. In the second line print the digits left after all delitions. \nIf there are multiple solutions, print any.\nIn the first test case, you can't delete 2 digits from the number 237, as all the numbers 2, 3, and 7 are prime. However, you can delete 1 digit, obtaining a number 27=33.\nIn the second test case, you can delete all digits except one, as 4=22 is a composite number.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "implementation",
            "math",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1559C": {
        "title": "C. Mocha and Hiking",
        "description": "The city where Mocha lives in is called Zhijiang. There are n+1n+1 villages and 2n\u22121 directed roads in this city. \nThere are two kinds of roads:\nMocha plans to go hiking with Taki this weekend. To avoid the trip being boring, they plan to go through every village exactly once. They can start and finish at any villages. Can you help them to draw up a plan? \nEach test contains multiple test cases. \nThe first line contains a single integer t (1\u2264t\u226420) \u2014 the number of test cases. Each test case consists of two lines.\nThe first line of each test case contains a single integer n (1\u2264n\u2264104) \u2014 indicates that the number of villages is n+1.\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u22641). If ai=0, it means that there is a road from village i to village n+1. If ai=1, it means that there is a road from village n+1 to village i.\nIt is guaranteed that the sum of n over all test cases does not exceed 104.\nFor each test case, print a line with n+1 integers, where the i-th number is the i-th village they will go through. If the answer doesn't exist, print \u22121.\nIf there are multiple correct answers, you can print any one of them.\nIn the first test case, the city looks like the following graph:\n\nSo all possible answers are (1\u21924\u21922\u21923), (1\u21922\u21923\u21924).\nIn the second test case, the city looks like the following graph:\n\nSo all possible answers are (4\u21921\u21922\u21923), (1\u21922\u21923\u21924), (3\u21924\u21921\u21922), (2\u21923\u21924\u21921).",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "graphs",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1557B": {
        "title": "B. Moamen and k-subarrays",
        "description": "Moamen has an array of n distinct integers. He wants to sort that array in non-decreasing order by doing the following operations in order exactly once:\nA sequence a is a subarray of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\nCan you tell Moamen if there is a way to sort the array in non-decreasing order using the operations written above?\nThe first line contains a single integer t (1\u2264t\u2264103)\u00a0\u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u2264105).\nThe second line contains n integers a1,a2,\u2026,an (0\u2264|ai|\u2264109). It is guaranteed that all numbers are distinct.\nIt is guaranteed that the sum of n over all test cases does not exceed 3\u22c5105.\nFor each test case, you should output a single string.\nIf Moamen can sort the array in non-decreasing order, output \"YES\" (without quotes). Otherwise, output \"NO\" (without quotes).\nYou can print each letter of \"YES\" and \"NO\" in any case (upper or lower).\nIn the first test case, a=[6,3,4,2,1], and k=4, so we can do the operations as follows: \nIn the second test case, there is no way to sort the array by splitting it into only 2 subarrays.\nAs an example, if we split it into {[1,\u22124],[0,\u22122]}, we can reorder them into {[1,\u22124],[0,\u22122]} or {[0,\u22122],[1,\u22124]}. However, after merging the subarrays, it is impossible to get a sorted array.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1553C": {
        "title": "C. Penalty",
        "description": "Consider a simplified penalty phase at the end of a football match.\nA penalty phase consists of at most 10 kicks, the first team takes the first kick, the second team takes the second kick, then the first team takes the third kick, and so on. The team that scores more goals wins; if both teams score the same number of goals, the game results in a tie (note that it goes against the usual football rules). The penalty phase is stopped if one team has scored more goals than the other team could reach with all of its remaining kicks. For example, if after the 7-th kick the first team has scored 1 goal, and the second team has scored 3 goals, the penalty phase ends \u2014 the first team cannot reach 3 goals.\nYou know which player will be taking each kick, so you have your predictions for each of the 10 kicks. These predictions are represented by a string s consisting of 10 characters. Each character can either be 1, 0, or ?. This string represents your predictions in the following way:\nBased on your predictions, you have to calculate the minimum possible number of kicks there can be in the penalty phase (that means, the earliest moment when the penalty phase is stopped, considering all possible ways it could go). Note that the referee doesn't take into account any predictions when deciding to stop the penalty phase \u2014 you may know that some kick will/won't be scored, but the referee doesn't.\nThe first line contains one integer t (1\u2264t\u22641000) \u2014 the number of test cases.\nEach test case is represented by one line containing the string s, consisting of exactly 10 characters. Each character is either 1, 0, or ?.\nFor each test case, print one integer \u2014 the minimum possible number of kicks in the penalty phase.\nConsider the example test:\nIn the first test case, consider the situation when the 1-st, 5-th and 7-th kicks score goals, and kicks 2, 3, 4 and 6 are unsuccessful. Then the current number of goals for the first team is 3, for the second team is 0, and the referee sees that the second team can score at most 2 goals in the remaining kicks. So the penalty phase can be stopped after the 7-th kick.\nIn the second test case, the penalty phase won't be stopped until all 10 kicks are finished.\nIn the third test case, if the first team doesn't score any of its three first kicks and the second team scores all of its three first kicks, then after the 6-th kick, the first team has scored 0 goals and the second team has scored 3 goals, and the referee sees that the first team can score at most 2 goals in the remaining kicks. So, the penalty phase can be stopped after the 6-th kick.\nIn the fourth test case, even though you can predict the whole penalty phase, the referee understands that the phase should be ended only after the 9-th kick.",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "brute force",
            "dp",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1550B": {
        "title": "B. Maximum Cost Deletion",
        "description": "You are given a string s of length n consisting only of the characters 0 and 1.\nYou perform the following operation until the string becomes empty: choose some consecutive substring of equal characters, erase it from the string and glue the remaining two parts together (any of them can be empty) in the same order. For example, if you erase the substring 111 from the string 111110, you will get the string 110. When you delete a substring of length l, you get a\u22c5l+b points.\nYour task is to calculate the maximum number of points that you can score in total, if you have to make the given string empty.\nThe first line contains a single integer t (1\u2264t\u22642000)\u00a0\u2014 the number of testcases.\nThe first line of each testcase contains three integers n, a and b (1\u2264n\u2264100;\u2212100\u2264a,b\u2264100)\u00a0\u2014 the length of the string s and the parameters a and b.\nThe second line contains the string s. The string s consists only of the characters 0 and 1.\nFor each testcase, print a single integer\u00a0\u2014 the maximum number of points that you can score.\nIn the first example, it is enough to delete the entire string, then we will get 2\u22c53+0=6 points.\nIn the second example, if we delete characters one by one, then for each deleted character we will get (\u22122)\u22c51+5=3 points, i.\u2009e. 15 points in total.\nIn the third example, we can delete the substring 00 from the string 100111, we get 1\u22c52+(\u22124)=\u22122 points, and the string will be equal to 1111, removing it entirely we get 1\u22c54+(\u22124)=0 points. In total, we got \u22122 points for 2 operations.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1547C": {
        "title": "C. Pair Programming",
        "description": "Monocarp and Polycarp are learning new programming techniques. Now they decided to try pair programming.\nIt's known that they have worked together on the same file for n+m minutes. Every minute exactly one of them made one change to the file. Before they started, there were already k lines written in the file.\nEvery minute exactly one of them does one of two actions: adds a new line to the end of the file or changes one of its lines.\nMonocarp worked in total for n minutes and performed the sequence of actions [a1,a2,\u2026,an]. If ai=0, then he adds a new line to the end of the file. If ai>0, then he changes the line with the number ai. Monocarp performed actions strictly in this order: a1, then a2, ..., an.\nPolycarp worked in total for m minutes and performed the sequence of actions [b1,b2,\u2026,bm]. If bj=0, then he adds a new line to the end of the file. If bj>0, then he changes the line with the number bj. Polycarp performed actions strictly in this order: b1, then b2, ..., bm.\nRestore their common sequence of actions of length n+m such that all actions would be correct \u2014 there should be no changes to lines that do not yet exist. Keep in mind that in the common sequence Monocarp's actions should form the subsequence [a1,a2,\u2026,an] and Polycarp's \u2014 subsequence [b1,b2,\u2026,bm]. They can replace each other at the computer any number of times.\nLet's look at an example. Suppose k=3. Monocarp first changed the line with the number 2 and then added a new line (thus, n=2,a=[2,0]). Polycarp first added a new line and then changed the line with the number 5 (thus, m=2,b=[0,5]).\nSince the initial length of the file was 3, in order for Polycarp to change line number 5 two new lines must be added beforehand. Examples of correct sequences of changes, in this case, would be [0,2,0,5] and [2,0,0,5]. Changes [0,0,5,2] (wrong order of actions) and [0,5,2,0] (line 5 cannot be edited yet) are not correct.\nThe first line contains an integer t (1\u2264t\u22641000). Then t test cases follow. Before each test case, there is an empty line.\nEach test case contains three lines. The first line contains three integers k, n, m (0\u2264k\u2264100, 1\u2264n,m\u2264100)\u00a0\u2014 the initial number of lines in file and lengths of Monocarp's and Polycarp's sequences of changes respectively.\nThe second line contains n integers a1,a2,\u2026,an (0\u2264ai\u2264300).\nThe third line contains m integers b1,b2,\u2026,bm (0\u2264bj\u2264300).\nFor each test case print any correct common sequence of Monocarp's and Polycarp's actions of length n+m or -1 if such sequence doesn't exist.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "greedy",
            "two pointers",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1546B": {
        "title": "B. AquaMoon and Stolen String",
        "description": "AquaMoon had n strings of length m each. n is an odd number.\nWhen AquaMoon was gone, Cirno tried to pair these n strings together. After making n\u221212 pairs, she found out that there was exactly one string without the pair!\nIn her rage, she disrupted each pair of strings. For each pair, she selected some positions (at least 1 and at most m) and swapped the letters in the two strings of this pair at the selected positions.\nFor example, if m=6 and two strings \"abcdef\" and \"xyzklm\" are in one pair and Cirno selected positions 2, 3 and 6 she will swap 'b' with 'y', 'c' with 'z' and 'f' with 'm'. The resulting strings will be \"ayzdem\" and \"xbcklf\".\nCirno then stole away the string without pair and shuffled all remaining strings in arbitrary order.\nAquaMoon found the remaining n\u22121 strings in complete disarray. Also, she remembers the initial n strings. She wants to know which string was stolen, but she is not good at programming. Can you help her?\nThis problem is made as interactive. It means, that your solution will read the input, given by the interactor. But the interactor will give you the full input at the beginning and after that, you should print the answer. So you should solve the problem, like as you solve the usual, non-interactive problem because you won't have any interaction process. The only thing you should not forget is to flush the output buffer, after printing the answer. Otherwise, you can get an \"Idleness limit exceeded\" verdict. Refer to the interactive problems guide for the detailed information about flushing the output buffer.\nThe input consists of multiple test cases. The first line contains a single integer t (1\u2264t\u2264100) \u2014 the number of test cases.\nThe first line of each test case contains two integers n, m (1\u2264n\u2264105, 1\u2264m\u2264105) \u2014 the number of strings and the length of each string, respectively.\nThe next n lines each contain a string with length m, describing the original n strings. All string consists of lowercase Latin letters.\nThe next n\u22121 lines each contain a string with length m, describing the strings after Cirno exchanged and reordered them.\nIt is guaranteed that n is odd and that the sum of n\u22c5m over all test cases does not exceed 105.\nHack format:\nThe first line should contain a single integer t. After that t test cases should follow in the following format:\nThe first line should contain two integers n and m.\nThe following n lines should contain n strings of length m, describing the original strings.\nThe following n\u221212 lines should describe the pairs. They should contain, in the following order: the index of the first string i (1\u2264i\u2264n), the index of the second string j (1\u2264j\u2264n, i\u2260j), the number of exchanged positions k (1\u2264k\u2264m), and the list of k positions that are exchanged (k distinct indices from 1 to m in any order).\nThe final line should contain a permutation of integers from 1 to n, describing the way the strings should be reordered. The strings will be placed in the order indices placed in this permutation, the stolen string index will be ignored.\nFor each test case print a single line with the stolen string.\nIn the first test case, \"aaaaa\" and \"bbbbb\" exchanged all positions, and \"ccccc\" is the stolen string.\nIn the second test case, \"aaaa\" and \"bbbb\" exchanged two first positions, and \"cccc\" is the stolen string.\nThis is the first test in the hack format: ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "interactive",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1541B": {
        "title": "B. Pleasant Pairs",
        "description": "You are given an array a1,a2,\u2026,an consisting of n distinct integers. Count the number of pairs of indices (i,j) such that i<j and ai\u22c5aj=i+j.\nThe first line contains one integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases. Then t cases follow.\nThe first line of each test case contains one integer n (2\u2264n\u2264105)\u00a0\u2014 the length of array a.\nThe second line of each test case contains n space separated integers a1,a2,\u2026,an (1\u2264ai\u22642\u22c5n)\u00a0\u2014 the array a. It is guaranteed that all elements are distinct.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output the number of pairs of indices (i,j) such that i<j and ai\u22c5aj=i+j.\nFor the first test case, the only pair that satisfies the constraints is (1,2), as a1\u22c5a2=1+2=3\nFor the second test case, the only pair that satisfies the constraints is (2,3).\nFor the third test case, the pairs that satisfy the constraints are (1,2), (1,5), and (2,3).",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "math",
            "number theory",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1539C": {
        "title": "C. Stable Groups",
        "description": "There are n students numerated from 1 to n. The level of the i-th student is ai. You need to split the students into stable groups. A group of students is called stable, if in the sorted array of their levels no two neighboring elements differ by more than x.\nFor example, if x=4, then the group with levels [1,10,8,4,4] is stable (because 4\u22121\u2264x, 4\u22124\u2264x, 8\u22124\u2264x, 10\u22128\u2264x), while the group with levels [2,10,10,7] is not stable (7\u22122=5>x).\nApart from the n given students, teachers can invite at most k additional students with arbitrary levels (at teachers' choice). Find the minimum number of stable groups teachers can form from all students (including the newly invited).\nFor example, if there are two students with levels 1 and 5; x=2; and k\u22651, then you can invite a new student with level 3 and put all the students in one stable group.\nThe first line contains three integers n, k, x (1\u2264n\u2264200000, 0\u2264k\u22641018, 1\u2264x\u22641018)\u00a0\u2014 the initial number of students, the number of students you can additionally invite, and the maximum allowed level difference.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u22641018)\u00a0\u2014 the students levels.\nIn the only line print a single integer: the minimum number of stable groups you can split the students into.\nIn the first example you can invite two students with levels 2 and 11. Then you can split the students into two stable groups: \nIn the second example you are not allowed to invite new students, so you need 3 groups: ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1539A": {
        "title": "A. Contest Start",
        "description": "There are n people participating in some contest, they start participating in x minutes intervals. That means the first participant starts at time 0, the second participant starts at time x, the third\u00a0\u2014 at time 2\u22c5x, and so on.\nDuration of contest is t minutes for each participant, so the first participant finishes the contest at time t, the second\u00a0\u2014 at time t+x, and so on. When a participant finishes the contest, their dissatisfaction equals to the number of participants that started the contest (or starting it now), but haven't yet finished it.\nDetermine the sum of dissatisfaction of all participants.\nThe first line contains a single integer k (1\u2264k\u22641000)\u00a0\u2014 the number of test cases.\nEach of the next k lines contains three integers n, x, t (1\u2264n,x,t\u22642\u22c5109)\u00a0\u2014 the number of participants, the start interval and the contest duration.\nPrint k lines, in the i-th line print the total dissatisfaction of participants in the i-th test case.\nIn the first example the first participant starts at 0 and finishes at time 5. By that time the second and the third participants start, so the dissatisfaction of the first participant is 2. \nThe second participant starts at time 2 and finishes at time 7. By that time the third the fourth participants start, so the dissatisfaction of the second participant is 2. \nThe third participant starts at 4 and finishes at 9. By that time the fourth participant starts, so the dissatisfaction of the third participant is 1.\nThe fourth participant starts at 6 and finishes at 11. By time 11 everyone finishes the contest, so the dissatisfaction of the fourth participant is 0.\nIn the second example the first participant starts at 0 and finishes at time 2. By that time the second participants starts, and the third starts at exactly time 2. So the dissatisfaction of the first participant is 2. \nThe second participant starts at time 1 and finishes at time 3. At that time the third participant is solving the contest.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "combinatorics",
            "geometry",
            "greedy",
            "math",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1537C": {
        "title": "C. Challenging Cliffs",
        "description": "You are a game designer and want to make an obstacle course. The player will walk from left to right. You have n heights of mountains already selected and want to arrange them so that the absolute difference of the heights of the first and last mountains is as small as possible. \nIn addition, you want to make the game difficult, and since walking uphill or flat is harder than walking downhill, the difficulty of the level will be the number of mountains i (1\u2264i<n) such that hi\u2264hi+1 where hi is the height of the i-th mountain. You don't want to waste any of the mountains you modelled, so you have to use all of them. \nFrom all the arrangements that minimize |h1\u2212hn|, find one that is the most difficult. If there are multiple orders that satisfy these requirements, you may find any.\nThe first line will contain a single integer t (1\u2264t\u2264100) \u2014 the number of test cases. Then t test cases follow.\nThe first line of each test case contains a single integer n (2\u2264n\u22642\u22c5105) \u2014 the number of mountains.\nThe second line of each test case contains n integers h1,\u2026,hn (1\u2264hi\u2264109), where hi is the height of the i-th mountain.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output n integers \u2014 the given heights in an order that maximizes the difficulty score among all orders that minimize |h1\u2212hn|.\nIf there are multiple orders that satisfy these requirements, you may output any.\nIn the first test case:\nThe player begins at height 2, next going up to height 4 increasing the difficulty by 1. After that he will go down to height 1 and the difficulty doesn't change because he is going downhill. Finally the player will go up to height 2 and the difficulty will increase by 1. The absolute difference between the starting height and the end height is equal to 0 and it's minimal. The difficulty is maximal.\nIn the second test case:\nThe player begins at height 1, next going up to height 3 increasing the difficulty by 1. The absolute difference between the starting height and the end height is equal to 2 and it's minimal as they are the only heights. The difficulty is maximal.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1536B": {
        "title": "B. Prinzessin der Verurteilung",
        "description": "I, Fischl, Prinzessin der Verurteilung, descend upon this land by the call of fate an \u2014 Oh, you are also a traveler from another world? Very well, I grant you permission to travel with me.\nIt is no surprise Fischl speaks with a strange choice of words. However, this time, not even Oz, her raven friend, can interpret her expressions! Maybe you can help us understand what this young princess is saying?\nYou are given a string of n lowercase Latin letters, the word that Fischl just spoke. You think that the MEX of this string may help you find the meaning behind this message. The MEX of the string is defined as the shortest string that doesn't appear as a contiguous substring in the input. If multiple strings exist, the lexicographically smallest one is considered the MEX. Note that the empty substring does NOT count as a valid MEX.\nA string a is lexicographically smaller than a string b if and only if one of the following holds: \nA string a is a substring of a string b if a can be obtained from b by deletion of several (possibly, zero or all) characters from the beginning and several (possibly, zero or all) characters from the end.\nFind out what the MEX of the string is!\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u22641000)\u00a0\u2014 the length of the word. The second line for each test case contains a single string of n lowercase Latin letters.\nThe sum of n over all test cases will not exceed 1000.\nFor each test case, output the MEX of the string on a new line.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "constructive algorithms",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1534B": {
        "title": "B. Histogram Ugliness",
        "description": "Little Dormi received a histogram with n bars of height a1,a2,\u2026,an for Christmas. However, the more he played with his new histogram, the more he realized its imperfections, so today he wanted to modify it to his liking.\nTo modify the histogram, Little Dormi is able to perform the following operation an arbitrary number of times:\nLittle Dormi defines the ugliness score of his histogram (after performing some number of operations) as the sum of the vertical length of its outline and the number of operations he performed on it. And to make the histogram as perfect as possible, he would like to minimize the ugliness score after modifying it with some number of operations.\nHowever, as his histogram is very large, Little Dormi is having trouble minimizing the ugliness score, so as Little Dormi's older brother, help him find the minimal ugliness.\nConsider the following example where the histogram has 4 columns of heights 4,8,9,6:\nThe blue region represents the histogram, and the red lines represent the vertical portion of the outline. Currently, the vertical length of the outline is 4+4+1+3+6=18, so if Little Dormi does not modify the histogram at all, the ugliness would be 18.\nHowever, Little Dormi can apply the operation once on column 2 and twice on column 3, resulting in a histogram with heights 4,7,7,6:\nNow, as the total vertical length of the outline (red lines) is 4+3+1+6=14, the ugliness is 14+3=17 dollars. It can be proven that this is optimal.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u2264104). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u22644\u22c5105).\nThe second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 4\u22c5105.\nFor each test case output one integer, the minimal ugliness Little Dormi can achieve with the histogram in that test case.\nExample 1 is the example described in the statement.\nThe initial histogram for example 2 is given below:\nThe ugliness is currently 2+1+6+3+4=16.\nBy applying the operation once on column 1, six times on column 3, and three times on column 4, we can end up with a histogram with heights 1,1,1,1,0,0:\nThe vertical length of the outline is now 1+1=2 and Little Dormi made 1+6+3=10 operations, so the final ugliness is 2+10=12, which can be proven to be optimal.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "math",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1530C": {
        "title": "C. Pursuit",
        "description": "You and your friend Ilya are participating in an individual programming contest consisting of multiple stages. A contestant can get between 0 and 100 points, inclusive, for each stage, independently of other contestants.\nPoints received by contestants in different stages are used for forming overall contest results. Suppose that k stages of the contest are completed. For each contestant, k\u2212\u230ak4\u230b stages with the highest scores are selected, and these scores are added up. This sum is the overall result of the contestant. (Here \u230at\u230b denotes rounding t down.)\nFor example, suppose 9 stages are completed, and your scores are 50,30,50,50,100,10,30,100,50. First, 7 stages with the highest scores are chosen\u00a0\u2014 for example, all stages except for the 2-nd and the 6-th can be chosen. Then your overall result is equal to 50+50+50+100+30+100+50=430.\nAs of now, n stages are completed, and you know the points you and Ilya got for these stages. However, it is unknown how many more stages will be held. You wonder what the smallest number of additional stages is, after which your result might become greater than or equal to Ilya's result, at least in theory. Find this number!\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u22641000). Description of the test cases follows.\nThe first line of each test case contains a single integer n (1\u2264n\u2264105)\u00a0\u2014 the number of completed stages.\nThe second line contains n integers a1,a2,\u2026,an (0\u2264ai\u2264100)\u00a0\u2014 your points for the completed stages.\nThe third line contains n integers b1,b2,\u2026,bn (0\u2264bi\u2264100)\u00a0\u2014 Ilya's points for the completed stages.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case print a single integer\u00a0\u2014 the smallest number of additional stages required for your result to be able to become greater than or equal to Ilya's result.\nIf your result is already not less than Ilya's result, print 0.\nIn the first test case, you have scored 100 points for the first stage, while Ilya has scored 0. Thus, your overall result (100) is already not less than Ilya's result (0).\nIn the second test case, you have scored 0 points for the first stage, while Ilya has scored 100. A single stage with an opposite result is enough for both your and Ilya's overall scores to become equal to 100.\nIn the third test case, your overall result is 30+40+50=120, while Ilya's result is 100+100+100=300. After three additional stages your result might become equal to 420, while Ilya's result might become equal to 400.\nIn the fourth test case, your overall result after four additional stages might become equal to 470, while Ilya's result might become equal to 400. Three stages are not enough.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "binary search",
            "brute force",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1529B": {
        "title": "B. Sifid and Strange Subsequences",
        "description": "A sequence (b1,b2,\u2026,bk) is called strange, if the absolute difference between any pair of its elements is greater than or equal to the maximum element in the sequence. Formally speaking, it's strange if for every pair (i,j) with 1\u2264i<j\u2264k, we have |ai\u2212aj|\u2265MAX, where MAX is the largest element of the sequence. In particular, any sequence of length at most 1 is strange.\nFor example, the sequences (\u22122021,\u22121,\u22121,\u22121) and (\u22121,0,1) are strange, but (3,0,1) is not, because |0\u22121|<3.\nSifid has an array a of n integers. Sifid likes everything big, so among all the strange subsequences of a, he wants to find the length of the longest one. Can you help him?\nA sequence c is a subsequence of an array d if c can be obtained from d by deletion of several (possibly, zero or all) elements.\nThe first line contains an integer t (1\u2264t\u2264104) \u2014 the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1\u2264n\u2264105) \u2014 the length of the array a.\nThe second line of each test case contains n integers a1,a2,\u2026,an (\u2212109\u2264ai\u2264109) \u2014 the elements of the array a.\nIt is guaranteed that the sum of n over all test cases doesn't exceed 105.\nFor each test case output a single integer \u2014 the length of the longest strange subsequence of a.\nIn the first test case, one of the longest strange subsequences is (a1,a2,a3,a4)\nIn the second test case, one of the longest strange subsequences is (a1,a3,a4,a5,a7).\nIn the third test case, one of the longest strange subsequences is (a1,a3,a4,a5).\nIn the fourth test case, one of the longest strange subsequences is (a2).\nIn the fifth test case, one of the longest strange subsequences is (a1,a2,a4).",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "math",
            "sortings",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1527B1": {
        "title": "B1. Palindrome Game (easy version)",
        "description": "The only difference between the easy and hard versions is that the given string s in the easy version is initially a palindrome, this condition is not always true for the hard version.\nA palindrome is a string that reads the same left to right and right to left. For example, \"101101\" is a palindrome, while \"0101\" is not.\nAlice and Bob are playing a game on a string s (which is initially a palindrome in this version) of length n consisting of the characters '0' and '1'. Both players take alternate turns with Alice going first.\nIn each turn, the player can perform one of the following operations: \nReversing a string means reordering its letters from the last to the first. For example, \"01001\" becomes \"10010\" after reversing.\nThe game ends when every character of string becomes '1'. The player who spends minimum dollars till this point wins the game and it is a draw if both spend equal dollars. If both players play optimally, output whether Alice wins, Bob wins, or if it is a draw.\nThe first line contains a single integer t (1\u2264t\u2264103). Then t test cases follow.\nThe first line of each test case contains a single integer n (1\u2264n\u2264103).\nThe second line of each test case contains the string s of length n, consisting of the characters '0' and '1'. It is guaranteed that the string s is a palindrome and contains at least one '0'. \nNote that there is no limit on the sum of n over test cases.\nFor each test case print a single word in a new line: \nIn the first test case of the example, ",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "games",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1523B": {
        "title": "B. Lord of the Values",
        "description": "While trading on his favorite exchange trader William realized that he found a vulnerability. Using this vulnerability he could change the values of certain internal variables to his advantage. To play around he decided to change the values of all internal variables from a1,a2,\u2026,an to \u2212a1,\u2212a2,\u2026,\u2212an. For some unknown reason, the number of service variables is always an even number.\nWilliam understands that with his every action he attracts more and more attention from the exchange's security team, so the number of his actions must not exceed 5000 and after every operation no variable can have an absolute value greater than 1018. William can perform actions of two types for two chosen variables with indices i and j, where i<j:\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u226420). Description of the test cases follows.\nThe first line of each test case contains a single even integer n (2\u2264n\u2264103), which is the number of internal variables.\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264109), which are initial values of internal variables.\nFor each test case print the answer in the following format:\nThe first line of output must contain the total number of actions k, which the strategy will perform. Note that you do not have to minimize k. The inequality k\u22645000 must be satisfied. \nEach of the next k lines must contain actions formatted as \"type i j\", where \"type\" is equal to \"1\" if the strategy needs to perform an assignment of the first type and \"2\" if the strategy needs to perform an assignment of the second type. Note that i<j should hold.\nWe can show that an answer always exists.\nFor the first sample test case one possible sequence of operations is as follows:\nFor the second sample test case one possible sequence of operations is as follows:",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1521A": {
        "title": "A. Nastia and Nearly Good Numbers",
        "description": "Nastia has 22 positive integers A and B. She defines that:\nFor example, if A=6 and B=4, the integers 24 and 72 are good, the integers 6, 660 and 12 are nearly good, the integers 16, 7 are neither good nor nearly good.\nFind 3 different positive integers x, y, and z such that exactly one of them is good and the other 2 are nearly good, and x+y=z.\nThe first line contains a single integer t (1\u2264t\u226410000)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains two integers A and B (1\u2264A\u2264106, 1\u2264B\u2264106)\u00a0\u2014 numbers that Nastia has.\nFor each test case print: \nIf there are multiple answers, print any.\nIn the first test case: 60\u00a0\u2014 good number; 10 and 50\u00a0\u2014 nearly good numbers.\nIn the second test case: 208\u00a0\u2014 good number; 169 and 39\u00a0\u2014 nearly good numbers.\nIn the third test case: 154\u00a0\u2014 good number; 28 and 182\u00a0\u2014 nearly good numbers.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1520D": {
        "title": "D. Same Differences",
        "description": "You are given an array a of n integers. Count the number of pairs of indices (i,j) such that i<j and aj\u2212ai=j\u2212i.\nThe first line contains one integer t (1\u2264t\u2264104). Then t test cases follow.\nThe first line of each test case contains one integer n (1\u2264n\u22642\u22c5105).\nThe second line of each test case contains n integers a1,a2,\u2026,an (1\u2264ai\u2264n)\u00a0\u2014 array a.\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case output the number of pairs of indices (i,j) such that i<j and aj\u2212ai=j\u2212i.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "data structures",
            "hashing",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1520C": {
        "title": "C. Not Adjacent Matrix",
        "description": "We will consider the numbers aa and b as adjacent if they differ by exactly one, that is, |a\u2212b|=1.\nWe will consider cells of a square matrix n\u00d7n as adjacent if they have a common side, that is, for cell (r,c) cells (r,c\u22121), (r,c+1), (r\u22121,c) and (r+1,c) are adjacent to it.\nFor a given number n, construct a square matrix n\u00d7n such that: \nThe first line contains one integer t (1\u2264t\u2264100). Then t test cases follow.\nEach test case is characterized by one integer n (1\u2264n\u2264100).\nFor each test case, output: \nThe matrix should be outputted as n lines, where each line contains n integers.",
        "time_limit": "time limit per test4 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1517B": {
        "title": "B. Morning Jogging",
        "description": "The 2050 volunteers are organizing the \"Run! Chase the Rising Sun\" activity. Starting on Apr 25 at 7:30 am, runners will complete the 6km trail around the Yunqi town.\nThere are n+1n+1 checkpoints on the trail. They are numbered by 0, 1, ..., n. A runner must start at checkpoint 0 and finish at checkpoint n. No checkpoint is skippable\u00a0\u2014 he must run from checkpoint 0 to checkpoint 1, then from checkpoint 1 to checkpoint 2 and so on. Look at the picture in notes section for clarification.\nBetween any two adjacent checkpoints, there are m different paths to choose. For any 1\u2264i\u2264n, to run from checkpoint i\u22121 to checkpoint i, a runner can choose exactly one from the m possible paths. The length of the j-th path between checkpoint i\u22121 and i is bi,j for any 1\u2264j\u2264m and 1\u2264i\u2264n.\nTo test the trail, we have m runners. Each runner must run from the checkpoint 0 to the checkpoint n once, visiting all the checkpoints. Every path between every pair of adjacent checkpoints needs to be ran by exactly one runner. If a runner chooses the path of length li between checkpoint i\u22121 and i (1\u2264i\u2264n), his tiredness is nmini=1li, i.\u00a0e. the minimum length of the paths he takes.\nPlease arrange the paths of the m runners to minimize the sum of tiredness of them.\nEach test contains multiple test cases. The first line contains the number of test cases t (1\u2264t\u226410000). Description of the test cases follows.\nThe first line of each test case contains two integers n and m (1\u2264n,m\u2264100).\nThe i-th of the next n lines contains m integers bi,1, bi,2, ..., bi,m (1\u2264bi,j\u2264109).\nIt is guaranteed that the sum of n\u22c5m over all test cases does not exceed 104.\nFor each test case, output n lines. The j-th number in the i-th line should contain the length of the path that runner j chooses to run from checkpoint i\u22121 to checkpoint i. There should be exactly m integers in the i-th line and these integers should form a permuatation of bi,1, ..., bi,m for all 1\u2264i\u2264n.\nIf there are multiple answers, print any.\nIn the first case, the sum of tiredness is min(2,5)+min(3,3)+min(4,1)=6.\nIn the second case, the sum of tiredness is min(2,4,3)+min(3,1,5)=3.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "sortings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1515B": {
        "title": "B. Phoenix and Puzzle",
        "description": "Phoenix is playing with a new puzzle, which consists of n identical puzzle pieces. Each puzzle piece is a right isosceles triangle as shown below.\nThe goal of the puzzle is to create a square using the n pieces. He is allowed to rotate and move the pieces around, but none of them can overlap and all n pieces must be used (of course, the square shouldn't contain any holes as well). Can he do it?\nThe input consists of multiple test cases. The first line contains an integer t (1\u2264t\u2264104)\u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (1\u2264n\u2264109)\u00a0\u2014 the number of puzzle pieces.\nFor each test case, if Phoenix can create a square with the n puzzle pieces, print YES. Otherwise, print NO.\nFor n=2, Phoenix can create a square like this:\nFor n=4, Phoenix can create a square like this:\nFor n=6, it is impossible for Phoenix to create a square.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "geometry",
            "math",
            "number theory",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1514B": {
        "title": "B. AND 0, Sum Big",
        "description": "Baby Badawy's first words were \"AND 0 SUM BIG\", so he decided to solve the following problem. Given two integers n and k, count the number of arrays of length n such that:\nSince the answer can be very large, print its remainder when divided by 109+7.\nThe first line contains an integer t (1\u2264t\u226410)\u00a0\u2014 the number of test cases you need to solve.\nEach test case consists of a line containing two integers n and k (1\u2264n\u2264105, 1\u2264k\u226420).\nFor each test case, print the number of arrays satisfying the conditions. Since the answer can be very large, print its remainder when divided by 109+7.\nIn the first example, the 4 arrays are:",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "bitmasks",
            "combinatorics",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1512D": {
        "title": "D. Corrupted Array",
        "description": "You are given a number nn and an array b1,b2,\u2026,bn+2, obtained according to the following algorithm: \nFor example, the array b=[2,3,7,12,2] it could be obtained in the following ways: \nFor the given array b, find any array a that could have been guessed initially.\nThe first line contains a single integer t (1\u2264t\u2264104). Then t test cases follow.\nThe first line of each test case contains a single integer n (1\u2264n\u22642\u22c5105).\nThe second row of each test case contains n+2 integers b1,b2,\u2026,bn+2 (1\u2264bi\u2264109).\nIt is guaranteed that the sum of n over all test cases does not exceed 2\u22c5105.\nFor each test case, output: \nIf there are several arrays of a, you can output any.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "data structures",
            "greedy",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1512C": {
        "title": "C. A-B Palindrome",
        "description": "You are given a string s consisting of the characters '0', '1', and '?'. You need to replace all the characters with '?' in the string s by '0' or '1' so that the string becomes a palindrome and has exactly a characters '0' and exactly b characters '1'. Note that each of the characters '?' is replaced independently from the others.\nA string t of length n is called a palindrome if the equality t[i]=t[n\u2212i+1] is true for all i (1\u2264i\u2264n).\nFor example, if s=\"01?????0\", a=4 and b=4, then you can replace the characters '?' in the following ways: \nFor the given string s and the numbers a and b, replace all the characters with '?' in the string s by '0' or '1' so that the string becomes a palindrome and has exactly a characters '0' and exactly b characters '1'.\nThe first line contains a single integer t (1\u2264t\u2264104). Then t test cases follow.\nThe first line of each test case contains two integers a and b (0\u2264a,b\u22642\u22c5105, a+b\u22651).\nThe second line of each test case contains the string s of length a+b, consisting of the characters '0', '1', and '?'.\nIt is guaranteed that the sum of the string lengths of s over all test cases does not exceed 2\u22c5105.\nFor each test case, output: \nIf there are several suitable ways to replace characters, you can output any.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "implementation",
            "strings",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1511C": {
        "title": "C. Yet Another Card Deck",
        "description": "You have a card deck of n cards, numbered from top to bottom, i.\u00a0e. the top card has index 1 and bottom card\u00a0\u2014 index n. Each card has its color: the i-th card has color ai.\nYou should process q queries. The j-th query is described by integer tj. For each query you should: \nThe first line contains two integers n and q (2\u2264n\u22643\u22c5105; 1\u2264q\u22643\u22c5105)\u00a0\u2014 the number of cards in the deck and the number of queries.\nThe second line contains n integers a1,a2,\u2026,an (1\u2264ai\u226450)\u00a0\u2014 the colors of cards.\nThe third line contains q integers t1,t2,\u2026,tq (1\u2264tj\u226450)\u00a0\u2014 the query colors. It's guaranteed that queries ask only colors that are present in the deck.\nPrint q integers\u00a0\u2014 the answers for each query.\nDescription of the sample: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "data structures",
            "implementation",
            "trees",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1511B": {
        "title": "B. GCD Length",
        "description": "You are given three integers a, b and c.\nFind two positive integers x and y (x>0, y>0) such that: \ngcd(x,y) denotes the greatest common divisor (GCD) of integers x and y.\nOutput x and y. If there are multiple answers, output any of them.\nThe first line contains a single integer t (1\u2264t\u2264285)\u00a0\u2014 the number of testcases.\nEach of the next t lines contains three integers a, b and c (1\u2264a,b\u22649, 1\u2264c\u2264min(a,b))\u00a0\u2014 the required lengths of the numbers.\nIt can be shown that the answer exists for all testcases under the given constraints.\nAdditional constraint on the input: all testcases are different.\nFor each testcase print two positive integers\u00a0\u2014 x and y (x>0, y>0) such that \nIn the example: ",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "number theory",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1510K": {
        "title": "K. King's Task",
        "description": "The brave Knight came to the King and asked permission to marry the princess. The King knew that the Knight was brave, but he also wanted to know if he was smart enough. So he asked him to solve the following task.\nThere is a permutation pi of numbers from 1 to 2n. You can make two types of operations. \nThe task is to find the minimal number of operations required to sort the given permutation.\nThe Knight was not that smart actually, but quite charming, so the princess asks you to help him to solve the King's task.\nThe first line contains the integer n (1\u2264n\u22641000). The second line contains 2n integers pi\u00a0\u2014 the permutation of numbers from 1 to 2n.\nPrint one integer\u00a0\u2014 the minimal number of operations required to sort the permutation. If it is impossible to sort the permutation using these operations, print \u22121.\nIn the first example, you can sort the permutation in three operations: ",
        "time_limit": "time limit per test3 seconds",
        "memory_limit": "memory limit per test512 megabytes",
        "tags": [
            "brute force",
            "graphs",
            "implementation",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1509B": {
        "title": "B. TMT Document",
        "description": "The student council has a shared document file. Every day, some members of the student council write the sequence TMT (short for Towa Maji Tenshi) in it.\nHowever, one day, the members somehow entered the sequence into the document at the same time, creating a jumbled mess. Therefore, it is Suguru Doujima's task to figure out whether the document has malfunctioned. Specifically, he is given a string of length n whose characters are all either T or M, and he wants to figure out if it is possible to partition it into some number of disjoint subsequences, all of which are equal to TMT. That is, each character of the string should belong to exactly one of the subsequences.\nA string a is a subsequence of a string b if a can be obtained from b by deletion of several (possibly, zero) characters.\nThe first line contains an integer t (1\u2264t\u22645000) \u00a0\u2014 the number of test cases.\nThe first line of each test case contains an integer n (3\u2264n<105), the number of characters in the string entered in the document. It is guaranteed that n is divisible by 3.\nThe second line of each test case contains a string of length n consisting of only the characters T and M.\nIt is guaranteed that the sum of n over all test cases does not exceed 105.\nFor each test case, print a single line containing YES if the described partition exists, and a single line containing NO otherwise.\nIn the first test case, the string itself is already a sequence equal to TMT.\nIn the third test case, we may partition the string into the subsequences TMTMTT. Both the bolded and the non-bolded subsequences are equal to TMT.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1506C": {
        "title": "C. Double-ended Strings",
        "description": "You are given the strings a and b, consisting of lowercase Latin letters. You can do any number of the following operations in any order: \nNote that after each of the operations, the string a or b may become empty.\nFor example, if a=\"hello\" and b=\"icpc\", then you can apply the following sequence of operations: \nFor the given strings a and b, find the minimum number of operations for which you can make the strings a and b equal. Note that empty strings are also equal.\nThe first line contains a single integer t (1\u2264t\u2264100). Then t test cases follow.\nThe first line of each test case contains the string a (1\u2264|a|\u226420), consisting of lowercase Latin letters.\nThe second line of each test case contains the string b (1\u2264|b|\u226420), consisting of lowercase Latin letters.\nFor each test case, output the minimum number of operations that can make the strings a and b equal.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "implementation",
            "strings",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1506B": {
        "title": "B. Partial Replacement",
        "description": "You are given a number k and a string s of length n, consisting of the characters '.' and '*'. You want to replace some of the '*' characters with 'x' characters so that the following conditions are met: \nFor example, if n=7, s=.**.*** and k=3, then the following strings will satisfy the conditions above: \nGiven n, k, and s, find the minimum number of '*' characters that must be replaced with 'x' in order to meet the above conditions.\nThe first line contains one integer t (1\u2264t\u2264500). Then t test cases follow.\nThe first line of each test case contains two integers n and k (1\u2264k\u2264n\u226450).\nThe second line of each test case contains a string s of length n, consisting of the characters '.' and '*'.\nIt is guaranteed that there is at least one '*' in the string s.\nIt is guaranteed that the distance between any two neighboring '*' characters does not exceed k.\nFor each test case output the minimum number of '*' characters that must be replaced with 'x' characters in order to satisfy the conditions above.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "greedy",
            "implementation",
            "*1100"
        ],
        "solution": "Solution not found"
    },
    "1504B": {
        "title": "B. Flip the Bits",
        "description": "There is a binary string aa of length n. In one operation, you can select any prefix of a with an equal number of 0 and 1 symbols. Then all symbols in the prefix are inverted: each 0 becomes 1 and each 1 becomes 0.\nFor example, suppose a=0111010000. \nCan you transform the string a into the string b using some finite number of operations (possibly, none)?\nThe first line contains a single integer t (1\u2264t\u2264104) \u2014 the number of test cases.\nThe first line of each test case contains a single integer n (1\u2264n\u22643\u22c5105) \u2014 the length of the strings a and b.\nThe following two lines contain strings a and b of length n, consisting of symbols 0 and 1.\nThe sum of n across all test cases does not exceed 3\u22c5105.\nFor each test case, output \"YES\" if it is possible to transform a into b, or \"NO\" if it is impossible. You can print each letter in any case (upper or lower).\nThe first test case is shown in the statement.\nIn the second test case, we transform a into b by using zero operations.\nIn the third test case, there is no legal operation, so it is impossible to transform a into b.\nIn the fourth test case, here is one such transformation: \nIn the fifth test case, the only legal operation is to transform a into 111000. From there, the only legal operation is to return to the string we started with, so we cannot transform a into b.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "greedy",
            "implementation",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    },
    "1499B": {
        "title": "B. Binary Removals",
        "description": "You are given a string s, consisting only of characters '0' or '1'. Let |s| be the length of s.\nYou are asked to choose some integer k (k>0) and find a sequence a of length k such that: \nThe characters at positions a1,a2,\u2026,ak are removed, the remaining characters are concatenated without changing the order. So, in other words, the positions in the sequence a should not be adjacent.\nLet the resulting string be s\u2032. s\u2032 is called sorted if for all i from 2 to |s\u2032| s\u2032i\u22121\u2264s\u2032i.\nDoes there exist such a sequence a that the resulting string s\u2032 is sorted?\nThe first line contains a single integer t (1\u2264t\u22641000)\u00a0\u2014 the number of testcases.\nThen the descriptions of t testcases follow.\nThe only line of each testcase contains a string s (2\u2264|s|\u2264100). Each character is either '0' or '1'.\nFor each testcase print \"YES\" if there exists a sequence a such that removing the characters at positions a1,a2,\u2026,ak and concatenating the parts without changing the order produces a sorted string.\nOtherwise, print \"NO\".\nYou may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES are all recognized as positive answer).\nIn the first testcase you can choose a sequence a=[1,3,6,9]. Removing the underlined letters from \"10101011011\" will produce a string \"0011111\", which is sorted.\nIn the second and the third testcases the sequences are already sorted.\nIn the fourth testcase you can choose a sequence a=[3]. s\u2032= \"11\", which is sorted.\nIn the fifth testcase there is no way to choose a sequence a such that s\u2032 is sorted.",
        "time_limit": "time limit per test2 seconds",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "brute force",
            "dp",
            "greedy",
            "implementation",
            "*1000"
        ],
        "solution": "Solution not found"
    },
    "1497C1": {
        "title": "C1. k-LCM (easy version)",
        "description": "It is the easy version of the problem. The only difference is that in this version k=3k=3.\nYou are given a positive integer n. Find k positive integers a1,a2,\u2026,ak, such that:\nHere LCM is the least common multiple of numbers a1,a2,\u2026,ak.\nWe can show that for given constraints the answer always exists.\nThe first line contains a single integer t (1\u2264t\u2264104) \u00a0\u2014 the number of test cases.\nThe only line of each test case contains two integers n, k (3\u2264n\u2264109, k=3).\nFor each test case print k positive integers a1,a2,\u2026,ak, for which all conditions are satisfied.",
        "time_limit": "time limit per test1 second",
        "memory_limit": "memory limit per test256 megabytes",
        "tags": [
            "constructive algorithms",
            "math",
            "*1200"
        ],
        "solution": "Solution not found"
    }
}